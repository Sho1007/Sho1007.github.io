---
title: "프로세스 상태와 계층 구조"
category:
- OperatingSystem
tag:
- OperatingSystem
- HonGong
toc: true
toc_sticky: true
date: 2024-07-02
last-modified-at: 2024-07-02
---

# 프로세스 상태
PCB에 기록되는 프로세스의 상태 
## 생성 상태
* 이제 막 메모리에 적재되어 PBC를 할당 받은 상태
* 준비가 완료되었다면 `준비 상태`로
## 준비 상태
* 당장이라도 CPU를 할당 받아 실행할 수 있지만,
* 자신의 차례가 아니므로 기다리는 상태
* 자신의 차례가 되면, `실행 상태`로 (디스패치)
## 실행 상태
* CPU를 할당 받아 실행 중인 상태
* 할당된 시간을 모두 사용 시 (타이머 인터럽트 발생 시) `준비 상태`로
* 실행 도중 입출력 장치를 사용하면 입출력 작업이 끝날 때까지 `대기 상태`로
## 대기 상태
* 프로세스가 실행 도중 입출력 장치를 사용하는 경우
* 입출력 작업은 CPU에 비해 느리므로 이 경우 대기 상태로 접어듦
* 입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) `준비 상태`로
## 종료 상태
* 프로세스가 종료된 상태
* PCB, 프로세스의 메모리 영역 정리

# 프로세스 계층 구조
* 프로세스 실행 도중 (시스템 호출을 통해) 다른 프로세스를 생성 가능
* 새 프로세스를 생성한 프로세스 : 부모 프로세스
* 부모 프로세스에 의해 생성된 프로세스 : 자식 프로세스
> 윈도우는 프로세스를 계층적으로 관리하지 않는다.   
> 부모 프로세스와 자식 프로세스는 (개별 프로세스이므로) 별개의 PID를 가진다.  
> 일부 운영체제에서는 PCB에 부모의 PID인 PPID 를 기록하기도 한다.
* 최초의 프로세스 : 리눅스 (systemd) / MacOS(launchd)

# 프로세스 생성 기법
부모 프로세스는 자식 프로세스를 어떻게 만들어내고,   
자식 프로세스는 자신만의 코드를 어떻게 실행할까?   
> 윈도우 운영체제와는 역시나 관련이 없다.
## fork (복제) 시스템 호출 -> 부모가 호출
* 복사본 (= 자식 프로세스) 생성
* 부모 프로세스의 자원을 상속
* PID와 메모리 위치 등은 다르다
## exec (옷 갈아입기) 시스템 호출 -> 자식이 호출
*  메모리 공간을 새로운 프로그램으로 덮어쓰기
* 코드 / 데이터 영역은 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화