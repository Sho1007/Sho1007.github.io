---
title: "84021 퍼즐 조각 채우기"
category:
- Programmers
tag:
- Algorithm
- CodingTest
- Cpp
- TIL
- Graph
- BFS
toc: true
toc_sticky: true
date: 2024-04-16
last-modified-at: 2024-04-16
---

# 84021. 퍼즐 조각 채우기 / c++ / level3 / 1시간 20분

## 문제 및 코드

[<img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100"/>](https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/84021.%E2%80%85%ED%8D%BC%EC%A6%90%E2%80%85%EC%A1%B0%EA%B0%81%E2%80%85%EC%B1%84%EC%9A%B0%EA%B8%B0)

## 접근 방식
### BFS
1. 테이블의 퍼즐을 보드의 빈칸에 맞춰야한다.
2. 테이블의 퍼즐을 탐색한다. (BFS)
3. 퍼즐을 3번 돌려 총 4개의 회전된 퍼즐을 찾는다.   
    1. 한번도 돌리지 않은 퍼즐 
    2. 시계방향으로 90도 회전하게 되면 1번 상태의 X,Y좌표값이 바뀌고 X값의 부호가 반대가 된다.
    3. 180도 회전은 3-1번 상태에서 X, Y의 부호가 모두 반대이다.
    4. 270도 회전은 3-2번 상태에서 X, Y의 부호가 모두 반대이다.
4. 이 때 퍼즐을 절대 좌표가 아닌, 처음 발견한 점 기준으로 상대좌표로 체크한다.
5. 빈칸과의 비교가 용이하도록 퍼즐의 좌표배열을 정렬한다.
6. 보드를 순회하며 아직 채워지지 않은 빈칸 발견시 빈칸역시도 BFS로 탐색한다.   
    (이 때 빈칸을 채우며 탐색, 빈칸의 발견 칸 기준 상대 좌표로 체크)
7. 탐색한 빈칸의 배열도 비교가 용이하도록 정렬한다.
8. 그 후 퍼즐 배열을 순회하며
    1. 우선 퍼즐의 칸 개수와 빈칸의 개수가 같은지 확인
    2. 같다면 빈칸이 퍼즐로 매꿔지는지 배열의 일치성을 확인
    3. 일치한다면 빈칸의 갯수를 answer에 더한다.   
    (이 때, 중복 사용을 방지하기 위해 해당 블록은 사용됐음을 표시)
    4. 일치하지 않는다면 빈칸을 다시 비워둔다. (6번에서 채웠기 때문)
9. answer 를 반환한다.




## 생각해 볼 점
1. 블록 회전과 같은 문제들은 재료 손질 단계에서 미리 값을 다 구하고 푸는게 속도가 빠른 것 같다.
2. 만약 한 무리의 빈칸에 블럭 하나로 꽉 채우는 경우만 놓는게 아니라, 여러 블럭의 조합으로도 놓을 수 있었다면 아마 BT나 DP를 사용했어야할 것 같다.
3. 한번 빈칸을 발견하면 매칭되는 블럭을 찾을 수 있을 것이라 생각했지만, 상대 좌표이기 때문에 어느 칸이 기준 점인지에 따라 같은 블럭이어도 매칭되지 않을 수 있었다.
4. 이 경우엔 다시 빈칸을 풀어주고 다른 칸에서 발견시에 다시 매칭을 검사하는 식으로 해결했다.   (시간초과가 날 것이라 생각했지만 0.01ms 정도로 꽤나 널널하게 풀렸다.)
5. 간만에 빡빡한 구현 문제를 풀게 돼서 어렵고 시간이 많이 소요됐지만 풀려서 성취감을 느꼈다.