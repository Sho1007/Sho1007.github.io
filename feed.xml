<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-06-16T12:15:34+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 28일차 TIL - 2145 Count the Hidden Sequences</title><link href="https://sho1007.github.io/leetcode/2145/" rel="alternate" type="text/html" title="99클럽 코테 스터디 28일차 TIL - 2145 Count the Hidden Sequences" /><published>2024-06-16T00:00:00+00:00</published><updated>2024-06-16T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2145</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2145/"><![CDATA[<h1 id="2145-count-the-hidden-sequences--c--medium--47분">2145. Count the Hidden Sequences / c++ / Medium / 47분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">numberOfArrays</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">differences</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">differences</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">minNum</span> <span class="o">=</span> <span class="n">differences</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="n">differences</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">differences</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="n">differences</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">&gt;</span> <span class="n">maxNum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">maxNum</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">&lt;</span> <span class="n">minNum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">minNum</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">newLower</span> <span class="o">=</span> <span class="n">lower</span> <span class="o">-</span> <span class="n">minNum</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newLower</span> <span class="o">&lt;</span> <span class="n">lower</span><span class="p">)</span> <span class="n">newLower</span> <span class="o">=</span> <span class="n">lower</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">newUpper</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">maxNum</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newUpper</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">)</span> <span class="n">newUpper</span> <span class="o">=</span> <span class="n">upper</span><span class="p">;</span>

        <span class="c1">// cout &lt;&lt; newLower &lt;&lt; ' ' &lt;&lt; newUpper &lt;&lt; '\n';</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">newUpper</span> <span class="o">&lt;</span> <span class="n">newLower</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">newUpper</span> <span class="o">-</span> <span class="n">newLower</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="배열">배열</h3>
<ol>
  <li>어떤 배열의 인접한 두 원소의 차이를 기록한 differences 배열과, 원소의 최소값 기준 lower, 최대값 기준 upper 가 주어졌을 때, 이 조건을 만족하는 배열의 개수를 반환하는 문제였다.</li>
  <li>우선 0-indexed였으므로, differences의 원소의 갯수가 0개인 경우를 상정했다.</li>
  <li>이 경우, (upper - lower + 1) 이 가능한 배열의 개수였다.</li>
  <li>다음으로 differences 배열에 원소가 있는 경우에도 3번 식을 적용할 수 있었는데, 내 생각은 모든 경우를 다 따질게 아니라, 0을 기준으로 differences를 순회하며 차이값들을 다 적용해보고, 그 중 최소값과 최대값을 찾아서 활용하는 것이었다.</li>
  <li>예를 들어, 기존 upper 가 4 인데, 0을 기준으로 찾은 배열의 최대값이 10인 경우, 배열은 최소 -6으로 시작해야한다. (그래야 최대값 10이 나오는 시점에 시작값이 0이 아닌 -6이므로, 10-6 = 4가 되어, 기존의 upper를 충족한다.)</li>
  <li>즉 조건을 만족하기 위한 시작값의 새로운 최대값 기준 newUpper, newLower을 위의 식처럼 계산하여 구한다.</li>
  <li>그리고 newUpper가 newLower보다 작으면 (같을 땐 최소 만족하는 원소가 1개라도 있음) 0을 반환, 크거나 같으면 newUpper - newLower + 1을 반환한다. (3번식과 유사)</li>
  <li>하지만 여기서 문제가 생겼다. 이건 leetcode의 좋은 점이자 안좋은 점인데, 틀리면 틀린 케이스를 보여준다는 것이다. 내가 발견한 문제점은 newUpper가 기존의 upper보다 큰 경우였다. (이러면 7번식으로 계산한 값이 upper을 초과하여 조건이 성립하지 않는다.)</li>
  <li>그래서 생각해낸게, newUpper가 upper를 초과하면, newUpper 값 대신 upper 값을 쓰는 것이었다. (newLower도 마찬가지)</li>
  <li>그렇게 수정했더니 통과했다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>배열의 규칙 (최대값 - 최소값 + 1)을 찾아서 해결한 문제라 뿌듯했다.</li>
  <li>0-indexed 문제는 해결했는데, newUpper가 upper보다 커질거라고는 생각하지 못했다. 만약 실제 코딩 테스트였다면 왜 틀렸는지 몰랐을 것이다. (이런 부분을 잘 찾아내는게 중요하다는걸 다시 한번 느낀다.)</li>
  <li>중간에 minNum,maxNum 을 구할 때, int의 범위를 넘어가서 long long 으로 바꿔서 해결했다. (배열의 원소가 int여서 current를 int로 선언했었는데, 뭔가 수식 도중에 갑싱 넘쳤던 것 같다.)</li>
  <li>여러모로 자료형과 제한 범위에 대해 생각해 볼 수 있는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Array" /><summary type="html"><![CDATA[2145. Count the Hidden Sequences / c++ / Medium / 47분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 27일차 TIL - 2861 Maximum Number of Alloys</title><link href="https://sho1007.github.io/leetcode/2861/" rel="alternate" type="text/html" title="99클럽 코테 스터디 27일차 TIL - 2861 Maximum Number of Alloys" /><published>2024-06-15T00:00:00+00:00</published><updated>2024-06-15T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2861</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2861/"><![CDATA[<h1 id="2861-maximum-number-of-alloys--c--medium--1시간">2861. Maximum Number of Alloys / c++ / Medium / 1시간</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">CheckMakeAlloys</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">composition</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">stock</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">cost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">currentBudget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">needCount</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">composition</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">stock</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">needCount</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                <span class="n">currentBudget</span> <span class="o">+=</span> <span class="p">(</span><span class="n">needCount</span> <span class="o">-</span> <span class="n">stock</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">cost</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">currentBudget</span> <span class="o">&lt;=</span> <span class="n">budget</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">maxNumberOfAlloys</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">composition</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">stock</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">987'654'321</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">answer</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">CheckMakeAlloys</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">budget</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">stock</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">mid</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">answer</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="배열--이분탐색">배열 / 이분탐색</h3>
<ol>
  <li>갯수를 기준으로 이분탐색을 해서, k개의 기계 중 mid 개 만큼의 합금을 budget 이하의 금액으로 만들 수 있는 최대 mid 를 반환하는 문제였다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이분탐색 치고는 조건이 많이 들어가는 편이었고, 명확한 제한값도 찾지 못해서 꽤나 번거로웠다.</li>
  <li>count개의 합금을 만들 때, stock[j]개만큼을 빼고 계산해야한는데 그 식을 composition[i][j] * (count - stock[j]) * cost[j] 로 계산해서 틀렸었다. (count개를 만들 때, 합금 한개 당 composition[i][j]만큼의 광석이 들어가므로, 제대로 된 식은 (composition[i][j] * count - stock[j]) * cost[j] 이다.)</li>
  <li>별 생각없이 left값을 1로 설정해서 또 한번 틀렸었다. (최대 한개도 만들 수 없으므로, 0으로 설정해야했다.)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Array" /><category term="BinarySearch" /><summary type="html"><![CDATA[2861. Maximum Number of Alloys / c++ / Medium / 1시간]]></summary></entry><entry><title type="html">99클럽 코테 스터디 26일차 TIL - 275 H-Index II</title><link href="https://sho1007.github.io/leetcode/275/" rel="alternate" type="text/html" title="99클럽 코테 스터디 26일차 TIL - 275 H-Index II" /><published>2024-06-14T00:00:00+00:00</published><updated>2024-06-14T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/275</id><content type="html" xml:base="https://sho1007.github.io/leetcode/275/"><![CDATA[<h1 id="275-h-index-ii--c--medium--4분">275. H-Index II / c++ / Medium / 4분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">hIndex</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">citations</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">citations</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">citations</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">citations</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">citations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">citations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">citations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="배열--정렬">배열 / 정렬</h3>
<ol>
  <li>H-Index는 h번 이상 인용된 논문이 h개 이상일 때의 최대값이다.</li>
  <li>우선 배열을 정렬한뒤, 순회한다.</li>
  <li>순회하면서 현재 남은 논문 갯수 (citations.size()-i)보다 현재 논문의 인용 횟수(citations[i])가 크거나 같다면, H-Index는 는 남은 논문의 갯수이므로 그것을 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>H-Index는 백준에서 이미 풀어본 경험이 있는 문제여서 쉽게 풀 수 있었다.</li>
  <li>백준에서 처음 이 문제를 접했을 때는 최대값 범위를 어떻게 잡아야하고 어떻게 접근할지 감이 잘 안왔었는데, 그 때 제대로 이해하고 넘어가니 다음에 다시 이 문제가 나왔을 때, 쉽게 다시 풀 수 있었던 것 같다.</li>
  <li>h-index는 결국 논문의 개수로 제한되니 최대값은 최대 논문의 개수이다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Array" /><summary type="html"><![CDATA[275. H-Index II / c++ / Medium / 4분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 25일차 TIL - 1971 Find if Path Exists in Graph</title><link href="https://sho1007.github.io/leetcode/1971/" rel="alternate" type="text/html" title="99클럽 코테 스터디 25일차 TIL - 1971 Find if Path Exists in Graph" /><published>2024-06-13T00:00:00+00:00</published><updated>2024-06-13T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/1971</id><content type="html" xml:base="https://sho1007.github.io/leetcode/1971/"><![CDATA[<h1 id="1971-find-if-path-exists-in-graph--c--easy--26분">1971. Find if Path Exists in Graph / c++ / Easy / 26분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">Find</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">num</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">parentA</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">parentB</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">parentA</span> <span class="o">==</span><span class="n">parentB</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">parent</span><span class="p">[</span><span class="n">parentB</span><span class="p">]</span> <span class="o">=</span> <span class="n">parentA</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">validPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Union</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">Find</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">==</span> <span class="n">Find</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="유니온파인드">유니온파인드</h3>
<ol>
  <li>양방향 그래프에서 두 정점 사이의 경로가 존재하는지를 반환하는 문제였다.</li>
  <li>유니온파인드(디스조인트셋/서로소 집합)을 사용하면 두 정점의 부모가 같을 경우 두 정점의 경로가 존재함을 알 수 있다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>99클럽의 챌린저 문제 치고는 너무 쉬웠다. (리트 코드 난이도 조차도 easy)</li>
  <li>아마 source 정점에서 BFS나 DFS등을 써서 destination 정점까지 도착할 수 있는지를 파악할 수도 있을 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="UnionFind" /><summary type="html"><![CDATA[1971. Find if Path Exists in Graph / c++ / Easy / 26분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 24일차 TIL - 49190 방의 개수</title><link href="https://sho1007.github.io/programmers/49190/" rel="alternate" type="text/html" title="99클럽 코테 스터디 24일차 TIL - 49190 방의 개수" /><published>2024-06-12T00:00:00+00:00</published><updated>2024-06-12T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/49190</id><content type="html" xml:base="https://sho1007.github.io/programmers/49190/"><![CDATA[<h1 id="49190-방의-개수--c--level5--2시간">49190. 방의 개수 / c++ / level5 / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/5/49190.%E2%80%85%EB%B0%A9%EC%9D%98%E2%80%85%EA%B0%9C%EC%88%98"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프">그래프</h3>
<ol>
  <li>방을 만드는 조건을 찾아야했다.
    <ol>
      <li>이미 방문한 좌표를 다시 방문할 때 방이 생성됐다.</li>
      <li>방문한적 없는 간선(arrow)로 방문해야 방이 생성됐다.</li>
    </ol>
  </li>
  <li>unordered_set으로 좌표와 간선의 방문여부를 체크했고, 테스트 케이스를 통과했지만, 문제는 틀렸다.</li>
  <li>아무리 생각해도 이유를 알 수 없어서, 다른 분들의 접근 방법을 찾아봤다.</li>
  <li>점 4개를 모래시계 형태로 교차해서 지나가게 되면, 이론상 방이 1개 생성되어야 하지만, 실제로는 방이 2개가 생성됐다.</li>
  <li>좌표 문제에서 가끔 나오는, 정밀도의 문제 (내가 이름지은..) 였다.</li>
  <li>이 문제의 해결법은 좌표계 자체를 2배씩 키우고, 한번 하던 이동을 2번으로 바꿔주는 것이었다.</li>
  <li>arrows의 각 원소를 2번씩으로 늘린, newArrows를 만들고, 이전까지의 로직을 newArrows를 기반으로 실행했더니 통과했다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>level5문제는 아마 이번이 처음 푼 것 같다.</li>
  <li>이쯤오니 문제가 정확히 요구하는 바가 무엇인지 안에 숨어있는 원리를 찾아내는게 정말 중요하게 느껴졌다.</li>
  <li>특히 좌표계가 나오면 항상 정밀도 문제를 생각해봐야겠다. (와 모래시계 모양으로 꽈서 연결하는건 정말 생각하지 못했다…)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><summary type="html"><![CDATA[49190. 방의 개수 / c++ / level5 / 2시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 23일차 TIL - 786 K-th Smallest Prime Fraction</title><link href="https://sho1007.github.io/leetcode/786/" rel="alternate" type="text/html" title="99클럽 코테 스터디 23일차 TIL - 786 K-th Smallest Prime Fraction" /><published>2024-06-11T00:00:00+00:00</published><updated>2024-06-11T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/786</id><content type="html" xml:base="https://sho1007.github.io/leetcode/786/"><![CDATA[<h1 id="786-k-th-smallest-prime-fraction--c--medium--14분">786. K-th Smallest Prime Fraction / c++ / Medium / 14분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">kthSmallestPrimeFraction</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]});</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">bool</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">});</span>

        <span class="k">return</span> <span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>문제는 1과 소수로 이루어진 정렬된 배열에서 원소 2개를 겹치지 않게 뽑아서 분수 (분자/분모 순) 을 만들었을 때,
k 번째로 작은 수가 되는 경우를 구하는 것이었다.</li>
  <li>일단 조합의 모든 경우를 다 새로운 vector&lt;vector<int>&gt; vec에 넣어준다.</int></li>
  <li>그리고 정렬을 할 때, a[0] * b[1] &lt; b[0] * a[1] 식으로 정렬해준다. (결국 분수의 비교라 함은, 분모가 같은 상황에서 분자의 값이 작은 경우이고, 분모가 같으려면 두 분수의 분자 분모에 각 수를 곱해주면 되므로)</li>
  <li>그런뒤 vec[k-1]을 반환 (0부터 시작하므로)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이분 탐색 문제로 내준건데, 단순 정렬로도 풀 수 있어서 생각보다 빨리 풀었다. (효율은 떨어지지만)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[786. K-th Smallest Prime Fraction / c++ / Medium / 14분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 22일차 TIL - 43236 징검다리</title><link href="https://sho1007.github.io/programmers/43236/" rel="alternate" type="text/html" title="99클럽 코테 스터디 22일차 TIL - 43236 징검다리" /><published>2024-06-10T00:00:00+00:00</published><updated>2024-06-10T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43236</id><content type="html" xml:base="https://sho1007.github.io/programmers/43236/"><![CDATA[<h1 id="43236-징검다리--c--level4--2시간">43236. 징검다리 / c++ / level4 / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/4/43236.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="이분탐색">이분탐색</h3>
<ol>
  <li>결론은 돌을 n개 이하로 제거했을 때, 시작점(0), 각 다리 사이의 거리, 끝점(distance)가 모두 x이상일 때, 이 x에 들어갈 수 있는 수 중 가장 큰 값을 구하는 문제였다.</li>
  <li>이분탐색을 안쓰고 정렬이랑 우선순위큐를 써서 풀어보려고 시간을 엄청 썼다.</li>
  <li>결국 이분탐색으로 풀었는데, AI가 무슨 시작점과 끝점은 상관 없고, 각 돌 사이의 거리만 구하라고 해서, 내가 문제를 잘못 읽었나보다 하고 그렇게 풀었는데, 틀렸다.</li>
  <li>다시 결과를 보니 내가 원래 읽었던 게 맞았다. 프로그래머스 AI는 문제가 많아 보인다.</li>
  <li>마지막 돌과 distance까지의 거리를 어떻게 구할까 고민했는데, (그 돌이 제거됐는지에 따라 달라지므로)</li>
  <li>그냥 매번 비교할 때, 이전돌과의 거리 &amp; distance와의 거리가 모두 mid 이상인지 체크하고, 아니면 제거하면 됐었다. (이걸 생각해내기까지 또 오래 걸렸다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>level4 문제는 맛있다. 그런데 너무 오래 걸려서 붙잡고 있다보면 시간이 사라진다.</li>
  <li>그래도 계속 풀다보면 익숙해지고 점차 속도가 붙지 않을까 생각하고 있다.</li>
  <li>99클럽 덕분에 기존에는 잘 도전하지 않던 문제들도 많이 접하게 돼서 도움이 된다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="BinarySearch" /><summary type="html"><![CDATA[43236. 징검다리 / c++ / level4 / 2시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 21일차 TIL - 42897 도둑질</title><link href="https://sho1007.github.io/programmers/42897/" rel="alternate" type="text/html" title="99클럽 코테 스터디 21일차 TIL - 42897 도둑질" /><published>2024-06-09T00:00:00+00:00</published><updated>2024-06-09T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42897</id><content type="html" xml:base="https://sho1007.github.io/programmers/42897/"><![CDATA[<h1 id="42897-도둑질--c--level4--1시간">42897. 도둑질 / c++ / level4 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/4/42897.%E2%80%85%EB%8F%84%EB%91%91%EC%A7%88"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>이런 식의 문제는 보통, 현재 칸에서 행동함 = 전 칸의 행동 안한 결과 + 현재 칸의 값 으로 풀 수 있다.</li>
  <li>다만 이 문제의 경우 순환 배열이어서 시작 원소와 마지막 원소 역시 위의 조건을 만족해야 했다.</li>
  <li>고민 끝에 내가 생각한 방법은, 배열을 아래처럼 총 4개 만들어주는 것이었다.
    <ol>
      <li>현재 집을 도둑질 함 (시작 지점을 도둑질한 경우)</li>
      <li>현재 집을 도둑질 하지 않음 (시작 지점을 도둑질한 경우)</li>
      <li>현재 집을 도둑질 함 (시작 지점을 도둑질하지 않은 경우)</li>
      <li>현재 집을 도둑질 하지 않음 (시작 지점을 도둑질하지 않은 경우)</li>
    </ol>
  </li>
  <li>이렇게 한 뒤, 맨 마지막 집 전까지만, 배열을 순회하며 dp값을 저장해주고, <br />
 맨 마지막 집의 경우 3-3번에만 값을 더 해주었다. (3-1의 경우 시작 지점을 도둑질 했기 때문에 마지막 집을 도둑질할 수 없다.)</li>
  <li>그 후, 나온 값들 중 가장 큰 값을 비교하여 반환</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>확실히 level4 문제들은 난이도가 있다고 생각이 들었다.</li>
  <li>다만 이 문제의 경우 이전에도 접해본 dp문제 유형이었는데, 거기에 시작 지점의 값도 추가로 신경써줘야하는 응용 문제여서 생각만 잘 했다면 충분히 빨리 풀 수 있었는데, 이건 좀 더 반복적으로 연습을 해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[42897. 도둑질 / c++ / level4 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 20일차 TIL - 1843 사칙연산</title><link href="https://sho1007.github.io/programmers/1843/" rel="alternate" type="text/html" title="99클럽 코테 스터디 20일차 TIL - 1843 사칙연산" /><published>2024-06-08T00:00:00+00:00</published><updated>2024-06-08T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/1843</id><content type="html" xml:base="https://sho1007.github.io/programmers/1843/"><![CDATA[<h1 id="1843-사칙연산--c--level4--1시간">1843. 사칙연산 / c++ / level4 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/4/1843.%E2%80%85%EC%82%AC%EC%B9%99%EC%97%B0%EC%82%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>식을 적절히 괄호로 감싸서 계산 순서를 정했을 때 나올 수 있는 최대 값을 구하는 문제였다.</li>
  <li>dp라는건 결국 이전 값을 다음 계산에 활용할 수 있다는 것이므로, 이걸 어떻게 문제에 대입할 수 있을지 생각해봤다.</li>
  <li>연산자 하나에 대해 양쪽 옆에 새로운 부분식이 생긴다고 했을 때, 다시 그 작은 식을 재귀적으로 해결할 수 있을거라고 생각했다.</li>
  <li>그 부분식의 계산값을 저장해두면, 매번 계산하지 않아도 되므로, 이 방법으로 풀었더니 통과했다. (이 때, 포인트는 부분식의 최대값과 최소값을 동시에 저장해서, 연산자가 - 일 때 오른쪽 부분식의 최대값과 최소값 중 어떤걸 활용하는지를 정하는 것이었다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>진짜 어려웠다. level4 문제를 정말 오랜만에 풀어봤다. 그래도 정답을 찾아보지 않고 직접 생각해서 풀어서 성취감을 느낄 수 있었다.</li>
  <li>마지막에 unordered_set으로도 시간초과가 나서 공간복잡도를 생각한 뒤, 2차원 배열로 바꾼게 효과적이었다. unordered_set 이 hash를 사용해서 일반 map보다 검색 속도가 빠르다고 하더라도, 굳이 int,int를 string으로 바꾸기보다, 2차원 배열로 직접 접근하는게 훨씬 빨랐다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[1843. 사칙연산 / c++ / level4 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 19일차 TIL - 43105 정수 삼각형</title><link href="https://sho1007.github.io/programmers/43105/" rel="alternate" type="text/html" title="99클럽 코테 스터디 19일차 TIL - 43105 정수 삼각형" /><published>2024-06-07T00:00:00+00:00</published><updated>2024-06-07T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43105</id><content type="html" xml:base="https://sho1007.github.io/programmers/43105/"><![CDATA[<h1 id="43105-정수-삼각형--c--level3--26분">43105. 정수 삼각형 / c++ / level3 / 26분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43105.%E2%80%85%EC%A0%95%EC%88%98%E2%80%85%EC%82%BC%EA%B0%81%ED%98%95"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>위에서 아래로 내려간다면, 어떤 루트를 결정해야 큰 값이 나올지 모를 수 있지만, 반대로 아래에서 위의 값을 고른다면, 무조건 둘 중 큰 값을 고르기만 하면 된다.</li>
  <li>해당 식을 DP라는 함수로 만들어서 저장 (이 때, 인자값으로 row, col 변수를 넘겨주는데, 만약 삼각형의 범위를 넘어간 값이라면 0을 리턴)</li>
  <li>맨 아랫줄의 모든 칸에 대해 DP를 수행하면, 순차적으로 위로 타고 올라가며 결국 모든 칸의 계산값이 구해지게 된다.</li>
  <li>따라서 맨 아랫줄의 계산 값 중, 가장 큰 값을 고르면 그 값이 나올 수 있는 가장 큰 값이다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>예전에 풀었던 문제라 로직 자체는 쉽게 생각해낼 수 있었는데, 배열로 선언하여 아랫줄에서 윗줄을 검사할 때는 실패가 떴었다. (아마 내가 구현을 잘못하거나, 예외처리를 빠트린게 있었겠지..?)</li>
  <li>다시 처음부터 만들 때, DP를 함수로 빼고, dp[row][col]이 계산되어 있지 않다면, 윗줄의 왼쪽 값, 오른쪽 값을 다시 재귀적으로  DP 함수를 호출하도록 구현했더니 통과했다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[43105. 정수 삼각형 / c++ / level3 / 26분]]></summary></entry></feed>