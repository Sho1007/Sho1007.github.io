<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-07-08T08:28:02+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">1823 Find the Winner of the Circular Game</title><link href="https://sho1007.github.io/leetcode/1823/" rel="alternate" type="text/html" title="1823 Find the Winner of the Circular Game" /><published>2024-07-08T00:00:00+00:00</published><updated>2024-07-08T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/1823</id><content type="html" xml:base="https://sho1007.github.io/leetcode/1823/"><![CDATA[<h1 id="1823-find-the-winner-of-the-circular-game--c--medium--5분">1823. Find the Winner of the Circular Game / c++ / Medium / 5분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<h3 id="문제-링크"><a href="https://leetcode.com/problems/find-the-winner-of-the-circular-game/description/?envType=daily-question&amp;envId=2024-07-08">문제 링크</a></h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">findTheWinner</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">removedCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">friends</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">friends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">currentPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">friends</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">currentPos</span> <span class="o">=</span> <span class="p">(</span><span class="n">currentPos</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">friends</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">friends</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">friends</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">currentPos</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">friends</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--배열">자료 구조 / 배열</h3>
<ol>
  <li>1번부터 n번까지의 친구가 있을 때, 마지막 한명이 남을 때까지 아래의 게임을 진행한다.
    <ol>
      <li>시작하는 사람을 포함해서 k번째 사람이 탈락한다.</li>
      <li>다음 시작 번호는 탈락한 사람의 다음 번호</li>
    </ol>
  </li>
  <li>vector<int> friends(n) 선언 후 각 원소를 1 ~ n 으로 초기화 해줬다.</int></li>
  <li>friends 의 원소가 1개 남을 때 까지 아래를 반복
    <ol>
      <li>currentPos 에 k - 1 만큼 더 한다. (자기 자신을 포함하므로 1 감소, currentPos 의 시작값은 0)</li>
      <li>currentPos 를 friends.size() 로 나머지값을 취해준다. (배열의 크기 밖으로 나가는 예외 처리)</li>
      <li>friends에서 currentPos번째의 원소를 빼준다.</li>
    </ol>
  </li>
  <li>friends.front()(마지막 남은 원소)를 반환</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>백준에서도 여러번 접해본 문제라 큰 어려움 없이 풀 수 있었다.</li>
  <li>배열의 삭제, 크기를 넘어가는 인덱스의 예외 처리가 중요한 것 같다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Array" /><summary type="html"><![CDATA[1823. Find the Winner of the Circular Game / c++ / Medium / 5분]]></summary></entry><entry><title type="html">[혼공 학습단 12기] 혼공컴운 1주차</title><link href="https://sho1007.github.io/hongong/HonGong12_OS_Week1/" rel="alternate" type="text/html" title="[혼공 학습단 12기] 혼공컴운 1주차" /><published>2024-07-08T00:00:00+00:00</published><updated>2024-07-08T00:00:00+00:00</updated><id>https://sho1007.github.io/hongong/HonGong12_OS_Week1</id><content type="html" xml:base="https://sho1007.github.io/hongong/HonGong12_OS_Week1/"><![CDATA[<p><img src="../../assets/images/HonGongCSOS.jpg" alt="image" /></p>

<h2 id="진도--chapter-01--03">진도 : Chapter 01 ~ 03</h2>

<h2 id="기본-숙제">기본 숙제</h2>
<ol>
  <li><strong>p. 51의 확인 문제 3번</strong> <br />
 프로그램이 실행되려면 반드시 <code class="language-plaintext highlighter-rouge">메모리</code>에 저장되어 있어야 합니다.</li>
  <li><strong>p. 65의 확인 문제 3번</strong> <br />
 1101(2)의 음수를 2의 보수 표현법으로 구해 보세요.
    <ol>
      <li>1101</li>
      <li>0010 (모든 0과 1 뒤집기)</li>
      <li>0011 (1 더하기)</li>
    </ol>

    <p>1101(2)을 음수로 표현한 값은 <code class="language-plaintext highlighter-rouge">0011(2)</code>입니다.</p>
  </li>
</ol>

<h2 id="추가-숙제">추가 숙제</h2>
<p><strong>p. 100의 스택과 큐의 개념을 정리하기</strong></p>
<h3 id="스택">스택</h3>
<blockquote>
  <p>한쪽 끝이 막혀 있는 통과 같은 저장 공간. 데이터를 빼낼 때는 <strong>저장한 반대 순서대로</strong> 빼낸다. 나중에 저장한 데이터를 가장 먼저 빼내는 후입선출이라는 점에서 LIFO (Last In First Out) 자료구조라고도 불린다.</p>
</blockquote>

<ul>
  <li>PUSH : 스택의 가장 위에 원소를 추가하는 연산</li>
  <li>POP : 스택의 가장 위에 있는 원소를 꺼내는 연산</li>
</ul>

<h3 id="큐">큐</h3>
<blockquote>
  <p>양쪽 끝이 뚫려 있는 저장 공간. 한쪽으로 데이터를 저장하고, 다른 한쪽에서 <strong>저장한 순서대로</strong> 데이터를 빼낸다. 가장 먼저 저장된 데이터부터 빼내는 선입선출이라는 점에서 FIFO (First In First Out) 자료구조라고도 불린다.</p>
</blockquote>

<ul>
  <li>PUSH : 큐의 가장 뒤에 원소를 추가하는 연산</li>
  <li>POP : 큐의 가장 앞에 있는 원소를 꺼내는 연산</li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;HonGong&quot;]" /><category term="Computer Structure" /><category term="Operating System" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">2058 Find the Minimum and Maximum Number of Nodes Between Critical Points</title><link href="https://sho1007.github.io/leetcode/2058/" rel="alternate" type="text/html" title="2058 Find the Minimum and Maximum Number of Nodes Between Critical Points" /><published>2024-07-05T00:00:00+00:00</published><updated>2024-07-05T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2058</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2058/"><![CDATA[<h1 id="2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points--c--medium--30분">2058. Find the Minimum and Maximum Number of Nodes Between Critical Points / c++ / Medium / 30분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<h3 id="문제-링크"><a href="https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/description/?envType=daily-question&amp;envId=2024-07-05">문제 링크</a></h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nodesBetweenCriticalPoints</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="mi">100'001</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span>
                <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
                    <span class="kt">int</span> <span class="n">resultSize</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">resultSize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="kt">int</span> <span class="n">currentDistance</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">resultSize</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="n">resultSize</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">currentDistance</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">minDistance</span> <span class="o">=</span> <span class="n">currentDistance</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">minDistance</span> <span class="o">==</span> <span class="mi">100'001</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">minDistance</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">-</span> <span class="n">result</span><span class="p">.</span><span class="n">front</span><span class="p">()};</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--링크드-리스트">자료 구조 / 링크드 리스트</h3>
<ol>
  <li>Critical Point 들의 거리 중 { 최소 거리, 최대 거리} 를 반환하는 문제였다.</li>
  <li>여기서 Critical Point 란, 링크드 리스트의 노드 중
    <ol>
      <li>이전 원소, 현재 원소, 다음 원소가 모두 존재 하고 (nullptr이 아니고)</li>
      <li>현재 원소의 값이 이전 원소와 다음 원소의 값보다 {크거나/작은} 노드이다. <br />
 (ex. 1 3 2 중 3은 critical point, 5 2 4 여기서 2는 critical point)</li>
    </ol>
  </li>
  <li>우선 모든 critical point들의 거리를 vector<int> result에 저장했다.
</int>    <ol>
      <li>싱글 링크드 리스트였으므로, ListNode* prev를 만들어서 이전 값을 저장해줬다. (초기값 nullptr)</li>
      <li>prev, current, next (current-&gt;next)가 모두 nullptr 가 아닌지 체크</li>
      <li>current-&gt;val이 prev-&gt;val, next-&gt;val 보다 {크거나, 작은지} 체크</li>
      <li>위의 조건에 만족한다면 현재 pos를 result에 삽입</li>
    </ol>
  </li>
  <li>내가 생각한 결과는 최대거리는 제일 처음 발견한 critical point와 가장 마지막에 발견한 critical point 의 거리였다.</li>
  <li>그리고 모든 critical point가 pos가 증가하는 순서대로 정렬되어 result에 들어오기 때문에, 최소 거리는 인접한 노드와의 거리 중 최소값이라고 생각했다.
    <ol>
      <li>그래서 3번 로직을 수행하면서, result의 크기가 2 이상일 때 (원소가 2개 이상은 있어야 둘 사이의 거리를 구할 수 있으므로)</li>
      <li>가장 마지막 값 (현재 critical point)와 그 바로 전 값 (이전 critical point)의 거리를 currentDistance로 구해줬다.</li>
      <li>그리고 currentDistance가 minDistance보다 작다면 갱신해줬다. (minDistance의 초기값은 100’001로 잡았다. 원소가 최대 100’000개 있을 수 있으므로 최대 100’001은 못넘기 때문에)</li>
    </ol>
  </li>
  <li>result를 {minDistance, result.back() - result.front()} 로 갱신하고 반환</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>처음에 계속 첫 번째 critical point의 위치가 2번씩 들어가서 최소 거리가 0으로 잡히는 오류가 생겼다.</li>
  <li>알고보니 while 문 안에서 critical point의 조건을 검사하고, 조건에 맞지 않으면 early return을 해줬었는데, 링크드 리스트를 다음 노드로 진행시키고 pos를 증가시키는 구문이 그 아래에 존재해서, 같은 노드를 한번 더 검사했던 것이었다.</li>
  <li>early return이 깊이를 증가시키지 않아서 좋은 점도 있지만, 흐름을 명확히 신경써야 한다는 단점도 존재한다는걸 다시금 깨달을 수 있었다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="LinkedList" /><summary type="html"><![CDATA[2058. Find the Minimum and Maximum Number of Nodes Between Critical Points / c++ / Medium / 30분]]></summary></entry><entry><title type="html">2181 Merge Nodes in Between Zeros</title><link href="https://sho1007.github.io/leetcode/2181/" rel="alternate" type="text/html" title="2181 Merge Nodes in Between Zeros" /><published>2024-07-04T00:00:00+00:00</published><updated>2024-07-04T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2181</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2181/"><![CDATA[<h1 id="2181-merge-nodes-in-between-zeros--c--medium--13분">2181. Merge Nodes in Between Zeros / c++ / Medium / 13분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<h3 id="문제-링크"><a href="https://leetcode.com/problems/merge-nodes-in-between-zeros/description/?envType=daily-question&amp;envId=2024-07-04">문제 링크</a></h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeNodes</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--링크드-리스트">자료 구조 / 링크드 리스트</h3>
<ol>
  <li>링크드 리스트에서 0이 아닌 값들을 합쳐서 반환하는 문제였다. <br />
(ex. 0 1 2 3 0 4 5 0 이라면, <code class="language-plaintext highlighter-rouge">6</code>(1+2+3) <code class="language-plaintext highlighter-rouge">9</code>(4+5) 를 반환)</li>
  <li>단순 값만 더하는 건 엄청 쉬웠지만, 링크드 리스트 구조를 유지하면서, 노드의 삭제가 필요해서 생각을 요구했다.</li>
  <li>내가 적용한 방식은, 0이 아닌 첫 번째 원소에다 이후의 값들을 더해주는 것이었다.
    <ol>
      <li>0 1 2 3 0 4 5 0</li>
      <li>0 3 3 0 4 5 0 (1 + 2)</li>
      <li>0 6 0 4 5 0 (3 + 3)</li>
      <li>0 6 0 9 0</li>
    </ol>
  </li>
  <li>다음으로 해야할 것은, 0인 값들은 링크드 리스트에서 제거해야 했다.</li>
  <li>제일 처음 0은 시작할 때 제거</li>
  <li>그 다음부터 나오는 0에 대해선
    <ol>
      <li>만약 0 다음에 노드가 또 있다면 (끝이 아님) : 0 전 후의 노드를 연결하고 0 노드를 삭제</li>
      <li>만약 0 다음에 노드가 없다면 (끝) : 현재 노드의 next를 nullptr로 하고 0 노드를 삭제</li>
    </ol>
  </li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>자료 구조를 공부할 때 가장 처음 나오는 자료 구조인 링크드 리스트를 되짚어 볼 수 있는 문제였다.</li>
  <li>지금 생각해보니 0인 노드를 삭제하지 말고 3번 로직을 0인 노드에서 실행했으면 더 효율적이었을 것 같다. (0 1 2 3 을 더하고 다음 0 4 5 를 더하고 마지막 0은 탈락)</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="LinkedList" /><summary type="html"><![CDATA[2181. Merge Nodes in Between Zeros / c++ / Medium / 13분]]></summary></entry><entry><title type="html">교착 상태란?</title><link href="https://sho1007.github.io/operatingsystem/DeadLock/" rel="alternate" type="text/html" title="교착 상태란?" /><published>2024-07-03T00:00:00+00:00</published><updated>2024-07-03T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/DeadLock</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/DeadLock/"><![CDATA[<h1 id="교착-상태란">교착 상태란?</h1>
<p>일어나지 않을 (점유된 자원을 점유하는) 사건 을 기다리면서 진행이 멈추어 버림</p>
<h2 id="식사하는-철학자-dining-philosopher-문제">식사하는 철학자 (Dining Philosopher) 문제</h2>
<ol>
  <li>계속 생각하다 왼쪽 포크가 사용 가능하면 집어든다.</li>
  <li>계속 생각하다 오른쪽 포크가 사용 가능하면 집어든다.</li>
  <li>양쪽 포크를 모드 집어들면 정해진 시간동안 식사를 한다.</li>
  <li>식사 시간이 끝나면 오른쪽 포크를 내려놓는다.</li>
  <li>오른쪽 포크를 내려놓은 뒤 왼쪽 포크를 내려놓는다.</li>
  <li>다시 1번부터 반복한다.
    <blockquote>
      <p>모든 철학자가 왼쪽 포크를 쥔 채, 오른쪽 포크를 기다리고 있는 상황에서 무한히 생각(대기)한다.</p>
    </blockquote>
  </li>
</ol>

<h1 id="교착-상태를-해결하기-위해서는">교착 상태를 해결하기 위해서는…</h1>
<ol>
  <li>첫째, 교착 상태가 발생했을 때의 상황을 정확히 표현</li>
  <li>둘째, 교착 상태가 일어나는 근본적인 이유 이해
    <h2 id="자원-할당-그래프">자원 할당 그래프</h2>
    <ul>
      <li>어떤 프로세스가 어떤 자원을 할당 받아 사용 중인지 확인 가능</li>
      <li>어떤 프로세스가 어떤 자원을 기다리고 있는지 확인 가능</li>
      <li>프로세스는 원, 자원은 사각형</li>
      <li>자원의 개수는 자원 사각형 내에 점으로 표현 (ex, A[ * * ])</li>
      <li>자원을 할당 받았다면, 자원에서 프로세스로 화살표</li>
      <li>자원을 기다리고 있다면, 프로세스에서 자원으로 화살표
        <blockquote>
          <p>교착 상태가 발생한 자원 할당 그래프는 <code class="language-plaintext highlighter-rouge">원</code>의 형태를 띄고 있다.</p>
          <h2 id="교착-상태가-발생할-조건">교착 상태가 발생할 조건</h2>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태</li>
  <li>점유와 대기 : 자원을 할당 받은 상태에서 다른 자원을 기다리는 상태</li>
  <li>비선점 : 어떤 프로세스도 다른 프로세스의 자원을 강제로 뺏지 못하는 상태</li>
  <li>원형 대기 : 프로세스들이 원의 형태로 자원을 대기하는 상태 (자원 할당 그래프가 원의 형태를 띄고 있다.)</li>
</ol>

<ul>
  <li>위 네 가지 조건 중 하나라도 만족하지 않으면 교착 상태가 발생하지 않음</li>
  <li>위 네 가지 조건을 모두 만족하면 교착 상태가 발생할 수 있음</li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[교착 상태란? 일어나지 않을 (점유된 자원을 점유하는) 사건 을 기다리면서 진행이 멈추어 버림 식사하는 철학자 (Dining Philosopher) 문제 계속 생각하다 왼쪽 포크가 사용 가능하면 집어든다. 계속 생각하다 오른쪽 포크가 사용 가능하면 집어든다. 양쪽 포크를 모드 집어들면 정해진 시간동안 식사를 한다. 식사 시간이 끝나면 오른쪽 포크를 내려놓는다. 오른쪽 포크를 내려놓은 뒤 왼쪽 포크를 내려놓는다. 다시 1번부터 반복한다. 모든 철학자가 왼쪽 포크를 쥔 채, 오른쪽 포크를 기다리고 있는 상황에서 무한히 생각(대기)한다.]]></summary></entry><entry><title type="html">교착 상태 해결 방법</title><link href="https://sho1007.github.io/operatingsystem/DeadLockSolution/" rel="alternate" type="text/html" title="교착 상태 해결 방법" /><published>2024-07-03T00:00:00+00:00</published><updated>2024-07-03T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/DeadLockSolution</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/DeadLockSolution/"><![CDATA[<h1 id="교착-상태-해결-방법">교착 상태 해결 방법</h1>
<ul>
  <li>예방</li>
  <li>회피</li>
  <li>검출 후 회복</li>
  <li>무시 (가끔)
    <h2 id="교착-상태-예방">교착 상태 예방</h2>
  </li>
  <li>애초에 교착 상태가 발생하지 않도록</li>
  <li>교착 상태 발생 조건 (상호 배제, 점유와 대기, 비선점, 원형 대기) 중 하나를 없애버리기
    <h3 id="상호-배제를-없애면">상호 배제를 없애면?</h3>
    <p>모든 자원을 공유 가능하게 만든다? 현실적으로 <code class="language-plaintext highlighter-rouge">불가능</code></p>
    <h3 id="점유와-대기를-없애면">점유와 대기를 없애면?</h3>
    <p>특정 프로세스에게 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분</p>
    <blockquote>
      <p>자원 활용률이 낮아질 수 있다.</p>
      <h3 id="비선점을-없애면">비선점을 없애면?</h3>
      <p>선점이 가능한 자원 (ex. CPU)에 한해 효과적
모든 자원이 선점 가능한 것은 아니다.</p>
      <h3 id="원형-대기를-없애면">원형 대기를 없애면?</h3>
      <p>자원에 우선 순위를 매기고, 우선 순위가 높은 순으로 자원을 점유
모든 자원에 우선 순위를 매기기는 어렵고, 우선 순위에 따라 자원의 활용률이 달라진다.</p>
    </blockquote>
  </li>
</ul>

<h2 id="교착-상태-회피">교착 상태 회피</h2>
<ul>
  <li>교착 상태를 <strong>무분별한 자원 할당으로 인해 발생</strong>했다고 간주</li>
  <li>교착 상태가 발생하지 않을 만큼 <strong>조심 조심 할당</strong>하기</li>
  <li>배분할 수 있는 자원의 양을 고려하여, 교착 상태가 발생하지 않을 만큼만 자원 배분
    <ol>
      <li><code class="language-plaintext highlighter-rouge">안전 순서열</code> : 교착 상태 없이 안전하게 모든 프로세스들에게 자원을 할당할 수 있는 순서</li>
      <li><code class="language-plaintext highlighter-rouge">안전 상태</code> : 교착 상태 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태</li>
      <li><code class="language-plaintext highlighter-rouge">불안전 상태</code> : 교착 상태가 발생할 수도 있는 상태
        <blockquote>
          <p>안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당하는 방식 <br />
항시 안전 상태를 유지하도록 자원을 할당하는 방식</p>
        </blockquote>
      </li>
    </ol>
  </li>
</ul>

<h2 id="교착-상태-검출-후-회복">교착 상태 검출 후 회복</h2>
<ul>
  <li>교착 상태의 발생을 인정하고 사후에 조치하는 방식</li>
  <li>프로세스가 자원을 요구하면 일단 할당, 교착 상태가 검출되면 회복</li>
  <li>선점을 통한 회복 : 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식</li>
  <li>프로세스 강제 종료를 통한 회복
    <ul>
      <li>교착 상태에 놓인 프로세스를 모두 강제 종료 (작업 내역을 잃을 위험)</li>
      <li>교착 상태가 해결될 때까지 한 프로세스씩 강제 종료 (오버헤드)</li>
    </ul>
  </li>
</ul>

<h2 id="교착-상태-무시">교착 상태 무시</h2>
<h3 id="타조-알고리즘">타조 알고리즘</h3>
<p>아주 희박하게 발생하는 교착 상태에 대해서는 무시하는 것이 엔지니어 입장에서 효율적일 때도 있다.</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[교착 상태 해결 방법 예방 회피 검출 후 회복 무시 (가끔) 교착 상태 예방 애초에 교착 상태가 발생하지 않도록 교착 상태 발생 조건 (상호 배제, 점유와 대기, 비선점, 원형 대기) 중 하나를 없애버리기 상호 배제를 없애면? 모든 자원을 공유 가능하게 만든다? 현실적으로 불가능 점유와 대기를 없애면? 특정 프로세스에게 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분 자원 활용률이 낮아질 수 있다. 비선점을 없애면? 선점이 가능한 자원 (ex. CPU)에 한해 효과적 모든 자원이 선점 가능한 것은 아니다. 원형 대기를 없애면? 자원에 우선 순위를 매기고, 우선 순위가 높은 순으로 자원을 점유 모든 자원에 우선 순위를 매기기는 어렵고, 우선 순위에 따라 자원의 활용률이 달라진다.]]></summary></entry><entry><title type="html">프로세스 동기화</title><link href="https://sho1007.github.io/operatingsystem/ProcessSynchronization/" rel="alternate" type="text/html" title="프로세스 동기화" /><published>2024-07-03T00:00:00+00:00</published><updated>2024-07-03T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/ProcessSynchronization</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/ProcessSynchronization/"><![CDATA[<p>동시다발적으로 실행되는 프로세스 (스레드) 는 자원의 일관성을 보장해야 한다. -&gt; <code class="language-plaintext highlighter-rouge">동기화</code>를 고려해야 한다.</p>

<h1 id="동기화의-의미">동기화의 의미</h1>
<p>프로세스의 수행 시기를 맞추는 것</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">실행 순서 제어</code> : 프로세스를 올바른 순서대로 실행하기</li>
  <li><code class="language-plaintext highlighter-rouge">상호 배제</code> : 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하기</li>
</ul>

<h2 id="reader-writer-problem">Reader-Writer Problem</h2>
<p>Writer : Book.txt 파일에 값을 <strong>저장하는</strong> 프로세스  <br />
Reader : Book.txt 팡리에 저장된 값을 <strong>읽어들이는</strong> 프로세스</p>

<p>이 두 프로세스는 아무렇게나 실행되어서는 안된다. <br />
<strong>실행의 순서</strong>가 있기 때문</p>

<p>Reader 프로세스는 ‘Book.txt 안에 값이 존재한다’는 <strong>특정 조건이 만족되어야만</strong> 실행 가능</p>

<h2 id="bank-account-problem">Bank Account Problem</h2>

<p><strong>공유가 불가능한 자원</strong>의 동시 사용을 피하기 위한 동기화</p>

<p>현재 계좌 잔액 10만원 <br />
프로세스 A : 현재 잔액에 2만원을 추가하는 프로세스 <br />
프로세스 B : 현재 잔액에 5만원을 추가하는 프로세스</p>

<p>프로세스 A, B를 동시에 실행하면 잔액은 얼마? 기대값 : 17만원 <br />
하지만 12만원, 15만원 등 예측할 수 없는 값이 나온다. <br />
왜? 코드는 한 줄이어도, 기계어는 여러 줄이다. (읽어들이고, 변경하고, 저장하고) 이 사이에 문맥 교환이 일어나면 예상하지 못한 값이 나올 수 있다.</p>
<blockquote>
  <p>따라서 한 번에 한 프로세스만 접근 가능한 자원 (공유 불가 자원)은, 그 프로세스의 접근이 끝난 뒤에 다른 프로세스가 접근해야 한다.</p>
</blockquote>

<h2 id="producer-consumer-problem">Producer-Consumer Problem</h2>

<p>Producer : 물건을 계속 생산 (총합 1 증가) <br />
Consumer : 물건을 계속 소비 (총합 1 감소) <br />
두 프로세스는 총합을 공유함 <br />
이 상태에서 생산자, 소비자를 각각 10만번 실행하면 ‘총합’은? <br />
기대값 : 0 <br />
하지만 이 역시도 Bank Account Problem과 마찬가지로 예측하지 못한 값이 나올 수 있다.</p>

<h1 id="공유-자원과-임계-구역">공유 자원과 임계 구역</h1>
<p><code class="language-plaintext highlighter-rouge">공유 자원</code> : 여러 프로세스 (스레드)가 공유하는 자원 <br />
<code class="language-plaintext highlighter-rouge">임계 구역</code> : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역</p>

<p>이런 임계 구역에 동시에 접근하면 자원의 일관성이 깨질 수 있는데, 이를 <code class="language-plaintext highlighter-rouge">경쟁 상태(Race Condition)</code>이라고 한다.</p>

<h2 id="운영체제가-임계구역-문제를-해결하는-세-가지-원칙">운영체제가 임계구역 문제를 해결하는 세 가지 원칙</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">상호 배제</code> (Mutual Exclusion) : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없다.</li>
  <li><code class="language-plaintext highlighter-rouge">진행</code> (Progress) : 임계 구역에 어떤 프로세스도 진입하지 않았다면, 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">유한 대기</code> (Bounded Wating) : 한 프로세스가 임계 구역에 진입하고 싶다면, 언젠가는 임계 구역에 들어올 수 있어야 한다. (임계 구역에 들어오기 위해 무한정 대기해서는 안된다.)</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[동시다발적으로 실행되는 프로세스 (스레드) 는 자원의 일관성을 보장해야 한다. -&gt; 동기화를 고려해야 한다.]]></summary></entry><entry><title type="html">동기화 기법</title><link href="https://sho1007.github.io/operatingsystem/SynchronizationTechnique/" rel="alternate" type="text/html" title="동기화 기법" /><published>2024-07-03T00:00:00+00:00</published><updated>2024-07-03T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/SynchronizationTechnique</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/SynchronizationTechnique/"><![CDATA[<h1 id="뮤텍스-락">뮤텍스 락</h1>
<ul>
  <li>상호 배제를 위한 동기화 도구 (자물쇠 역할)</li>
  <li>전역 변수 하나, 함수 두개
    <ul>
      <li><code class="language-plaintext highlighter-rouge">lock</code> : 자물쇠 역할의 전역 변수</li>
      <li><code class="language-plaintext highlighter-rouge">acquire</code> : 임계 구역을 잠그는 함수</li>
      <li><code class="language-plaintext highlighter-rouge">release</code> : 임계 구역의 잠금을 해제하는 함수</li>
    </ul>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">acquire</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lock</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
        <span class="p">;</span>                   <span class="cm">/* 임계 구역이 잠겨 있는지를 잠겨 있지 않을 때까지, 반복 확인 */</span>

    <span class="n">lock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>            <span class="cm">/* 임계 구역이 잠겨 있지 않다면, 임계 구역을 잠금*/</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">release</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>           <span class="cm">/* 임계 구역 작업이 끝난 후 잠금 해제*/</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">SomeThread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">acquire</span><span class="p">();</span>             <span class="cm">/* 자물쇠가 잠겨있는지 확인 후, 자물쇠가 풀릴 때까지 기다렸다가 자물쇠를 잠그고 들어옴 */</span>
    <span class="c1">// 임계 구역</span>
    <span class="n">release</span><span class="p">();</span>             <span class="cm">/* 자물쇠를 풂 */</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="바쁜-대기">바쁜 대기</h2>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">while</span> <span class="p">(</span><span class="n">lock</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>    <span class="cm">/* 만약 임계 구역이 잠겨 있다면 */</span>
    <span class="p">;</span>                       <span class="cm">/* 임계 구역이 잠겨 있는지를 반복적으로 확인 */</span>
</code></pre></div></div>
<p>문이 잠겨있는지를 계속 덜컹거리며 확인 (CPU 자원 계속 소모)</p>

<h1 id="세마포">세마포</h1>
<ul>
  <li>좀 더 일반화된 방식의 동기화 도구</li>
  <li>공유 자원이 여러 개 있는 경우에도 적용 가능</li>
  <li>여기에선 카운팅 세마포를 지칭 (이진 세마포는 뮤텍스 락과 유사)</li>
  <li>세마포의 단순한 형태 : 전역 변수 하나, 함수 두 개
    <ul>
      <li><code class="language-plaintext highlighter-rouge">S</code> : 임계 구역에 진입할 수 있는 프로세스 개수를 나타내는 전역 변수</li>
      <li><code class="language-plaintext highlighter-rouge">wait</code> : 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 함수</li>
      <li><code class="language-plaintext highlighter-rouge">signal</code> : 임계 구역 앞에서 기다리는 프로세스에게 ‘이제 가도 좋다’고 신호를 주는 함수
```c++
void SomeThread()
{
  wait();
  // 임계 구역
  signal();
}</li>
    </ul>
  </li>
</ul>

<p>void wait()
{
    while ( S &lt;= 0)
    ;
    S–;
}
void signal()
{
    S++;
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 바쁜 대기 해결 방법
* 사용할 수 있는 자원이 없을 경우 `대기 상태`로 만듦
(해당 프로세스의 PCB를 대기 큐에 삽입)
* 사용할 수 있는 자원이 생겼을 경우, 대기 큐의 프로세스를 `준비 상태`로 만듦
(해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐에 삽입)

## 실행 순서 제어 동기화
```c++
int S = 0;

void P1() // 먼저 실행 되어야 함
{
    // 임계 구역
    signal();
}

void P2() // 나중에 실행 되어야 함
{
    wait();
    // 임계 구역
}
</code></pre></div></div>

<h1 id="모니터">모니터</h1>
<p>뮤텍스 락, 세마포 같은 경우는 앞뒤로 함수를 붙여줘야 해서 실수가 발생할 수 있고, 실수로 누락하거나 순서를 헷갈리거나, 중복해서 같은 함수를 붙일 시 디버깅이 어렵다. <br />
<code class="language-plaintext highlighter-rouge">모니터</code> : 사용자가 사용하기 편한 동기화 도구</p>
<h2 id="상호-배제를-위한-동기화">상호 배제를 위한 동기화</h2>
<ul>
  <li>인터페이스를 위한 큐</li>
  <li>공유 자원에 접근하고자 하는 프로세스를 (공유 자원을 위한) 큐에 삽입</li>
  <li>큐에 삽입된 순서대로 (한 번에 하나의 프로세스만) 공유 자원 이용
    <h2 id="실행-순서-제어를-위한-동기화">실행 순서 제어를 위한 동기화</h2>
  </li>
  <li>조건 변수(Condition Variable)를 이용</li>
  <li>프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
    <ul>
      <li>조건 변수.wait() : 대기 상태로 변경, 조건 변수에 대한 큐에 삽입</li>
      <li>조건 변수.signal() : wait()로 대기 상태가 된 프로세스를 준비 상태로 변경</li>
    </ul>
  </li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[뮤텍스 락 상호 배제를 위한 동기화 도구 (자물쇠 역할) 전역 변수 하나, 함수 두개 lock : 자물쇠 역할의 전역 변수 acquire : 임계 구역을 잠그는 함수 release : 임계 구역의 잠금을 해제하는 함수]]></summary></entry><entry><title type="html">CPU 스케줄링</title><link href="https://sho1007.github.io/operatingsystem/CPUScheduling/" rel="alternate" type="text/html" title="CPU 스케줄링" /><published>2024-07-02T00:00:00+00:00</published><updated>2024-07-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/CPUScheduling</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/CPUScheduling/"><![CDATA[<h1 id="cpu-스케줄링이란">CPU 스케줄링이란?</h1>
<p>운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것</p>

<h1 id="프로세스-우선순위">프로세스 우선순위</h1>
<p>가장 공정한 CPU 스케줄링? <br />
프로세스마다 우선순위가 다르다. (빨리 처리해야하는 프로세스와 늦게 처리해도 되는 프로세스)</p>
<ul>
  <li>입출력 집중 프로세스 (입출력 작업이 많은 프로세스) : 우선순위 높음</li>
  <li>CPU 집중 프로세스 (CPU 작업이 많은 프로세스) : 우선순위 낮음</li>
</ul>

<p>입출력 집중 프로세스는 어차피 CPU를 잠깐 쓰고 <code class="language-plaintext highlighter-rouge">대기 상태</code>로 넘어감 <br />
프로세스 우선순위는 PCB에 저장된다.</p>

<h1 id="스케줄링-큐">스케줄링 큐</h1>
<p>특정 자원을 이용하고 싶어하는 프로세스들이 서는 줄 (대기열?)</p>
<blockquote>
  <p>스케줄링에서의 큐는 반드시 FIFO일 필요는 없다. 프로세스별로 우선순위가 다르므로</p>
</blockquote>

<h2 id="준비-큐와-대기-큐">준비 큐와 대기 큐</h2>
<ul>
  <li>준비 큐 : CPU를 이용하고 싶어하는 프로세스들이 서는 줄</li>
  <li>대기 큐 : 입출력 장치를 이용하고 싶어하는 프로세스들이 서는 줄 (입출력 장치 별로 존재)
    <h2 id="선점형과-비선점형-스케줄링">선점형과 비선점형 스케줄링</h2>
    <p>이미 CPU를 할당받아서 실행 중인 프로세스가 있는데, 우선순위가 더 높은 프로세스가 있다면?</p>
  </li>
  <li>선점형 스케줄링 : 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
    <ul>
      <li>장점 : 어느 한 프로세스의 자원 독점을 막고, 골고루 자원을 배분할 수 있다.</li>
      <li>단점 : 문맥 교환 과정에서 오버헤드가 발생할 수 있다. (자주 발생)</li>
    </ul>
  </li>
  <li>비선점형 스케줄링 : 현재 CPU를 사용 중인 프로세스의 작업이 끝나기를 기다렸다가 CPU 자원을 할당
    <ul>
      <li>장점 : 문맥 교환에서 발생하는 오버헤드가 적다.</li>
      <li>단점 : 모든 프로세스가 골고루 자원을 이용하기 어렵다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[CPU 스케줄링이란? 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것]]></summary></entry><entry><title type="html">CPU 스케줄링 알고리즘</title><link href="https://sho1007.github.io/operatingsystem/CPUSchedulingAlgorithm/" rel="alternate" type="text/html" title="CPU 스케줄링 알고리즘" /><published>2024-07-02T00:00:00+00:00</published><updated>2024-07-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/CPUSchedulingAlgorithm</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/CPUSchedulingAlgorithm/"><![CDATA[<h1 id="선입-선처리-스케줄링">선입 선처리 스케줄링</h1>
<p>FCFS(First Come First Served) 스케줄링</p>
<ul>
  <li>단순히 <code class="language-plaintext highlighter-rouge">준비 큐에 삽입된 순서대로 처리</code>하는 <strong>비선점 스케줄링</strong></li>
  <li>먼저 CPU를 요청한 프로세스부터 CPU 할당</li>
  <li>단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 (=호위 효과)
    <h1 id="최단-작업-우선-스케줄링">최단 작업 우선 스케줄링</h1>
    <p>SJF(Shortes Job First)  스케줄링</p>
  </li>
  <li>호위 효과를 방지하려면?</li>
  <li>CPU 사용이 긴 프로세스를 나중에 실행, CPU 사용 시간이 짧은 프로세스를 먼저 실행</li>
  <li><code class="language-plaintext highlighter-rouge">CPU 사용 시간이 가장 짧은 프로세스부터 처리</code>하는 스케줄링 방식
    <h1 id="라운드-로빈-스케줄링">라운드 로빈 스케줄링</h1>
  </li>
  <li>RR (Round-Robin) 스케줄링</li>
  <li>선입 선처리 스케줄링 + 타임 슬라이스 (time slice)</li>
  <li>타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간</li>
  <li><code class="language-plaintext highlighter-rouge">정해진 타임 슬라이스만큼의 시간 동안 돌아가며</code> CPU를 이용하는 <strong>선점형 스케줄링</strong>
    <ul>
      <li>큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되, 정해진 시간만큼만 이용</li>
      <li>정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면, 다시 큐의 맨 뒤에 삽입 (문맥 교환)
        <blockquote>
          <p>타임 슬라이스의 크기가 중요 (너무 크면 FCFS처럼 호위 효과 발생 / 너무 작으면 문맥 교환 오버헤드가 발생하여 CPU 부담이 커짐)</p>
          <h1 id="최소-잔여-시간-우선-스케줄링">최소 잔여 시간 우선 스케줄링</h1>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>SRT(Shortest Remaining Time) 스케줄링</li>
  <li>최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링</li>
  <li><code class="language-plaintext highlighter-rouge">정해진 시간 만큼 CPU를 이용</code>하되, 다음으로 CPU를 사용할 프로세스로는 <code class="language-plaintext highlighter-rouge">남은 작업 시간이 가장 적은 프로세스 선택</code>
    <h1 id="우선순위-스케줄링">우선순위 스케줄링</h1>
  </li>
  <li>프로세들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행</li>
  <li>우선순위가 같은 프로세스들은 선입 선처리로 스케줄링</li>
  <li>최단 작업 우선 / 최소 잔여 시간 스케줄링은 둘 다 우선순위 스케줄링의 한 종류</li>
  <li>기아 현상 (Starvation) : 우선순위가 낮은 프로세스는 (준비 큐에 먼저 삽입되어도) 실행이 계속 연기될 수 있다.
    <ul>
      <li>에이징 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식</li>
      <li>대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법</li>
      <li>처음엔 우선순위가 낮아도 언젠간 우선순위가 높아진다.
        <h1 id="다단계-큐-스케줄링">다단계 큐 스케줄링</h1>
        <p>MultilevelQueue 스케줄링</p>
      </li>
    </ul>
  </li>
  <li>우선순위 스케줄링의 발전된 형태</li>
  <li>우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식
    <ul>
      <li>우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리</li>
      <li>우선순위가 가장 높은 큐가 비어 있으면, 그 다음 우선순위 큐에 있는 프로세스를 처리</li>
    </ul>
  </li>
  <li>장점 : 프로세를 유형 (큐) 별로 처리 가능</li>
  <li>단점 : 큐 간에 이동이 불가능하여, 기아 현상 발생 가능
    <h1 id="다단계-피드백-큐-스케줄링">다단계 피드백 큐 스케줄링</h1>
    <p>Multilevel feedback queue 스케줄링</p>
  </li>
  <li>다단계 큐 스케줄링의 발전된 형태</li>
  <li>큐 간 이동이 가능한 다단계 큐 스케줄링
    <blockquote>
      <ul>
        <li>일단 가장 우선 순위가 높은 큐에 넣고 실행</li>
        <li>안끝났으면 다음 우선 순위가 높은 큐에 넣고 실행</li>
        <li>… 점점 우선순위가 낮아짐</li>
      </ul>
    </blockquote>
  </li>
  <li>CPU를 집중 프로세스의 우선 순위가 상대적으로 낮아지고, 입출력 집중 프로세스의 우선 순위는 상대적으로 높아진다.</li>
  <li>에이징 기법 적용 가능 (큐에서 대기가 길어지면, 우선 순위가 높은 큐로 이동)</li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[선입 선처리 스케줄링 FCFS(First Come First Served) 스케줄링 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링 먼저 CPU를 요청한 프로세스부터 CPU 할당 단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 (=호위 효과) 최단 작업 우선 스케줄링 SJF(Shortes Job First) 스케줄링 호위 효과를 방지하려면? CPU 사용이 긴 프로세스를 나중에 실행, CPU 사용 시간이 짧은 프로세스를 먼저 실행 CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식 라운드 로빈 스케줄링 RR (Round-Robin) 스케줄링 선입 선처리 스케줄링 + 타임 슬라이스 (time slice) 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되, 정해진 시간만큼만 이용 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면, 다시 큐의 맨 뒤에 삽입 (문맥 교환) 타임 슬라이스의 크기가 중요 (너무 크면 FCFS처럼 호위 효과 발생 / 너무 작으면 문맥 교환 오버헤드가 발생하여 CPU 부담이 커짐) 최소 잔여 시간 우선 스케줄링 SRT(Shortest Remaining Time) 스케줄링 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링 정해진 시간 만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스 선택 우선순위 스케줄링 프로세들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링 최단 작업 우선 / 최소 잔여 시간 스케줄링은 둘 다 우선순위 스케줄링의 한 종류 기아 현상 (Starvation) : 우선순위가 낮은 프로세스는 (준비 큐에 먼저 삽입되어도) 실행이 계속 연기될 수 있다. 에이징 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법 처음엔 우선순위가 낮아도 언젠간 우선순위가 높아진다. 다단계 큐 스케줄링 MultilevelQueue 스케줄링 우선순위 스케줄링의 발전된 형태 우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리 우선순위가 가장 높은 큐가 비어 있으면, 그 다음 우선순위 큐에 있는 프로세스를 처리 장점 : 프로세를 유형 (큐) 별로 처리 가능 단점 : 큐 간에 이동이 불가능하여, 기아 현상 발생 가능 다단계 피드백 큐 스케줄링 Multilevel feedback queue 스케줄링 다단계 큐 스케줄링의 발전된 형태 큐 간 이동이 가능한 다단계 큐 스케줄링 일단 가장 우선 순위가 높은 큐에 넣고 실행 안끝났으면 다음 우선 순위가 높은 큐에 넣고 실행 … 점점 우선순위가 낮아짐 CPU를 집중 프로세스의 우선 순위가 상대적으로 낮아지고, 입출력 집중 프로세스의 우선 순위는 상대적으로 높아진다. 에이징 기법 적용 가능 (큐에서 대기가 길어지면, 우선 순위가 높은 큐로 이동)]]></summary></entry></feed>