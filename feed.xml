<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-06-19T08:07:41+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 31일차 TIL - 402 Remove K Digits</title><link href="https://sho1007.github.io/leetcode/402/" rel="alternate" type="text/html" title="99클럽 코테 스터디 31일차 TIL - 402 Remove K Digits" /><published>2024-06-19T00:00:00+00:00</published><updated>2024-06-19T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/402</id><content type="html" xml:base="https://sho1007.github.io/leetcode/402/"><![CDATA[<h1 id="402-remove-k-digits--c--medium--46분">402. Remove K Digits / c++ / Medium / 46분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">removeKdigits</span><span class="p">(</span><span class="n">string</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="s">"0"</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">removeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;)</span>
        <span class="p">{</span>
            <span class="c1">// cout &lt;&lt; removeCount &lt;&lt; " : " &lt;&lt; num &lt;&lt; '\n';</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">num</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">removeCount</span><span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">removeCount</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">num</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">num</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">removeCount</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">num</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">removeCount</span><span class="p">));</span>

        <span class="k">return</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">num</span> <span class="o">:</span> <span class="s">"0"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="문자열">문자열</h3>
<ol>
  <li>처음엔 완전탐색과 백트래킹으로 k개 만큼 제거한 뒤에 배열에 넣어서 정렬 후 최소값을 찾아볼까 했다.</li>
  <li>하지만 k와 num의 길이의 최대값은 10^5였고 1번 방식으로 풀다간 시간 / 공간 복잡도가 엄청 늘어남은 물론이고 해당 숫자를 담을 자료형 조차 없었다.</li>
  <li>그래서 단순 숫자대 숫자로 비교가 안된다는 것을 깨닫고, 그럼 문제를 풀기 위해선 규칙이 있을 것이라고 판단했다.</li>
  <li>첫 번째로 찾은 규칙은 이러했다. 만약 현재 자리의 수가 다음 자리의 수보다 크다면 제거하는 것이다. <br />
 (ex. 1243 에서 하나를 제거한다고 했을 때, 123이 제일 작은 수이다. 즉 4가 3보다 
 크므로 4를 제거하는 것이 정답이다.)</li>
  <li>4번 규칙대로 풀었더니 1234567890 에서 결과가 123456780 이 나왔다. i + 1에 접근해야 해서 for 문의 규칙을 i &lt; num.length() - 1로 걸었더니, 9가 제거되면서 num의 길이가 하나 줄어서 i &lt; num.length() - 1 에 걸려서 종료된 것이었다.</li>
  <li>5번을 해결하기 위해 한 자리를 제거할 때, i 도 1 감소시켜줬다. 그러면 1234567890에서 9를 제거하면 num[i]는 0이 아닌 8을 가리키게 되므로, 연쇄적으로 num[i] &gt; num[i+1] 조건문을 통해 연쇄적으로 줄여나갈 수 있게 된다.</li>
  <li>다음 문제는 6번까지의 for문 순회를 돌고 난 다음 removeCount(제거한 횟수)가 k보다 작아서 생기는 문제였다. 예를 들어 11111 처럼 다 같은 문자여서 조건식에 걸리지 않았던가, 10001 처럼 중간에 0이 들어가서 자동적으로 탈락된 경우 (이 경우엔 자동 탈락이므로 removeCount는 증가하지 않는다.), k = 5 일 때 둘 다 정답은 0이 나와야 했다.</li>
  <li>7번 문제점을 해결하면서 한가지 추가적인 규칙을 찾아냈다. for문 순회가 끝난 수를 보면 마치 12345 처럼 정렬된 모양새를 띈다는 점이었다.</li>
  <li>그래서 이 경우엔 앞에서 제거하는게 아닌, 뒷부분을 제거하는 것이 결과값을 줄이는 방법이었다.</li>
  <li>따라서 만약 k - removeCount (남은 제거 횟수)가 만약 현재 num의 길이보다 크거나 같다면, 다 지워야하는 경우이므로 num을 “” 로 만들어줬고 (이 경우 반환 과정에서 “0”으로 치환된다.), 그게 아니라면 num을 num.length() - (k - removeCount)로 만들어줬다. (num을 뒤에서부터 남은 제거 횟수만큼 제거한 부분 문자열)</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>medium 난이도 치고는 생각보다 풀이시간이 오래 걸렸다. (역시나 난 문자열에 약한 것 같다.)</li>
  <li>leetcode는 틀린 케이스를 자꾸 알려줘서 거기에 맞춰서 풀게되는 느낌이다. (내가 찾아낸 것들도 있지만 생각하지 않은 엣지 케이스를 알려줘서 뇌 빼고 보는 느낌)</li>
  <li>그래도 99클럽을 시작한 뒤로 꾸준히 하루 한 문제씩 풀면서 문제 해결 능력도 많이 올라온 것 같다.</li>
  <li>단적인 예로 이런 막히는 문제들도 이제는 다른 사람들의 풀이를 보지 않고 혼자 해결할 수 있게 되었다. (특히 내 약점인 문자열 문제였음에도)</li>
  <li>또한 오늘 내 글이 우수 TIL로 선정되었다는 공지가 올라왔고 성취감이 배로 늘었다.</li>
  <li>다시 한번 이런 커리큘럼을 만들어준 팀스파르타에 감사함을 느낀다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="String" /><summary type="html"><![CDATA[402. Remove K Digits / c++ / Medium / 46분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 30일차 TIL - 5 Longest Palindromic Substring</title><link href="https://sho1007.github.io/leetcode/5/" rel="alternate" type="text/html" title="99클럽 코테 스터디 30일차 TIL - 5 Longest Palindromic Substring" /><published>2024-06-18T00:00:00+00:00</published><updated>2024-06-18T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/5</id><content type="html" xml:base="https://sho1007.github.io/leetcode/5/"><![CDATA[<h1 id="5-longest-palindromic-substring--c--medium--13분">5. Longest Palindromic Substring / c++ / Medium / 13분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">answer</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">answer</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="kt">bool</span> <span class="n">isPalindrome</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="p">])</span>
                        <span class="p">{</span>
                            <span class="n">isPalindrome</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">isPalindrome</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">answer</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="문자열--백트래킹">문자열 / 백트래킹</h3>
<ol>
  <li>문자열 s의 부분문자열 중, 길이가 가장 긴 팰린드롬 문자열(거꾸로 뒤집어도 똑같은 문자) 를 반환하는 문제였다.</li>
  <li>가장 단순하게 완전 탐색을 시도해보았다.</li>
  <li>s의 시작부터 i 기준으로 순회한다.
    <ol>
      <li>s의 끝부터 j 기준으로 순회한다.</li>
      <li>만약 s[i] == s[j]이면, 첫 글자가 같으므로 팰린드롬일 가능성이 있다.
        <ol>
          <li>여기서 다시 k 를 기준으로 i + k &lt;= j - k 일 때까지 순회한다.</li>
          <li>s[i + k] != s[j - k]이면 팰린드롬이 아니므로 isPalindrome을 false로 바꾸고 break</li>
          <li>순회가 끝났는데 isPalindrome 이 true라면 answer를 갱신해준다.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>권장이 3시간이어서 걱정했는데 13분 만에 풀려서 허무했다.</li>
  <li>역시 가장 쉽고 간편한건 완전 탐색!</li>
  <li>풀다보니 계속 최적화 할 수 있는 부분 (탐색하려는 길이가 이미 answer의 길이보다 작거나 같으면 무의미) 이 계속 보여서 추가적으로 넣어줬지만, 결과상 큰 변화는 없었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="String" /><summary type="html"><![CDATA[5. Longest Palindromic Substring / c++ / Medium / 13분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 29일차 TIL - 556 Next Greater Element III</title><link href="https://sho1007.github.io/leetcode/556/" rel="alternate" type="text/html" title="99클럽 코테 스터디 29일차 TIL - 556 Next Greater Element III" /><published>2024-06-17T00:00:00+00:00</published><updated>2024-06-17T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/556</id><content type="html" xml:base="https://sho1007.github.io/leetcode/556/"><![CDATA[<h1 id="556-next-greater-element-iii--c--medium--18분">556. Next Greater Element III / c++ / Medium / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">answer</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numberVector</span><span class="p">;</span>
<span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">resultSet</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">intLimit</span> <span class="o">=</span> <span class="mi">2'147'483'647</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">BackTracking</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numberVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="n">intLimit</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">resultSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numberVector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">numberVector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">numberVector</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">numberVector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">BackTracking</span><span class="p">();</span>
        <span class="n">numberVector</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">numberVector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">nextGreaterElement</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">numberVector</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">resultSet</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="n">string</span> <span class="n">nString</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">numberVector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nString</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">BackTracking</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">resultSet</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">resultVector</span><span class="p">(</span><span class="n">resultSet</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">resultSet</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">resultVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">resultVector</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="k">return</span> <span class="n">resultVector</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="문자열--백트래킹">문자열 / 백트래킹</h3>
<ol>
  <li>n과 같은 숫자로 만들어진 수 중, n보다 크고, 그 중에서 가장 작은 수를 반환하는 문제</li>
  <li>1번 조건이 약간 이상하게 쓰여져있지만, 해석해보면 n과 같은 숫자의 조합으로 만들어진 수 중에서, n 바로 다음으로 큰 수를 구하는 문제였다.</li>
  <li>숫자를 각 자리마다 접근하기 위해서 to_string으로 문자열로 바꿔서 접근해줬다.</li>
  <li>모든 자리를 numberVector에 담아준다.</li>
  <li>그 후 백트래킹을 하면서 numberVector에 있는 수로 만들 수 있는 모든 수를 구해준다.</li>
  <li>숫자가 다 만들어지면, 해당 숫자가 n보다 크고, intLimit(32bit int의 최대 범위) 보다 작거나 같은지 체크한 뒤 resultSet에 담아준다. (중복을 피하기 위해서 unordered_set을 이용)</li>
  <li>위의 과정이 끝나면, resultSet을 다시 resultVector에 담는다. (만약 resultSet이 비었다면, 이 시점에서 -1을 반환)</li>
  <li>resultVector를 정렬 후 0번째 숫자 (즉, intLimit보다 작거나 같고, n보다 큰 수 중 가장 작은 수)를 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>백트래킹과 set 그리고 정렬을 이용해서 풆 수 있는 문제였다.</li>
  <li>32-bit int 라고 해서 unsigned int 는 아니겠지 하고 int의 최대 범위를 사용했는데 맞았다.</li>
  <li>조합할 수 있는 수는, 앞에 9가 오게 되고 10자리 인 경우 int의 최대 범위르 넘어갈 수 있으므로, 통 크게 unsigned long long 으로 잡아줬다. (n이 양의 정수이므로 음수는 가정하지 않았다)</li>
  <li>leetcode의 경우 전역변수를 공유해서 테스트케이스들을 처리하다보니, 전역변수를 선언하고 함수 안에서 초기화해주는 방식으로 사용했다. (이번엔 백트래킹에 사용되는 전역변수가 좀 많았다.)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="String" /><summary type="html"><![CDATA[556. Next Greater Element III / c++ / Medium / 18분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 28일차 TIL - 2145 Count the Hidden Sequences</title><link href="https://sho1007.github.io/leetcode/2145/" rel="alternate" type="text/html" title="99클럽 코테 스터디 28일차 TIL - 2145 Count the Hidden Sequences" /><published>2024-06-16T00:00:00+00:00</published><updated>2024-06-16T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2145</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2145/"><![CDATA[<h1 id="2145-count-the-hidden-sequences--c--medium--47분">2145. Count the Hidden Sequences / c++ / Medium / 47분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">numberOfArrays</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">differences</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">differences</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">minNum</span> <span class="o">=</span> <span class="n">differences</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="n">differences</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">differences</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="n">differences</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">&gt;</span> <span class="n">maxNum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">maxNum</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">&lt;</span> <span class="n">minNum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">minNum</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">newLower</span> <span class="o">=</span> <span class="n">lower</span> <span class="o">-</span> <span class="n">minNum</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newLower</span> <span class="o">&lt;</span> <span class="n">lower</span><span class="p">)</span> <span class="n">newLower</span> <span class="o">=</span> <span class="n">lower</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">newUpper</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">maxNum</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newUpper</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">)</span> <span class="n">newUpper</span> <span class="o">=</span> <span class="n">upper</span><span class="p">;</span>

        <span class="c1">// cout &lt;&lt; newLower &lt;&lt; ' ' &lt;&lt; newUpper &lt;&lt; '\n';</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">newUpper</span> <span class="o">&lt;</span> <span class="n">newLower</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">newUpper</span> <span class="o">-</span> <span class="n">newLower</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="배열">배열</h3>
<ol>
  <li>어떤 배열의 인접한 두 원소의 차이를 기록한 differences 배열과, 원소의 최소값 기준 lower, 최대값 기준 upper 가 주어졌을 때, 이 조건을 만족하는 배열의 개수를 반환하는 문제였다.</li>
  <li>우선 0-indexed였으므로, differences의 원소의 갯수가 0개인 경우를 상정했다.</li>
  <li>이 경우, (upper - lower + 1) 이 가능한 배열의 개수였다.</li>
  <li>다음으로 differences 배열에 원소가 있는 경우에도 3번 식을 적용할 수 있었는데, 내 생각은 모든 경우를 다 따질게 아니라, 0을 기준으로 differences를 순회하며 차이값들을 다 적용해보고, 그 중 최소값과 최대값을 찾아서 활용하는 것이었다.</li>
  <li>예를 들어, 기존 upper 가 4 인데, 0을 기준으로 찾은 배열의 최대값이 10인 경우, 배열은 최소 -6으로 시작해야한다. (그래야 최대값 10이 나오는 시점에 시작값이 0이 아닌 -6이므로, 10-6 = 4가 되어, 기존의 upper를 충족한다.)</li>
  <li>즉 조건을 만족하기 위한 시작값의 새로운 최대값 기준 newUpper, newLower을 위의 식처럼 계산하여 구한다.</li>
  <li>그리고 newUpper가 newLower보다 작으면 (같을 땐 최소 만족하는 원소가 1개라도 있음) 0을 반환, 크거나 같으면 newUpper - newLower + 1을 반환한다. (3번식과 유사)</li>
  <li>하지만 여기서 문제가 생겼다. 이건 leetcode의 좋은 점이자 안좋은 점인데, 틀리면 틀린 케이스를 보여준다는 것이다. 내가 발견한 문제점은 newUpper가 기존의 upper보다 큰 경우였다. (이러면 7번식으로 계산한 값이 upper을 초과하여 조건이 성립하지 않는다.)</li>
  <li>그래서 생각해낸게, newUpper가 upper를 초과하면, newUpper 값 대신 upper 값을 쓰는 것이었다. (newLower도 마찬가지)</li>
  <li>그렇게 수정했더니 통과했다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>배열의 규칙 (최대값 - 최소값 + 1)을 찾아서 해결한 문제라 뿌듯했다.</li>
  <li>0-indexed 문제는 해결했는데, newUpper가 upper보다 커질거라고는 생각하지 못했다. 만약 실제 코딩 테스트였다면 왜 틀렸는지 몰랐을 것이다. (이런 부분을 잘 찾아내는게 중요하다는걸 다시 한번 느낀다.)</li>
  <li>중간에 minNum,maxNum 을 구할 때, int의 범위를 넘어가서 long long 으로 바꿔서 해결했다. (배열의 차이값을 저장한 differences의 원소가 int라고 해서, 실제 배열의 원소도 int일거라고 생각한게 실수였다.)</li>
  <li>여러모로 자료형과 제한 범위에 대해 생각해 볼 수 있는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Array" /><summary type="html"><![CDATA[2145. Count the Hidden Sequences / c++ / Medium / 47분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 27일차 TIL - 2861 Maximum Number of Alloys</title><link href="https://sho1007.github.io/leetcode/2861/" rel="alternate" type="text/html" title="99클럽 코테 스터디 27일차 TIL - 2861 Maximum Number of Alloys" /><published>2024-06-15T00:00:00+00:00</published><updated>2024-06-15T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2861</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2861/"><![CDATA[<h1 id="2861-maximum-number-of-alloys--c--medium--1시간">2861. Maximum Number of Alloys / c++ / Medium / 1시간</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">CheckMakeAlloys</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">composition</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">stock</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">cost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">currentBudget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">needCount</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">composition</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">stock</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">needCount</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                <span class="n">currentBudget</span> <span class="o">+=</span> <span class="p">(</span><span class="n">needCount</span> <span class="o">-</span> <span class="n">stock</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">cost</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">currentBudget</span> <span class="o">&lt;=</span> <span class="n">budget</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">maxNumberOfAlloys</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">composition</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">stock</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">987'654'321</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">answer</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">CheckMakeAlloys</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">budget</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">stock</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">mid</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">answer</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="배열--이분탐색">배열 / 이분탐색</h3>
<ol>
  <li>갯수를 기준으로 이분탐색을 해서, k개의 기계 중 mid 개 만큼의 합금을 budget 이하의 금액으로 만들 수 있는 최대 mid 를 반환하는 문제였다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이분탐색 치고는 조건이 많이 들어가는 편이었고, 명확한 제한값도 찾지 못해서 꽤나 번거로웠다.</li>
  <li>count개의 합금을 만들 때, stock[j]개만큼을 빼고 계산해야한는데 그 식을 composition[i][j] * (count - stock[j]) * cost[j] 로 계산해서 틀렸었다. (count개를 만들 때, 합금 한개 당 composition[i][j]만큼의 광석이 들어가므로, 제대로 된 식은 (composition[i][j] * count - stock[j]) * cost[j] 이다.)</li>
  <li>별 생각없이 left값을 1로 설정해서 또 한번 틀렸었다. (최대 한개도 만들 수 없으므로, 0으로 설정해야했다.)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Array" /><category term="BinarySearch" /><summary type="html"><![CDATA[2861. Maximum Number of Alloys / c++ / Medium / 1시간]]></summary></entry><entry><title type="html">99클럽 코테 스터디 26일차 TIL - 275 H-Index II</title><link href="https://sho1007.github.io/leetcode/275/" rel="alternate" type="text/html" title="99클럽 코테 스터디 26일차 TIL - 275 H-Index II" /><published>2024-06-14T00:00:00+00:00</published><updated>2024-06-14T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/275</id><content type="html" xml:base="https://sho1007.github.io/leetcode/275/"><![CDATA[<h1 id="275-h-index-ii--c--medium--4분">275. H-Index II / c++ / Medium / 4분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">hIndex</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">citations</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">citations</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">citations</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">citations</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">citations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">citations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">citations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="배열--정렬">배열 / 정렬</h3>
<ol>
  <li>H-Index는 h번 이상 인용된 논문이 h개 이상일 때의 최대값이다.</li>
  <li>우선 배열을 정렬한뒤, 순회한다.</li>
  <li>순회하면서 현재 남은 논문 갯수 (citations.size()-i)보다 현재 논문의 인용 횟수(citations[i])가 크거나 같다면, H-Index는 는 남은 논문의 갯수이므로 그것을 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>H-Index는 백준에서 이미 풀어본 경험이 있는 문제여서 쉽게 풀 수 있었다.</li>
  <li>백준에서 처음 이 문제를 접했을 때는 최대값 범위를 어떻게 잡아야하고 어떻게 접근할지 감이 잘 안왔었는데, 그 때 제대로 이해하고 넘어가니 다음에 다시 이 문제가 나왔을 때, 쉽게 다시 풀 수 있었던 것 같다.</li>
  <li>h-index는 결국 논문의 개수로 제한되니 최대값은 최대 논문의 개수이다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Array" /><summary type="html"><![CDATA[275. H-Index II / c++ / Medium / 4분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 25일차 TIL - 1971 Find if Path Exists in Graph</title><link href="https://sho1007.github.io/leetcode/1971/" rel="alternate" type="text/html" title="99클럽 코테 스터디 25일차 TIL - 1971 Find if Path Exists in Graph" /><published>2024-06-13T00:00:00+00:00</published><updated>2024-06-13T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/1971</id><content type="html" xml:base="https://sho1007.github.io/leetcode/1971/"><![CDATA[<h1 id="1971-find-if-path-exists-in-graph--c--easy--26분">1971. Find if Path Exists in Graph / c++ / Easy / 26분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">Find</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">num</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">parentA</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">parentB</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">parentA</span> <span class="o">==</span><span class="n">parentB</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">parent</span><span class="p">[</span><span class="n">parentB</span><span class="p">]</span> <span class="o">=</span> <span class="n">parentA</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">validPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Union</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">Find</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">==</span> <span class="n">Find</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="유니온파인드">유니온파인드</h3>
<ol>
  <li>양방향 그래프에서 두 정점 사이의 경로가 존재하는지를 반환하는 문제였다.</li>
  <li>유니온파인드(디스조인트셋/서로소 집합)을 사용하면 두 정점의 부모가 같을 경우 두 정점의 경로가 존재함을 알 수 있다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>99클럽의 챌린저 문제 치고는 너무 쉬웠다. (리트 코드 난이도 조차도 easy)</li>
  <li>아마 source 정점에서 BFS나 DFS등을 써서 destination 정점까지 도착할 수 있는지를 파악할 수도 있을 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="UnionFind" /><summary type="html"><![CDATA[1971. Find if Path Exists in Graph / c++ / Easy / 26분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 24일차 TIL - 49190 방의 개수</title><link href="https://sho1007.github.io/programmers/49190/" rel="alternate" type="text/html" title="99클럽 코테 스터디 24일차 TIL - 49190 방의 개수" /><published>2024-06-12T00:00:00+00:00</published><updated>2024-06-12T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/49190</id><content type="html" xml:base="https://sho1007.github.io/programmers/49190/"><![CDATA[<h1 id="49190-방의-개수--c--level5--2시간">49190. 방의 개수 / c++ / level5 / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/5/49190.%E2%80%85%EB%B0%A9%EC%9D%98%E2%80%85%EA%B0%9C%EC%88%98"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프">그래프</h3>
<ol>
  <li>방을 만드는 조건을 찾아야했다.
    <ol>
      <li>이미 방문한 좌표를 다시 방문할 때 방이 생성됐다.</li>
      <li>방문한적 없는 간선(arrow)로 방문해야 방이 생성됐다.</li>
    </ol>
  </li>
  <li>unordered_set으로 좌표와 간선의 방문여부를 체크했고, 테스트 케이스를 통과했지만, 문제는 틀렸다.</li>
  <li>아무리 생각해도 이유를 알 수 없어서, 다른 분들의 접근 방법을 찾아봤다.</li>
  <li>점 4개를 모래시계 형태로 교차해서 지나가게 되면, 이론상 방이 1개 생성되어야 하지만, 실제로는 방이 2개가 생성됐다.</li>
  <li>좌표 문제에서 가끔 나오는, 정밀도의 문제 (내가 이름지은..) 였다.</li>
  <li>이 문제의 해결법은 좌표계 자체를 2배씩 키우고, 한번 하던 이동을 2번으로 바꿔주는 것이었다.</li>
  <li>arrows의 각 원소를 2번씩으로 늘린, newArrows를 만들고, 이전까지의 로직을 newArrows를 기반으로 실행했더니 통과했다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>level5문제는 아마 이번이 처음 푼 것 같다.</li>
  <li>이쯤오니 문제가 정확히 요구하는 바가 무엇인지 안에 숨어있는 원리를 찾아내는게 정말 중요하게 느껴졌다.</li>
  <li>특히 좌표계가 나오면 항상 정밀도 문제를 생각해봐야겠다. (와 모래시계 모양으로 꽈서 연결하는건 정말 생각하지 못했다…)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><summary type="html"><![CDATA[49190. 방의 개수 / c++ / level5 / 2시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 23일차 TIL - 786 K-th Smallest Prime Fraction</title><link href="https://sho1007.github.io/leetcode/786/" rel="alternate" type="text/html" title="99클럽 코테 스터디 23일차 TIL - 786 K-th Smallest Prime Fraction" /><published>2024-06-11T00:00:00+00:00</published><updated>2024-06-11T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/786</id><content type="html" xml:base="https://sho1007.github.io/leetcode/786/"><![CDATA[<h1 id="786-k-th-smallest-prime-fraction--c--medium--14분">786. K-th Smallest Prime Fraction / c++ / Medium / 14분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">kthSmallestPrimeFraction</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]});</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">bool</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">});</span>

        <span class="k">return</span> <span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>문제는 1과 소수로 이루어진 정렬된 배열에서 원소 2개를 겹치지 않게 뽑아서 분수 (분자/분모 순) 을 만들었을 때,
k 번째로 작은 수가 되는 경우를 구하는 것이었다.</li>
  <li>일단 조합의 모든 경우를 다 새로운 vector&lt;vector<int>&gt; vec에 넣어준다.</int></li>
  <li>그리고 정렬을 할 때, a[0] * b[1] &lt; b[0] * a[1] 식으로 정렬해준다. (결국 분수의 비교라 함은, 분모가 같은 상황에서 분자의 값이 작은 경우이고, 분모가 같으려면 두 분수의 분자 분모에 각 수를 곱해주면 되므로)</li>
  <li>그런뒤 vec[k-1]을 반환 (0부터 시작하므로)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이분 탐색 문제로 내준건데, 단순 정렬로도 풀 수 있어서 생각보다 빨리 풀었다. (효율은 떨어지지만)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[786. K-th Smallest Prime Fraction / c++ / Medium / 14분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 22일차 TIL - 43236 징검다리</title><link href="https://sho1007.github.io/programmers/43236/" rel="alternate" type="text/html" title="99클럽 코테 스터디 22일차 TIL - 43236 징검다리" /><published>2024-06-10T00:00:00+00:00</published><updated>2024-06-10T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43236</id><content type="html" xml:base="https://sho1007.github.io/programmers/43236/"><![CDATA[<h1 id="43236-징검다리--c--level4--2시간">43236. 징검다리 / c++ / level4 / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/4/43236.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="이분탐색">이분탐색</h3>
<ol>
  <li>결론은 돌을 n개 이하로 제거했을 때, 시작점(0), 각 다리 사이의 거리, 끝점(distance)가 모두 x이상일 때, 이 x에 들어갈 수 있는 수 중 가장 큰 값을 구하는 문제였다.</li>
  <li>이분탐색을 안쓰고 정렬이랑 우선순위큐를 써서 풀어보려고 시간을 엄청 썼다.</li>
  <li>결국 이분탐색으로 풀었는데, AI가 무슨 시작점과 끝점은 상관 없고, 각 돌 사이의 거리만 구하라고 해서, 내가 문제를 잘못 읽었나보다 하고 그렇게 풀었는데, 틀렸다.</li>
  <li>다시 결과를 보니 내가 원래 읽었던 게 맞았다. 프로그래머스 AI는 문제가 많아 보인다.</li>
  <li>마지막 돌과 distance까지의 거리를 어떻게 구할까 고민했는데, (그 돌이 제거됐는지에 따라 달라지므로)</li>
  <li>그냥 매번 비교할 때, 이전돌과의 거리 &amp; distance와의 거리가 모두 mid 이상인지 체크하고, 아니면 제거하면 됐었다. (이걸 생각해내기까지 또 오래 걸렸다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>level4 문제는 맛있다. 그런데 너무 오래 걸려서 붙잡고 있다보면 시간이 사라진다.</li>
  <li>그래도 계속 풀다보면 익숙해지고 점차 속도가 붙지 않을까 생각하고 있다.</li>
  <li>99클럽 덕분에 기존에는 잘 도전하지 않던 문제들도 많이 접하게 돼서 도움이 된다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="BinarySearch" /><summary type="html"><![CDATA[43236. 징검다리 / c++ / level4 / 2시간+]]></summary></entry></feed>