<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-05-26T11:46:37+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 7일차 TIL - 2551 Put Marbles in Bags</title><link href="https://sho1007.github.io/leetcode/2551/" rel="alternate" type="text/html" title="99클럽 코테 스터디 7일차 TIL - 2551 Put Marbles in Bags" /><published>2024-05-26T00:00:00+00:00</published><updated>2024-05-26T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2551</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2551/"><![CDATA[<h1 id="2551-put-marbles-in-bags--c--hard--1시간">2551. Put Marbles in Bags / c++ / Hard / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">costVector</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">putMarbles</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">costVector</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">costVector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">costVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costVector</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">maxCost</span> <span class="o">+=</span> <span class="n">costVector</span><span class="p">[</span><span class="n">costVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">minCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">minCost</span> <span class="o">+=</span> <span class="n">costVector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">maxCost</span> <span class="o">-</span> <span class="n">minCost</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>가장 단순하게 모든 구간을 잘라봤다. (전수조사, 백트래킹) -&gt; 시간 초과</li>
  <li>시간을 단축할 수 있는 방법을 찾아보려 했지만 결국 찾지 못했고, 힌트를 봤다.</li>
  <li>힌트에서 나눠지는 부분의 앞과 뒤를 사용해라고 나와 있었다.</li>
  <li>pair&lt;int,int&gt; 를 원소로 가지는 우선순위 큐를 선언하여 끊어질 수 있는 부분을 모두 넣었다.</li>
  <li>이러면 크거나 작은 한가지의 기준으로 정렬된 값을 꺼낼 수 있지만 여기선 최소값과 최대값 두가지의 기준이 필요했고, 기존 방법으로는 정렬의 반대 순서로 꺼내는게 번거로웠다.</li>
  <li>다시 생각해보니 굳이 우선순위 큐를 쓰지 않고, 벡터에 다 넣은 다음 정렬하면 앞뒤로 꺼낼 수 있었다.</li>
  <li>다른 분들의 풀이를 보니 또 굳이 pair&lt;int,int&gt; 로 나눠지는 부분을 받지 않고, 어차피 더해질 거 그냥 int 로 처음부터 더한 값을 원소로 받으면 된다는 점을 깨달았다.</li>
  <li>마지막으로 항상 maxSum - minSum을 반환하기 때문에, 맨 앞과 맨 뒤 원소는 maxSum과 minSum에 모두 포함되어 결국 상쇄되는 값이었다.</li>
  <li>이런 최적화 과정을 통해 최종 식이 (내림차순 정렬의 k-1개의 원소의 합) - (오름차순 정렬의 k-1개의 원소의 합) 이라는 점을 깨달았다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>리트코드는 힌트와 풀이 방법을 제공해준다는 점이 신기했다.</li>
  <li>힌트도 단계별로 나눠져 있어서 하다가 도저히 안되겠을 때 차례로 한 개씩 열어볼 수 있다는 점이 좋았다.</li>
  <li>이해하고 나니 단순 정렬 문제였는데, 풀이 과정을 유추해 내는 것이 너무 어려웠다.</li>
  <li>마치 구현 방법을 식으로 나타내고 그 식을 최적화하여 최종 계산식을 뽑아내는 느낌이었다.</li>
  <li>내가 부족한 부분이 문제 전체를 도식화하여 해결하는 능력이라는 것을 다시 한번 깨달을 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[2551. Put Marbles in Bags / c++ / Hard / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 6일차 TIL - 42628 이중우선순위큐</title><link href="https://sho1007.github.io/programmers/42628/" rel="alternate" type="text/html" title="99클럽 코테 스터디 6일차 TIL - 42628 이중우선순위큐" /><published>2024-05-25T00:00:00+00:00</published><updated>2024-05-25T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42628</id><content type="html" xml:base="https://sho1007.github.io/programmers/42628/"><![CDATA[<h1 id="42628-이중우선순위큐--c--level3--32분">42628. 이중우선순위큐 / c++ / level3 / 32분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42628.%E2%80%85%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="구현--자료구조--힙--셋-set">구현 / 자료구조 / 힙 / 셋 (Set)</h3>
<ol>
  <li>해당 요구사항에 맞게 자료구조를 구현하면 되는 문제였다.</li>
  <li>multiset을 사용해서 혹시 모를 중복에 대비하며, 자료를 입력과 동시에 정렬해줬다.</li>
  <li>D 1 의 경우 최대값을 삭제해야하므로 set 의 마지막 원소를 erase 해줬다.</li>
  <li>D -1 의 경우 최소값을 삭제해야하므로 set의 첫번째 원소를 erase 해줬다.</li>
  <li>마지막으로 set이 비어있는 경우 0,0을, set의 원소가 1개인 경우 해당 원소를 두번 출력해줬다.</li>
  <li>set의 원소가 2개 이상인 경우 set 의 begin 과 end -1 을 출력해줬다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>자료구조에 대한 이해가 있다면 set 혹은 priority_queue 등을 사용해서 쉽게 풀 수 있는 문제였던 것 같다.</li>
  <li>지금 와서 생각해보니 출력을 set의 원소가 0 / 1 / 2 이상 인 3가지로 잡지 않고 set이 비어있거나, 비어있지 않은 2가지 경우로 잡아도 충분히 출력이 가능한 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Heap" /><summary type="html"><![CDATA[42628. 이중우선순위큐 / c++ / level3 / 32분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 5일차 TIL - 42627 디스크 컨트롤러</title><link href="https://sho1007.github.io/programmers/42627/" rel="alternate" type="text/html" title="99클럽 코테 스터디 5일차 TIL - 42627 디스크 컨트롤러" /><published>2024-05-24T00:00:00+00:00</published><updated>2024-05-24T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42627</id><content type="html" xml:base="https://sho1007.github.io/programmers/42627/"><![CDATA[<h1 id="42627-디스크-컨트롤러--c--level3--1시간">42627. 디스크 컨트롤러 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42627.%E2%80%85%EB%94%94%EC%8A%A4%ED%81%AC%E2%80%85%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--힙--우선순위-큐">자료구조 / 힙 / 우선순위 큐</h3>
<ol>
  <li>문제 자체는 단순했다.</li>
  <li>현재 처리할 수 있는 일들 중 가장 짧은 일을 처리한다.</li>
  <li>모든 일을 처리할 때까지 반복</li>
  <li>이 때, 일을 짧은 순서로 정리하기 위해서 우선순위 큐를 사용했다.</li>
  <li>하지만 간과한 것이 2가지 있었다.
    <ol>
      <li>매번 일을 하나 처리할 때마다, 현재 시간이 증가하기 때문에, 새로운 일들이 들어온다. 이를 놓쳐서 큐에 있는 모든 일을 처리한 뒤 새로운 일들을 큐에 받아들였더니 틀린 답이 나왔었다.</li>
      <li>첫 일을 정할때도 가장 짧은 일을 골라야 한다. jobs 벡터가 정렬되어 있지 않을 것이라고 생각해서 정렬을 했었지만, 단순 시작 시간으로만 정렬을 했었다. 그랬더니 아마 첫 일을 가장 빠른 일이지만 가장 짧은 일을 고르지 못해서 틀렸던 것 같다.</li>
    </ol>
  </li>
  <li>위의 두가지 문제를 해결했더니 정답을 맞출 수 있었다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 자체는 굉장히 단순하다고 생각했는데, 엣지 케이스를 찾는데 너무 많은 시간을 허비했다.</li>
  <li>다음부터 이렇게 뭔가 놓치는 부분이 보이면 수도코드로 어느정도 정리해서 엣지 케이스를 잡을 수 있도록 해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Heap" /><summary type="html"><![CDATA[42627. 디스크 컨트롤러 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 4일차 TIL - 12909 옳바른 괄호</title><link href="https://sho1007.github.io/programmers/12909/" rel="alternate" type="text/html" title="99클럽 코테 스터디 4일차 TIL - 12909 옳바른 괄호" /><published>2024-05-23T00:00:00+00:00</published><updated>2024-05-23T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/12909</id><content type="html" xml:base="https://sho1007.github.io/programmers/12909/"><![CDATA[<h1 id="12909-옳바른-괄호--c--level2--8분">12909. 옳바른 괄호 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/12909.%E2%80%85%EC%98%AC%EB%B0%94%EB%A5%B8%E2%80%85%EA%B4%84%ED%98%B8"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--스택">자료구조 / 스택</h3>
<ol>
  <li>괄호 문제는 일단 스택을 생각하고 봐야한다.</li>
  <li>만약 배열의 원소의 갯수가 홀수라면 false를 리턴</li>
  <li>아니라면 배열을 순회하며
    <ol>
      <li>여는 괄호가 나오면 스택에 push</li>
      <li>닫는 괄호가 나오면 스택의 top이 여는 괄호인지 체크
        <ol>
          <li>스택이 비어있거나 스택의 top이 여는 괄호가 아니라면 false 리턴</li>
          <li>스택의 top이 여는 괄호라면 스택을 pop</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>배열 순회가 무사히 끝나면 true 리턴</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>괄호 문제 = 스택이라는 공식을 다시 한번 체감할 수 있는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Stack" /><summary type="html"><![CDATA[12909. 옳바른 괄호 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 3일차 TIL - 42586 기능개발</title><link href="https://sho1007.github.io/programmers/42586/" rel="alternate" type="text/html" title="99클럽 코테 스터디 3일차 TIL - 42586 기능개발" /><published>2024-05-22T00:00:00+00:00</published><updated>2024-05-22T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42586</id><content type="html" xml:base="https://sho1007.github.io/programmers/42586/"><![CDATA[<h1 id="42586-기능개발--c--level2--11분">42586. 기능개발 / c++ / level2 / 11분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42586.%E2%80%85%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="구현">구현</h3>
<ol>
  <li>완료되지 않은 가장 앞의 작업이 100을 넘길때까지 계속 작업량을 한번씩 더함</li>
  <li>완료되지 않은 가장 앞의 작업이 100을 넘기면, 그 뒤로 100이 넘어간 작업이 몇개 더 있는지 체크</li>
  <li>해당 갯수만큼 정답 벡터에 삽입, 만약 완료되지 않은 작업이 남았다면 다시 완료되지 않은 가장 앞의 작업에서 1번부터 반복</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제의 카테고리에는 자료구조와 큐가 적혀있었는데 이 문제는 단순 구현으로만 풀어서 뭔가 더 좋은 방법이 없나 고민해봤다.</li>
  <li>while 문으로 현재 작업이 100%를 넘길때까지 반복할게 아니라, (100 - 현재 작업량)/작업 속도를 해서 작업일을 구하고, 그 뒤로 해당 작업일까지 작업했을 때 같이 배포할 수 있는 것들의 수를 더해서 벡터에 삽입하는 방식이 더 효율적이라고 생각했다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Queue" /><summary type="html"><![CDATA[42586. 기능개발 / c++ / level2 / 11분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 2일차 TIL - 42578 의상</title><link href="https://sho1007.github.io/programmers/42578/" rel="alternate" type="text/html" title="99클럽 코테 스터디 2일차 TIL - 42578 의상" /><published>2024-05-21T00:00:00+00:00</published><updated>2024-05-21T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42578</id><content type="html" xml:base="https://sho1007.github.io/programmers/42578/"><![CDATA[<h1 id="42578-의상--c--level2--8분">42578. 의상 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42578.%E2%80%85%EC%9D%98%EC%83%81"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--해시">자료구조 / 해시</h3>
<ol>
  <li>매일 다른 옷을 입어야 하고 종류별로 최대 1가지 의상을 착용하거나 착용하지 않을 수 있는데, 최소 1가지의 옷은 입어야 한다.</li>
  <li>문제를 보고 든 생각은 종류 (카테고리) 별로 옷을 나누고, 그 옷들의 조합의 수를 구하는 것이었다.</li>
  <li>이 때 주의해야 할 점은 3가지이다.
    <ol>
      <li>각 종류별로 1가지를 입거나 입지 않을 수 있기 때문에 종류의 가짓수 + 1을 한 값에서 조합을 구해야 한다.</li>
      <li>최소 1개의 옷을 입어야 하기 때문에 모두 입지 않은 경우는 빼야한다.</li>
      <li>마지막으로 옷의 종류가 1가지만 있는 경우 1번과 2번이 상충되어 해당 종류의 가짓수를 그대로 출력한다.</li>
    </ol>
  </li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>챌린저 문제를 한참 고민하다 시간이 촉박하여 미들러 문제를 풀게 되었다.</li>
  <li>해싱을 통해 데이터를 정리 (나는 이것을 재료 손질이라고 부른다.) 하고 그 데이터를 가지고 추가적인 로직(여기서는 조합)과 예외 조건 등을 처리하는 문제였다.</li>
  <li>해싱은 그 자체로 문제 해결 알고리즘이 될 수 있지만, 이렇게 문제를 풀기 위한 사전 작업이 될 수도 있다는 점을 다시 한번 깨달았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Hash" /><summary type="html"><![CDATA[42578. 의상 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 1일차 TIL - 42579 베스트앨범</title><link href="https://sho1007.github.io/programmers/42579/" rel="alternate" type="text/html" title="99클럽 코테 스터디 1일차 TIL - 42579 베스트앨범" /><published>2024-05-20T00:00:00+00:00</published><updated>2024-05-20T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42579</id><content type="html" xml:base="https://sho1007.github.io/programmers/42579/"><![CDATA[<h1 id="42579-베스트앨범--c--level3--13분">42579. 베스트앨범 / c++ / level3 / 13분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42579.%E2%80%85%EB%B2%A0%EC%8A%A4%ED%8A%B8%EC%95%A8%EB%B2%94"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--해시--정렬">자료구조 / 해시 / 정렬</h3>
<ol>
  <li>문제를 읽고 든 생각은 총 2개의 컨테이너가 필요하다는 것이었다.
    <ol>
      <li>각 장르별 총 재생 횟수를 저장하는 컨테이너</li>
      <li>각 장르마다 곡의 인덱스와 재생 횟수를 저장하는 컨테이너</li>
    </ol>
  </li>
  <li>그래서 genres와 plays 벡터를 순회하면서 형식에 맞게 자료를 저장했다.</li>
  <li>문제의 요구 사항 1번이 ‘속한 노래가 많이 재생된 장르를 먼저 수록합니다.’ 였으므로 1번 컨테이너를 재생 횟수 순으로 정렬했다.</li>
  <li>정렬된 1번 컨테이너를 순회하면서 (이러면 자연스럽게 재생 횟수 순으로 노래가 들어가게 된다.) 해당 장르에 속하는 2번 컨테이너를 정렬했는데, 이 때 문제의 요구 사항 2, 3번을 적용했다.</li>
  <li>정렬된 2번 컨테이너에서 (장르가 존재한다는 것은 해당 장르의 노래가 최소 한 곡 이상은 존재한다는 의미이므로) 우선 첫 번째 원소의 인덱스를 정답 벡터에 삽입하고, 컨테이너 사이즈가 1 이상이면 두 번째 원소의 인덱스도 정답 벡터에 삽입했다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 외적으로 99클럽이 빠른 시일 내에 다시 열려서 기쁘다. 혼자서 코테 준비를 하게 되면 아무래도 꾸준하게 하기가 어려웠는데, 99클럽을 통해 다시 꾸준하게 코테 준비를 이어나가야겠다.</li>
  <li>문제는 해시 (맵) 과 정렬을 사용하면 비교적 쉽게 풀리는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Hash" /><category term="Sort" /><summary type="html"><![CDATA[42579. 베스트앨범 / c++ / level3 / 13분]]></summary></entry><entry><title type="html">18352 특정 거리의 도시 찾기</title><link href="https://sho1007.github.io/boj/18352/" rel="alternate" type="text/html" title="18352 특정 거리의 도시 찾기" /><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/18352</id><content type="html" xml:base="https://sho1007.github.io/boj/18352/"><![CDATA[<h1 id="18352-특정-거리의-도시-찾기--c--silver2--30분">18352 특정 거리의 도시 찾기 / c++ / Silver2 / 30분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/18352.%E2%80%85%ED%8A%B9%EC%A0%95%E2%80%85%EA%B1%B0%EB%A6%AC%EC%9D%98%E2%80%85%EB%8F%84%EC%8B%9C%E2%80%85%EC%B0%BE%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프--다익스트라">그래프 / 다익스트라</h3>
<ol>
  <li>각 도시간의 거리는 1이다.</li>
  <li>최대 도시 수는 300’000으로, 인접행렬로 구하기엔 공간 복잡도가 높다. <br />
 -&gt; 인접 리스트를 사용</li>
  <li>시작 도시 X에서 다익스트라 알고리즘으로 각 도시까지의 거리를 구한다.</li>
  <li>계산이 끝나면 그 중 거리가 K인 도시를 사전 순으로 출력, 없다면 -1을 출력한다.</li>
</ol>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>다익스트라 알고리즘을 적용해 볼 수 있는 비교적 간단한 문제였다.</li>
  <li>각 도시간의 거리가 1이라는 점, 큐와 다익스트라의 성질에 의해 먼저 접근한 도시가 당연히 거리가 짧게 된다. (그래서 거리를 비교할게 아니라 방문만 했다면 바로 건너뛰면 됨)</li>
  <li>1차 시도에서 시간이 960ms가 나와서 왜 그런지 찾아봤더니 인접 리스트를 저장할 때 Map으로 저장한게 시간을 지연시켰었다.
300’000개나 되는 도시를 다 저장하지 않아도 된다고 생각해서 검색 속도가 빠른 Map을 사용한 것이었는데, 이정도 규모에서는 그냥 Vector를 사용하는 것이 훨씬 효율이 좋았다. (심지어 메모리도 더 적게 차지했다.)</li>
  <li>간만에 자료구조에 대해 다시 생각해볼 수 있는 좋은 경험이었다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="Dijkstra" /><summary type="html"><![CDATA[18352 특정 거리의 도시 찾기 / c++ / Silver2 / 30분]]></summary></entry><entry><title type="html">11652 카드</title><link href="https://sho1007.github.io/boj/11652/" rel="alternate" type="text/html" title="11652 카드" /><published>2024-05-05T00:00:00+00:00</published><updated>2024-05-05T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/11652</id><content type="html" xml:base="https://sho1007.github.io/boj/11652/"><![CDATA[<h1 id="11652-카드--c--silver4--8분">11652 카드 / c++ / Silver4 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/11652.%E2%80%85%EC%B9%B4%EB%93%9C"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조---맵--정렬">자료구조  / 맵 / 정렬</h3>
<ol>
  <li>준규가 가지는 하나의 카드는 long long 범위이다.</li>
  <li>맵을 사용하여 카드의 갯수를 증가시키며 저장</li>
  <li>카드 입력 종료 후 맵을 처음부터 순회하며 최대값 갱신때마다 answer에 해당 정수를 저장</li>
  <li>answer 출력</li>
</ol>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>자료형의 범위와 맵의 특징을 알고 있다면 쉽게 풀 수 있는 문제였다.</li>
  <li>맵을 벡터로 변환하여 정렬 후 가장 앞의 값을 출력해도 풀 수 있을 것 같다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Map" /><category term="Sort" /><summary type="html"><![CDATA[11652 카드 / c++ / Silver4 / 8분]]></summary></entry><entry><title type="html">3085 사탕 게임</title><link href="https://sho1007.github.io/boj/3085/" rel="alternate" type="text/html" title="3085 사탕 게임" /><published>2024-05-04T00:00:00+00:00</published><updated>2024-05-04T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/3085</id><content type="html" xml:base="https://sho1007.github.io/boj/3085/"><![CDATA[<h1 id="3085-사탕-게임--c--silver2--40분">3085 사탕 게임 / c++ / Silver2 / 40분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/3085.%E2%80%85%EC%82%AC%ED%83%95%E2%80%85%EA%B2%8C%EC%9E%84"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="브루트-포스--구현">브루트 포스 / 구현</h3>
<ol>
  <li>인접한 4칸 중 색이 다른 칸을 찾기
 (왼쪽위에서 우하향으로 내려오기 때문에 오른쪽, 아래만 검사하면 됨)</li>
  <li>서로 색을 바꾸기</li>
  <li>바꾼 칸 두 칸을 기준으로 4방향으로 뻗었을 때, 가장 긴 수를 반환</li>
  <li>최대값 갱신</li>
  <li>순회가 끝나면 최대값 출력</li>
</ol>

<p>-&gt; 내가 바꾸지 않은 부분에서 최대값이 나오는 경우를 탐지하지 못했다. (에제 2번)</p>

<p>그래서 1번 전에 우선 현재 칸 기준으로 최대값을 한번 찾는 로직을 추가했다. <br />
-&gt; 해결</p>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>코딩을 시작하기 전에 문제를 한번 분석하고 수도 코드를 작성하고 풀었더니 훨씬 쉽게 풀렸다.</li>
  <li>내가 바꾸지 않은 부분에서 최대값이 나올 수 있다는 것을 알았을 때, 처음엔 바꿀 때마다 전체 보드를 다 탐색해야 하나 생각했다.</li>
  <li>하지만 너무 비효율적이었고, 다른 방법을 찾던 중, 결국 내가 바꿨다면 변화가 거기에서만 오기때문에 그 부분만 찾는게 맞고, 아니라면 바꾸기 전 상태를 먼저 체크하면 되는게 아닌가 생각이 들었다.</li>
  <li>생각한대로 수정하고 문제를 해결하게 되어 엄청 뿌듯했다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Brute Force" /><summary type="html"><![CDATA[3085 사탕 게임 / c++ / Silver2 / 40분]]></summary></entry></feed>