<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-06-26T15:28:07+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 38일차 TIL - 3112 Minimum Time to Visit Disappearing Nodes</title><link href="https://sho1007.github.io/leetcode/3112/" rel="alternate" type="text/html" title="99클럽 코테 스터디 38일차 TIL - 3112 Minimum Time to Visit Disappearing Nodes" /><published>2024-06-26T00:00:00+00:00</published><updated>2024-06-26T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/3112</id><content type="html" xml:base="https://sho1007.github.io/leetcode/3112/"><![CDATA[<h1 id="3112-minimum-time-to-visit-disappearing-nodes--c--medium--1시간">3112. Minimum Time to Visit Disappearing Nodes / c++ / Medium / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minimumTime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">disappear</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">adjVector</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">adjVector</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">({</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]});</span>
            <span class="n">adjVector</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]].</span><span class="n">push_back</span><span class="p">({</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]});</span>
        <span class="p">}</span>

        <span class="n">set</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Set</span><span class="p">;</span>
        <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">});</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">Set</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">Iter</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Current</span> <span class="o">=</span> <span class="o">*</span><span class="n">Iter</span><span class="p">;</span>
            <span class="n">Set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Iter</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Iter</span> <span class="o">:</span> <span class="n">adjVector</span><span class="p">[</span><span class="n">Current</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">nextPos</span> <span class="o">=</span> <span class="n">Iter</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">nextTime</span> <span class="o">=</span> <span class="n">Current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Iter</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nextTime</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="n">disappear</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nextTime</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">EraseTarget</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">],</span> <span class="n">nextPos</span><span class="p">});</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">EraseTarget</span> <span class="o">!=</span> <span class="n">Set</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="n">Set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">EraseTarget</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextTime</span><span class="p">;</span>
                    <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">nextTime</span><span class="p">,</span> <span class="n">nextPos</span><span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프--다익스트라--set">그래프 / 다익스트라 / Set</h3>
<ol>
  <li>0부터 모든 노드까지의 최소 거리를 봤을 때 바로 다익스트라가 떠올랐다.</li>
  <li>이 문제엔 한가지 추가 조건이 있었는데, disappear[i]일 때, 해당 노드가 사라진다는 것이었다.</li>
  <li>그래서 다익스트라를 갱신할 때 nextTime &lt; disappear[nextPos] 조건을 추가해줬다. (다음 노드까지의 시간이 다음 노드가 사라질 시간보다 작을 때)</li>
  <li>n의 최대개수인 50000일 때 시간 초과가 났다.</li>
  <li>그래서 보통 다익스트라를 사용할 때는 큐를 활용했었는데, 가장 거리가 짧은 노드를 먼저 갱신해야할 꺼같아서 우선순위 큐로 바꿔줬었다. 하지만 그래도 시간초과</li>
  <li>고민하다 1시간이 넘었고 다른 사람들의 접근방법을 참고했는데, 그 중에 Set을 활용한 풀이가 눈에 띄었다.</li>
  <li>항상 우선순위 큐를 쓸 때 고민했던 건데, 우선순위 큐에 이미 들어간 값이 새롭게 갱신됐을 때, 기존 값을 어떻게 삭제할지가 문제였다.</li>
  <li>그런데 Set을 쓰게 되면, 기존값을 검색해서 삭제할 수 있고, 이 문제의 경우 {다음 노드까지의 최소거리, 다음 노드의 번호} 처럼 원소가 2개인 벡터로 Set을 만들면, 알아서 벡터의 첫 번째 원소 기준으로 정렬을 해주기때문에 우선순위 큐를 사용한 것 같은 효과를 낼 수 있었다.</li>
  <li>그렇게 갱신되면 기존 값을 Set에서 제거해주며 진행했더니 통과되었다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>항상 고민했었던, 우선순위 큐에서 갱신되버린 원소의 기존값을 삭제하는 문제를 Set을 활용해서 해결하는 방법을 배웠다.</li>
  <li>그리고 원소 2개짜리인 컨테이너가 필요할 때 항상 pair를 썼었는데, vector를 써도 된다는 점을 새롭게 배웠다. (사실 당연히 둘 다 {1, 2} 이런식으로 선언할 수 있는건데, 이걸 왜 이제 깨달았을까..)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Heap" /><summary type="html"><![CDATA[3112. Minimum Time to Visit Disappearing Nodes / c++ / Medium / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 37일차 TIL - 385 Mini Parser</title><link href="https://sho1007.github.io/leetcode/385/" rel="alternate" type="text/html" title="99클럽 코테 스터디 37일차 TIL - 385 Mini Parser" /><published>2024-06-25T00:00:00+00:00</published><updated>2024-06-25T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/385</id><content type="html" xml:base="https://sho1007.github.io/leetcode/385/"><![CDATA[<h1 id="385-mini-parser--c--medium--2시간">385. Mini Parser / c++ / Medium / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">NestedInteger</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'['</span><span class="p">)</span> <span class="k">return</span> <span class="n">NestedInteger</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

        <span class="n">NestedInteger</span> <span class="n">ni</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">current</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="s">""</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">ni</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">NestedInteger</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">current</span><span class="p">)));</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'['</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">bracketCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span><span class="sc">'['</span><span class="p">)</span> <span class="n">bracketCount</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span><span class="sc">']'</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bracketCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">ni</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">deserialize</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">current</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="s">""</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ni</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">NestedInteger</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">current</span><span class="p">)));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ni</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--스택">자료 구조 / 스택</h3>
<ol>
  <li>주어진 문자열을 NestedInteger라고 하는 자료형구조로 변환(복원)하는 문제였다.</li>
  <li>문자열이 ‘[‘로 시작하면 앞뒤의 ‘[‘와 ‘]’를 제거해준다.</li>
  <li>NestedInteger를 생성하고 문자열을 순회하면서 아래의 규칙으로 진행
    <ol>
      <li>’[‘을 만난다면, 괄호갯수를 카운트해주며 짝이 맞는 닫힌 괄호까지를 새롭게 deserialize에 넣어서 현재 NestedInteger에 add해준다. (그리고 i를 닫힌 괄호의 다음으로 이동)</li>
      <li>’,’를 만나면, 만약 current (integer로 바꿀 string)이 비어있지 않다면 NestedInteger로 만들어서 현재 NestedInteger에 추가해준다.</li>
      <li>위의 두 경우가 아니라면 숫자이므로 current에 추가해준다.</li>
    </ol>
  </li>
  <li>위의 방법으로 생성된 NestedInteger를 반환</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 자체는 재귀적으로 해결하면 쉬운 문제였지만, 이해를 잘못해서 시간을 엄청 잡아먹었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Stack" /><summary type="html"><![CDATA[385. Mini Parser / c++ / Medium / 2시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 36일차 TIL - 2434 Using a Robot to Print the Lexicographically Smallest String</title><link href="https://sho1007.github.io/leetcode/2434/" rel="alternate" type="text/html" title="99클럽 코테 스터디 36일차 TIL - 2434 Using a Robot to Print the Lexicographically Smallest String" /><published>2024-06-24T00:00:00+00:00</published><updated>2024-06-24T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2434</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2434/"><![CDATA[<h1 id="2434-using-a-robot-to-print-the-lexicographically-smallest-string--c--medium--1시간">2434. Using a Robot to Print the Lexicographically Smallest String / c++ / Medium / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">Stack</span><span class="p">;</span>
<span class="n">multiset</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ms</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">robotWithString</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="n">Stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Stack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
                <span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]));</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Stack</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">ms</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
                <span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]));</span>
            <span class="p">}</span>

            <span class="n">answer</span> <span class="o">+=</span> <span class="n">Stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">Stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="c1">// cout &lt;&lt; answer &lt;&lt; '\n';</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Stack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">Stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">Stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--스택">자료 구조 / 스택</h3>
<ol>
  <li>주어진 문자열 s와, 저장 공간 t를 활용하여 만들어질 수 있는 문자열 중, 사전적으로 가장 앞에 오는 문자열을 반환하는 문제</li>
  <li>답은 문제에 있었다. 1번 동작은 s의 가장 앞 문자를 t의 가장 뒤에 붙이는 것, 2번 동작은 t의 가장 뒤에 있는 문자를 종이 (여기선는 answer)에 추가하는 것이었다.</li>
  <li>2번에서 알 수 있듯이, t는 뒤에 추가되고, 뒤에서 제거된다. (LIFO) 즉, 스택 자료형이다.</li>
  <li>이를 토대로 로직을 재구성해보면</li>
  <li>우선 최소값을 알아야 하기 때문에 s의 모든 문자를 multiset인 ms에 넣는다.</li>
  <li>index가 n (s의 length)보다 작을 동안 아래를 반복</li>
  <li>만약 t가 비어있다면 s[index]를 t에 넣고, ms에서 s[index]를 제거해준 후 index 증가</li>
  <li>t.top()이 *ms.begin() (남은 문자열 중 가장 작은 문자) 보다 크다면, 계속 t에 넣는다.</li>
  <li>그러다 t.top()이 *ms.begin() 보다 작거나 같다면 (적지 않는 모든 문자 중 가장 작은 문자라면) answer에 적고 t에서 제거한다. (t.pop())</li>
  <li>결국 s의 모든 문자가 t에 들어가고 그 중 일부는 answer에 적힌 채로 반복이 종료된다.</li>
  <li>마지막으로 t가 빌 때까지, t에 들어있는 모든 문자를 answer에 추가해준다.</li>
  <li>answer를 반환</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>여러 방법을 생각하다 t의 구조가 stack과 유사하다고 생각했고, 남은 문자열의 최소 문자를 찾기 위해 multiset을 활용했다. 99클럽의 이전 문제에서 multiset을 활용했던 경험이 도움이 되었다.</li>
  <li>나름 어렵게 느껴진 문제였지만, stl을 활용하여 스스로 풀었다는 점에서 성취감을 느낄 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Stack" /><summary type="html"><![CDATA[2434. Using a Robot to Print the Lexicographically Smallest String / c++ / Medium / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 35일차 TIL - 2762 Continuous Subarrays</title><link href="https://sho1007.github.io/leetcode/2762/" rel="alternate" type="text/html" title="99클럽 코테 스터디 35일차 TIL - 2762 Continuous Subarrays" /><published>2024-06-23T00:00:00+00:00</published><updated>2024-06-23T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2762</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2762/"><![CDATA[<h1 id="2762-continuous-subarrays--c--medium--2시간">2762. Continuous Subarrays / c++ / Medium / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">MAX</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">MIN</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">ABS</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="o">-</span><span class="n">a</span><span class="p">;</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">continuousSubarrays</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ms</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">minNum</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="o">*</span><span class="n">ms</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
                    <span class="kt">int</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="o">*</span><span class="n">ms</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">ABS</span><span class="p">(</span><span class="n">minNum</span> <span class="o">-</span> <span class="n">maxNum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">ms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="o">++</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
            <span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="o">++</span><span class="p">]));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="투-포인터">투 포인터</h3>
<ol>
  <li>배열 nums의 부분 배열 중 모든 원소의 차이의 절대값이 2보다 작거나 같은 부분배열의 갯수를 반환하는 문제</li>
  <li>처음엔 원소의 개수에 따른 부분 배열의 개수를 저장하는 continuous 벡터를 사용했다. (ex. 원소가 1개인 부분배열이 2개라면 continuous[1] = 2)</li>
  <li>i로 1번 순회하면서 다시 j = i부터 2차 순회한다.
    <ol>
      <li>모든 nums[j]에 대해 min, max 값을 초기화해준다.</li>
      <li>max - min &gt; 2 이면 break;</li>
      <li>2번이 아니라면, (j - i + 1)개의 원소를 가지는 부분 배열이 하나 새로 생긴 것이므로 continuous[j - i + 1]++;</li>
    </ol>
  </li>
  <li>이런식으로 한 뒤, continuous의 모든 원소를 다 더한 값을 반환</li>
  <li>하지만 이 방법은 시간초과가 났었다. (지금 생각해보면 매번 i부터 시작해서 부분 배열을 만들 필요가 없었다.)</li>
  <li>여러 방법을 시도해봤지만 해결하지 못했고, 다른 사람들의 접근법을 참고했다.</li>
  <li>요점은 투 포인터였다, 내가 시도했던 방법은 원 포인터 i에 대해 2차 순회를 통해 매번 부분 배열을 만들었던 반면, 투 포인터를 쓰게 되면
    <ol>
      <li>left부터 right까지의 부분 배열을 구한다. (시작은 둘 다 0), left &lt; nums.size()로 1차 반복, 그 안에서 right &lt; nums.size()로 2차 반복한다.</li>
      <li>새로운 원소를 넣을 때 min, max 검사를 해주고 (이 때, multiset을 사용하여 begin(), rbegin()으로 부분 배열의 최소, 최대값을 가져올 수 있다.)</li>
      <li>조건에 만족한다면 부분 배열에 넣고, right를 1 증가</li>
      <li>조건에 만족하지 못한다면 answer에 거기까지의 부분배열의 개수 (해당 부분 배열의 원소 수, 여기서는 right - left)를 더해준다.</li>
      <li>그리고 부분 배열에서 nums[left] 원소를 빼주고, left를 1 증가</li>
      <li>2중 반복이 모두 완료되면, answer를 반환</li>
    </ol>
  </li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>요즘 나오는 스택 / 큐 카테고리의 문제들이 꽤나 어렵다. (그리고 스택 / 큐를 활용한 풀이법도 모르겠고 다른 알고리즘을 사용해서 풀게 된다.)</li>
  <li>어떤 배열의 연속된 부분 배열의 개수는 그 배열의 원소의 수였다. (ex. [1, 2, 3, 4]의 경우 [1], [1, 2], [1, 2, 3], [1, 2, 3, 4]의 부분 배열이 있는데, 이는 배열의 원소의 개수인 4와 동일하다.)</li>
  <li>첫 번째 풀이법에서 시간초과가 났었는데, 그 때 만들어둔 부분 배열을 초기화 하지 않고, 해당 배열에서 left 원소만 제거하고 다시 이어나갔어야했다. (사실 이게 투 포인터의 핵심 원리, 그 때는 투 포인터라고 생각하지 않고 접근해서 이 방법을 생각하지 못했다.)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="TwoPointer" /><summary type="html"><![CDATA[2762. Continuous Subarrays / c++ / Medium / 2시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 34일차 TIL - 2944 Minimum Number of Coins for Fruits</title><link href="https://sho1007.github.io/leetcode/2944/" rel="alternate" type="text/html" title="99클럽 코테 스터디 34일차 TIL - 2944 Minimum Number of Coins for Fruits" /><published>2024-06-22T00:00:00+00:00</published><updated>2024-06-22T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2944</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2944/"><![CDATA[<h1 id="2944-minimum-number-of-coins-for-fruits--c--medium--1시간">2944. Minimum Number of Coins for Fruits / c++ / Medium / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">MIN</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">Calculate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">minResult</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">endIndex</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">minResult</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">minResult</span><span class="p">,</span> <span class="n">Calculate</span><span class="p">(</span><span class="n">prices</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">minResult</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minimumCoins</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">Calculate</span><span class="p">(</span><span class="n">prices</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>i번째 과일을 사면, 그 이후의 i + 1 개만큼의 과일을 무료로 받을 수 있을 때, 모든 과일을 사는 최소 가격을 반환하는 문제</li>
  <li>현재 과일을 사는 것, 사지 않는 것 (이전에 과일을 산 경우) 로 나뉘어 풀리게 되므로 분할 정복, 그 중에서도 이전 값을 활용할 수 있으므로 DP를 사용했다.</li>
  <li>계산식은, i번째 과일의 가격 + (2 * i + 2) 번째까지 중 가장 작은 값이 된다. <br />
(여기서 왜 2 * i + 1 이 아닌 2 * i + 2가 되냐면, 무료로 받는 과일은 2 * i + 1 까지 이지만, 그렇게 되면 하나 뒤의 과일은 무조건 사야하는 상황이 된다. 하지만 3번 예시에서 알 수 있듯이, 무료로 받을 수 있는 과일을 삼으로써 값을 더 아낄 수 있는 경우가 있기 때문에, 결국 2 * i + 2 까지의 과일들 중 하나만 사면 되고, 그 최소값을 구해야하는 것이다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>점화식 도출이 어려워서 다른 사람들의 접근 방식을 참고했다. 역시나 DP는 아직까지도 점화식 도출이 어려운 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[2944. Minimum Number of Coins for Fruits / c++ / Medium / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 33일차 TIL - 2195 Append K Integers With Minimal Sum</title><link href="https://sho1007.github.io/leetcode/2195/" rel="alternate" type="text/html" title="99클럽 코테 스터디 33일차 TIL - 2195 Append K Integers With Minimal Sum" /><published>2024-06-21T00:00:00+00:00</published><updated>2024-06-21T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2195</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2195/"><![CDATA[<h1 id="2195-append-k-integers-with-minimal-sum--c--medium--8분">2195. Append K Integers With Minimal Sum / c++ / Medium / 8분+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">minimalKSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">addCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">nextNum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nextNum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">nextNum</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(;</span> <span class="n">nextNum</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">nextNum</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">answer</span> <span class="o">+=</span> <span class="n">nextNum</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">addCount</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">nextNum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">addCount</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">addCount</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">nextNum</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>k개의 중복되지 않은 양의 정수를 배열에 더할 때, 배열의 원소 합이 최소가 되는 정수들의 합을 구하는 문제였다.</li>
  <li>1번 조건을 다시 풀어서 적자면, 배열에 없는 원소를 가장 작은 순으로 k개 더한 합을 반환는 문제이다.</li>
  <li>배열을 정렬 후 순회하면서 nextNum (나올 것이라고 기대하는 수) 와 비교해준다.</li>
  <li>만약 nextNum &lt; nums[i] 이라면, nextNum부터 nums[i]-1까지는 배열에 포함되지 않은 수가 된다.</li>
  <li>그러면 다시 순회를 돌면서 nextNum부터 nums[i]-1까지를 answer에 더해준다. (중간에 addCount를 측정해서 k와 같아지면 break)</li>
  <li>배열 순회가 끝난 후에도 addCount &lt; k 이면, 다시 nextNum을 answer에 더하며 증가시켜준다. (배열의 원소들의 사잇값이 아닌, 배열의 끝 원소 이후에 추가되는 숫자들이다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>배열 원소의 사잇값만 생각하고, 배열 순회 후에 다시 addCount == k 가 될 때까지, nextNum을 더해줄 생각을 못했다. (만약 문제가 어렵게 나왔다면 테스트 케이스에도 이 부분을 명시하지 않았을 것이다.) 항상 이런 엣지 케이스들을 쉽게 놓치는데, 문제를 읽을 때 좀 더 면밀하게 조건을 분석해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[2195. Append K Integers With Minimal Sum / c++ / Medium / 8분+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 32일차 TIL - 2280 Minimum Lines to Represent a Line Chart</title><link href="https://sho1007.github.io/leetcode/2280/" rel="alternate" type="text/html" title="99클럽 코테 스터디 32일차 TIL - 2280 Minimum Lines to Represent a Line Chart" /><published>2024-06-20T00:00:00+00:00</published><updated>2024-06-20T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2280</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2280/"><![CDATA[<h1 id="2280-minimum-lines-to-represent-a-line-chart--c--medium--1시간">2280. Minimum Lines to Represent a Line Chart / c++ / Medium / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minimumLines</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">stockPrices</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">stockPrices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">stockPrices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">bool</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">});</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stockPrices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="n">stockPrices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">deltaX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">deltaY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stockPrices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">long</span> <span class="kt">long</span> <span class="n">currentDeltaX</span> <span class="o">=</span> <span class="n">stockPrices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">stockPrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">long</span> <span class="kt">long</span> <span class="n">currentDeltaY</span> <span class="o">=</span> <span class="n">stockPrices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">stockPrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">deltaX</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">deltaY</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">deltaX</span> <span class="o">*</span> <span class="n">currentDeltaY</span> <span class="o">!=</span> <span class="n">currentDeltaX</span> <span class="o">*</span> <span class="n">deltaY</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">answer</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">deltaX</span> <span class="o">=</span> <span class="n">currentDeltaX</span><span class="p">;</span>
            <span class="n">deltaY</span> <span class="o">=</span> <span class="n">currentDeltaY</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>그래프를 그릴 때 필요한 선의 갯수를 반환하는 문제였다.</li>
  <li>1번 의미를 풀어보자면 두 정점이 주어졌을 때, deltaY / deltaX 로 기울기를 구한 뒤, 그 기울기가 이전 기울기보다 달라지면 새로운 선이 필요한 것이므로 answer++ 해주는 로직이었다.</li>
  <li>풀다가 알게 된 사실이지만, stockPrices는 정렬되어 있지 않아서, x값을 기준으로 정렬해줬다. 그 후 순회하면서 각 선분의 기울기를 구하고, 이전 기울기와 다르다면 answer++을 해줬었다.</li>
  <li>3번에서 또 문제가 발생했었는데, deltaY / deltaX로 기울기를 구할 때, 500000000 /499999999 같은 경우 기울기를 1로 인식해서 값이 틀리게 나왔다.</li>
  <li>한참 고민하다가 부동소수의 계산은 큰 정수의 계산으로 치환하는 편이 결과가 정확하다는 점이 기억나서, deltaY / deltaX가 아닌 이전deltaX * 현재deltaY 가 현재deltaX * 이전deltaY와 같은지로 기울기의 변화를 측정했다. (분모가 다른 분수의 비교 연산)</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>stockPrices가 정렬되어 있지 않은걸 간과한 것이 컸다. (당연히 x값을 기준으로 정렬되어 있을 것이라고 생각했는데, 다음부턴 항상 정렬을 먼저 신경써야겠다.)</li>
  <li>정밀한 소수점 자리 비교는 차라리 큰 정수형 비교로 치환하는 편이 좋다는 것을 몸소 체험할 수 있는 문제였다. (항상 부동소수점으로 인한 비교 오류가 있다는 것을 은연 중에 알고는 있었는데, 이번 기회에 확실하게 경험하고 해결할 수 있었다.)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[2280. Minimum Lines to Represent a Line Chart / c++ / Medium / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 31일차 TIL - 402 Remove K Digits</title><link href="https://sho1007.github.io/leetcode/402/" rel="alternate" type="text/html" title="99클럽 코테 스터디 31일차 TIL - 402 Remove K Digits" /><published>2024-06-19T00:00:00+00:00</published><updated>2024-06-19T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/402</id><content type="html" xml:base="https://sho1007.github.io/leetcode/402/"><![CDATA[<h1 id="402-remove-k-digits--c--medium--46분">402. Remove K Digits / c++ / Medium / 46분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">removeKdigits</span><span class="p">(</span><span class="n">string</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="s">"0"</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">removeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;)</span>
        <span class="p">{</span>
            <span class="c1">// cout &lt;&lt; removeCount &lt;&lt; " : " &lt;&lt; num &lt;&lt; '\n';</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">num</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">removeCount</span><span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">removeCount</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">num</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">num</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">removeCount</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">num</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">removeCount</span><span class="p">));</span>

        <span class="k">return</span> <span class="n">num</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">num</span> <span class="o">:</span> <span class="s">"0"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="문자열">문자열</h3>
<ol>
  <li>처음엔 완전탐색과 백트래킹으로 k개 만큼 제거한 뒤에 배열에 넣어서 정렬 후 최소값을 찾아볼까 했다.</li>
  <li>하지만 k와 num의 길이의 최대값은 10^5였고 1번 방식으로 풀다간 시간 / 공간 복잡도가 엄청 늘어남은 물론이고 해당 숫자를 담을 자료형 조차 없었다.</li>
  <li>그래서 단순 숫자대 숫자로 비교가 안된다는 것을 깨닫고, 그럼 문제를 풀기 위해선 규칙이 있을 것이라고 판단했다.</li>
  <li>첫 번째로 찾은 규칙은 이러했다. 만약 현재 자리의 수가 다음 자리의 수보다 크다면 제거하는 것이다. <br />
 (ex. 1243 에서 하나를 제거한다고 했을 때, 123이 제일 작은 수이다. 즉 4가 3보다 
 크므로 4를 제거하는 것이 정답이다.)</li>
  <li>4번 규칙대로 풀었더니 1234567890 에서 결과가 123456780 이 나왔다. i + 1에 접근해야 해서 for 문의 규칙을 i &lt; num.length() - 1로 걸었더니, 9가 제거되면서 num의 길이가 하나 줄어서 i &lt; num.length() - 1 에 걸려서 종료된 것이었다.</li>
  <li>5번을 해결하기 위해 한 자리를 제거할 때, i 도 1 감소시켜줬다. 그러면 1234567890에서 9를 제거하면 num[i]는 0이 아닌 8을 가리키게 되므로, 연쇄적으로 num[i] &gt; num[i+1] 조건문을 통해 연쇄적으로 줄여나갈 수 있게 된다.</li>
  <li>다음 문제는 6번까지의 for문 순회를 돌고 난 다음 removeCount(제거한 횟수)가 k보다 작아서 생기는 문제였다. 예를 들어 11111 처럼 다 같은 문자여서 조건식에 걸리지 않았던가, 10001 처럼 중간에 0이 들어가서 자동적으로 탈락된 경우 (이 경우엔 자동 탈락이므로 removeCount는 증가하지 않는다.), k = 5 일 때 둘 다 정답은 0이 나와야 했다.</li>
  <li>7번 문제점을 해결하면서 한가지 추가적인 규칙을 찾아냈다. for문 순회가 끝난 수를 보면 마치 12345 처럼 정렬된 모양새를 띈다는 점이었다.</li>
  <li>그래서 이 경우엔 앞에서 제거하는게 아닌, 뒷부분을 제거하는 것이 결과값을 줄이는 방법이었다.</li>
  <li>따라서 만약 k - removeCount (남은 제거 횟수)가 만약 현재 num의 길이보다 크거나 같다면, 다 지워야하는 경우이므로 num을 “” 로 만들어줬고 (이 경우 반환 과정에서 “0”으로 치환된다.), 그게 아니라면 num을 num.length() - (k - removeCount)로 만들어줬다. (num을 뒤에서부터 남은 제거 횟수만큼 제거한 부분 문자열)</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>medium 난이도 치고는 생각보다 풀이시간이 오래 걸렸다. (역시나 난 문자열에 약한 것 같다.)</li>
  <li>leetcode는 틀린 케이스를 자꾸 알려줘서 거기에 맞춰서 풀게되는 느낌이다. (내가 찾아낸 것들도 있지만 생각하지 않은 엣지 케이스를 알려줘서 뇌 빼고 보는 느낌)</li>
  <li>그래도 99클럽을 시작한 뒤로 꾸준히 하루 한 문제씩 풀면서 문제 해결 능력도 많이 올라온 것 같다.</li>
  <li>단적인 예로 이런 막히는 문제들도 이제는 다른 사람들의 풀이를 보지 않고 혼자 해결할 수 있게 되었다. (특히 내 약점인 문자열 문제였음에도)</li>
  <li>또한 오늘 내 글이 우수 TIL로 선정되었다는 공지가 올라왔고 성취감이 배로 늘었다.</li>
  <li>다시 한번 이런 커리큘럼을 만들어준 팀스파르타에 감사함을 느낀다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="String" /><summary type="html"><![CDATA[402. Remove K Digits / c++ / Medium / 46분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 30일차 TIL - 5 Longest Palindromic Substring</title><link href="https://sho1007.github.io/leetcode/5/" rel="alternate" type="text/html" title="99클럽 코테 스터디 30일차 TIL - 5 Longest Palindromic Substring" /><published>2024-06-18T00:00:00+00:00</published><updated>2024-06-18T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/5</id><content type="html" xml:base="https://sho1007.github.io/leetcode/5/"><![CDATA[<h1 id="5-longest-palindromic-substring--c--medium--13분">5. Longest Palindromic Substring / c++ / Medium / 13분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">answer</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">answer</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="kt">bool</span> <span class="n">isPalindrome</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="p">])</span>
                        <span class="p">{</span>
                            <span class="n">isPalindrome</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">isPalindrome</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">answer</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="문자열--백트래킹">문자열 / 백트래킹</h3>
<ol>
  <li>문자열 s의 부분문자열 중, 길이가 가장 긴 팰린드롬 문자열(거꾸로 뒤집어도 똑같은 문자) 를 반환하는 문제였다.</li>
  <li>가장 단순하게 완전 탐색을 시도해보았다.</li>
  <li>s의 시작부터 i 기준으로 순회한다.
    <ol>
      <li>s의 끝부터 j 기준으로 순회한다.</li>
      <li>만약 s[i] == s[j]이면, 첫 글자가 같으므로 팰린드롬일 가능성이 있다.
        <ol>
          <li>여기서 다시 k 를 기준으로 i + k &lt;= j - k 일 때까지 순회한다.</li>
          <li>s[i + k] != s[j - k]이면 팰린드롬이 아니므로 isPalindrome을 false로 바꾸고 break</li>
          <li>순회가 끝났는데 isPalindrome 이 true라면 answer를 갱신해준다.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>권장이 3시간이어서 걱정했는데 13분 만에 풀려서 허무했다.</li>
  <li>역시 가장 쉽고 간편한건 완전 탐색!</li>
  <li>풀다보니 계속 최적화 할 수 있는 부분 (탐색하려는 길이가 이미 answer의 길이보다 작거나 같으면 무의미) 이 계속 보여서 추가적으로 넣어줬지만, 결과상 큰 변화는 없었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="String" /><summary type="html"><![CDATA[5. Longest Palindromic Substring / c++ / Medium / 13분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 29일차 TIL - 556 Next Greater Element III</title><link href="https://sho1007.github.io/leetcode/556/" rel="alternate" type="text/html" title="99클럽 코테 스터디 29일차 TIL - 556 Next Greater Element III" /><published>2024-06-17T00:00:00+00:00</published><updated>2024-06-17T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/556</id><content type="html" xml:base="https://sho1007.github.io/leetcode/556/"><![CDATA[<h1 id="556-next-greater-element-iii--c--medium--18분">556. Next Greater Element III / c++ / Medium / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">answer</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numberVector</span><span class="p">;</span>
<span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">resultSet</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">intLimit</span> <span class="o">=</span> <span class="mi">2'147'483'647</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">BackTracking</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numberVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="n">intLimit</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">resultSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numberVector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">numberVector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">numberVector</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">numberVector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">BackTracking</span><span class="p">();</span>
        <span class="n">numberVector</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">numberVector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">nextGreaterElement</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">numberVector</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">resultSet</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="n">string</span> <span class="n">nString</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">numberVector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nString</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">BackTracking</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">resultSet</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">resultVector</span><span class="p">(</span><span class="n">resultSet</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">resultSet</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">resultVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">resultVector</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="k">return</span> <span class="n">resultVector</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="문자열--백트래킹">문자열 / 백트래킹</h3>
<ol>
  <li>n과 같은 숫자로 만들어진 수 중, n보다 크고, 그 중에서 가장 작은 수를 반환하는 문제</li>
  <li>1번 조건이 약간 이상하게 쓰여져있지만, 해석해보면 n과 같은 숫자의 조합으로 만들어진 수 중에서, n 바로 다음으로 큰 수를 구하는 문제였다.</li>
  <li>숫자를 각 자리마다 접근하기 위해서 to_string으로 문자열로 바꿔서 접근해줬다.</li>
  <li>모든 자리를 numberVector에 담아준다.</li>
  <li>그 후 백트래킹을 하면서 numberVector에 있는 수로 만들 수 있는 모든 수를 구해준다.</li>
  <li>숫자가 다 만들어지면, 해당 숫자가 n보다 크고, intLimit(32bit int의 최대 범위) 보다 작거나 같은지 체크한 뒤 resultSet에 담아준다. (중복을 피하기 위해서 unordered_set을 이용)</li>
  <li>위의 과정이 끝나면, resultSet을 다시 resultVector에 담는다. (만약 resultSet이 비었다면, 이 시점에서 -1을 반환)</li>
  <li>resultVector를 정렬 후 0번째 숫자 (즉, intLimit보다 작거나 같고, n보다 큰 수 중 가장 작은 수)를 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>백트래킹과 set 그리고 정렬을 이용해서 풆 수 있는 문제였다.</li>
  <li>32-bit int 라고 해서 unsigned int 는 아니겠지 하고 int의 최대 범위를 사용했는데 맞았다.</li>
  <li>조합할 수 있는 수는, 앞에 9가 오게 되고 10자리 인 경우 int의 최대 범위르 넘어갈 수 있으므로, 통 크게 unsigned long long 으로 잡아줬다. (n이 양의 정수이므로 음수는 가정하지 않았다)</li>
  <li>leetcode의 경우 전역변수를 공유해서 테스트케이스들을 처리하다보니, 전역변수를 선언하고 함수 안에서 초기화해주는 방식으로 사용했다. (이번엔 백트래킹에 사용되는 전역변수가 좀 많았다.)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="String" /><summary type="html"><![CDATA[556. Next Greater Element III / c++ / Medium / 18분]]></summary></entry></feed>