<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-07-02T15:53:13+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">CPU 스케줄링</title><link href="https://sho1007.github.io/operatingsystem/CPUScheduling/" rel="alternate" type="text/html" title="CPU 스케줄링" /><published>2024-07-02T00:00:00+00:00</published><updated>2024-07-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/CPUScheduling</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/CPUScheduling/"><![CDATA[<h1 id="cpu-스케줄링이란">CPU 스케줄링이란?</h1>
<p>운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것</p>

<h1 id="프로세스-우선순위">프로세스 우선순위</h1>
<p>가장 공정한 CPU 스케줄링? <br />
프로세스마다 우선순위가 다르다. (빨리 처리해야하는 프로세스와 늦게 처리해도 되는 프로세스)</p>
<ul>
  <li>입출력 집중 프로세스 (입출력 작업이 많은 프로세스) : 우선순위 높음</li>
  <li>CPU 집중 프로세스 (CPU 작업이 많은 프로세스) : 우선순위 낮음</li>
</ul>

<p>입출력 집중 프로세스는 어차피 CPU를 잠깐 쓰고 <code class="language-plaintext highlighter-rouge">대기 상태</code>로 넘어감 <br />
프로세스 우선순위는 PCB에 저장된다.</p>

<h1 id="스케줄링-큐">스케줄링 큐</h1>
<p>특정 자원을 이용하고 싶어하는 프로세스들이 서는 줄 (대기열?)</p>
<blockquote>
  <p>스케줄링에서의 큐는 반드시 FIFO일 필요는 없다. 프로세스별로 우선순위가 다르므로</p>
</blockquote>

<h2 id="준비-큐와-대기-큐">준비 큐와 대기 큐</h2>
<ul>
  <li>준비 큐 : CPU를 이용하고 싶어하는 프로세스들이 서는 줄</li>
  <li>대기 큐 : 입출력 장치를 이용하고 싶어하는 프로세스들이 서는 줄 (입출력 장치 별로 존재)
    <h2 id="선점형과-비선점형-스케줄링">선점형과 비선점형 스케줄링</h2>
    <p>이미 CPU를 할당받아서 실행 중인 프로세스가 있는데, 우선순위가 더 높은 프로세스가 있다면?</p>
  </li>
  <li>선점형 스케줄링 : 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
    <ul>
      <li>장점 : 어느 한 프로세스의 자원 독점을 막고, 골고루 자원을 배분할 수 있다.</li>
      <li>단점 : 문맥 교환 과정에서 오버헤드가 발생할 수 있다. (자주 발생)</li>
    </ul>
  </li>
  <li>비선점형 스케줄링 : 현재 CPU를 사용 중인 프로세스의 작업이 끝나기를 기다렸다가 CPU 자원을 할당
    <ul>
      <li>장점 : 문맥 교환에서 발생하는 오버헤드가 적다.</li>
      <li>단점 : 모든 프로세스가 골고루 자원을 이용하기 어렵다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[CPU 스케줄링이란? 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것]]></summary></entry><entry><title type="html">CPU 스케줄링 알고리즘</title><link href="https://sho1007.github.io/operatingsystem/CPUSchedulingAlgorithm/" rel="alternate" type="text/html" title="CPU 스케줄링 알고리즘" /><published>2024-07-02T00:00:00+00:00</published><updated>2024-07-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/CPUSchedulingAlgorithm</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/CPUSchedulingAlgorithm/"><![CDATA[<h1 id="cpu-스케줄링이란">CPU 스케줄링이란?</h1>
<p>운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것</p>

<h1 id="프로세스-우선순위">프로세스 우선순위</h1>
<p>가장 공정한 CPU 스케줄링? <br />
프로세스마다 우선순위가 다르다. (빨리 처리해야하는 프로세스와 늦게 처리해도 되는 프로세스)</p>
<ul>
  <li>입출력 집중 프로세스 (입출력 작업이 많은 프로세스) : 우선순위 높음</li>
  <li>CPU 집중 프로세스 (CPU 작업이 많은 프로세스) : 우선순위 낮음</li>
</ul>

<p>입출력 집중 프로세스는 어차피 CPU를 잠깐 쓰고 <code class="language-plaintext highlighter-rouge">대기 상태</code>로 넘어감 <br />
프로세스 우선순위는 PCB에 저장된다.</p>

<h1 id="스케줄링-큐">스케줄링 큐</h1>
<p>특정 자원을 이용하고 싶어하는 프로세스들이 서는 줄 (대기열?)</p>
<blockquote>
  <p>스케줄링에서의 큐는 반드시 FIFO일 필요는 없다. 프로세스별로 우선순위가 다르므로</p>
</blockquote>

<h2 id="준비-큐와-대기-큐">준비 큐와 대기 큐</h2>
<ul>
  <li>준비 큐 : CPU를 이용하고 싶어하는 프로세스들이 서는 줄</li>
  <li>대기 큐 : 입출력 장치를 이용하고 싶어하는 프로세스들이 서는 줄 (입출력 장치 별로 존재)
    <h2 id="선점형과-비선점형-스케줄링">선점형과 비선점형 스케줄링</h2>
    <p>이미 CPU를 할당받아서 실행 중인 프로세스가 있는데, 우선순위가 더 높은 프로세스가 있다면?</p>
  </li>
  <li>선점형 스케줄링 : 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
    <ul>
      <li>장점 : 어느 한 프로세스의 자원 독점을 막고, 골고루 자원을 배분할 수 있다.</li>
      <li>단점 : 문맥 교환 과정에서 오버헤드가 발생할 수 있다.</li>
    </ul>
  </li>
  <li>비선점형 스케줄링 : 현재 CPU를 사용 중인 프로세스의 작업이 끝나기를 기다렸다가 CPU 자원을 할당
    <ul>
      <li>장점 : 문맥 교환에서 발생하는 오버헤드가 적다.</li>
      <li>단점 : 모든 프로세스가 골고루 자원을 이용하기 어렵다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[CPU 스케줄링이란? 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것]]></summary></entry><entry><title type="html">프로세스 개요</title><link href="https://sho1007.github.io/operatingsystem/Process/" rel="alternate" type="text/html" title="프로세스 개요" /><published>2024-07-02T00:00:00+00:00</published><updated>2024-07-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/Process</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/Process/"><![CDATA[<h1 id="프로세스란">프로세스란?</h1>
<p>실행되기 전 데이터 덩어리 -&gt; 프로그램 <br />
실행되어서 메모리에 적재된 것 -&gt; 프로세스</p>

<h2 id="포그라운드-프로세스">포그라운드 프로세스</h2>
<p>사용자가 볼 수 있는 공간에서 실행되는 프로세스</p>
<h2 id="백그라운드-프로세스">백그라운드 프로세스</h2>
<p>사용자의 간섭 없이 보이지 않는 뒷편에서 실행 중인 프로세스 (서비스 / 데몬)</p>

<h1 id="프로세스-제어-블록">프로세스 제어 블록</h1>
<p>프로세스는 CPU가 필요하고, CPU 자원은 한정되어 있다. <br />
프로세스는 한정된 시간 만큼만 CPU 이용 가능 <br />
<strong>타이머 인터럽트</strong> 발생하면 다음 프로세스에게 차례를 양보 <br />
클럭신호를 발생하는 장치에서 주기적으로 발생하는 하드웨어 인터럽트</p>

<p>이렇게 빠르게 번갈아가며 수행하는 프로세스을 관리하기 위해 필요한 것이</p>
<h2 id="프로제스-제어-블록-pcb">프로제스 제어 블록 (PCB)</h2>
<p>프로세스 관련 정보를 저장하는 자료 구조 <br />
프로세스에 붙는 <code class="language-plaintext highlighter-rouge">상품 태그</code> <br />
프로세스 생성 시 커널 영역에 생성되고, 종료시 폐기 된다.</p>

<h3 id="pcb에-담기는-정보">PCB에 담기는 정보</h3>
<ul>
  <li>pid</li>
  <li>레지스터 값</li>
  <li>프로세스 상태</li>
  <li>CPU 스케줄링 정보</li>
  <li>메모리 정보</li>
  <li>사용한 파일과 입출력 장치 정보</li>
</ul>

<h4 id="pid">PID</h4>
<p>특정 프로세스를 식별하기 위해 부여하는 고유한 번호</p>

<h4 id="레지스터-값">레지스터 값</h4>
<ul>
  <li>타이머 인터럽트가 발생하면 <code class="language-plaintext highlighter-rouge">지금까지의 정보를 저장하고 있어야</code> 다시 복구하여 이어서 실행 가능</li>
  <li>프로그램 카운터, 스택 포인터 등</li>
</ul>

<h4 id="프로세스-상태">프로세스 상태</h4>
<ul>
  <li>입출력 장치를 위해 기다리는 상태</li>
  <li>생성 / 준비 / 실행 / 대기 / 종료</li>
</ul>

<h4 id="cpu-스케줄링-정보">CPU 스케줄링 정보</h4>
<p>프로세스가 언제, 어떤 순서로 CPU를 할당 받을 지</p>
<h4 id="메모리-정보">메모리 정보</h4>
<ul>
  <li>프로세스가 어느 주소에 저장되어 있는지에 대한 정보</li>
  <li>페이지 테이블 정보
    <h4 id="사용한-파일과-입출력-장지-정보">사용한 파일과 입출력 장지 정보</h4>
    <p>할당된 입출력 장치, 사용 중인 (열린) 파일 정보</p>
  </li>
</ul>

<h1 id="문맥-교환-context-switch">문맥 교환 (Context Switch)</h1>
<p>프로세스 A에서 프로세스 B로 실행 순서가 넘어가면 어떤 작업이 이루어져야 하는가?</p>
<ol>
  <li>기존에 실행되던 프로세스 A는 중간 정보를 백업
    <ul>
      <li>위의 PCB에 해당하는 정보</li>
      <li>이러한 정보를 <code class="language-plaintext highlighter-rouge">문맥 (Context)</code></li>
      <li>다음 차례에 실행을 재개하기 위한 정보</li>
    </ul>
  </li>
  <li>뒤이어 실행할 프로세스 B의 문맥을 복구
    <blockquote>
      <p>이처럼 기존에 실행 중인 프로세스의 문맥을 백업하고, 새로운 프로세스의 문맥을 복구하는 과정을 <code class="language-plaintext highlighter-rouge">문맥 교환</code>이라고 한다.</p>
      <ul>
        <li>여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리</li>
      </ul>
    </blockquote>
  </li>
</ol>

<h1 id="프로세스의-메모리-영역">프로세스의 메모리 영역</h1>
<blockquote>
  <p>코드 / 데이터 / 힙 / 스택</p>
</blockquote>

<h2 id="코드-영역-텍스트-영역">코드 영역 (텍스트 영역)</h2>
<ul>
  <li>기계어로 이루어진 명령어가 저장된 영역</li>
  <li>CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역 (Read-Only)
    <h2 id="데이터-영역">데이터 영역</h2>
  </li>
  <li>프로그램이 실행되는 동안 유지할 데이터를 저장</li>
  <li>지역 변수 / 정적 변수</li>
</ul>

<blockquote>
  <p>위의 두 영역은 크기가 변형되지 않으므로 <code class="language-plaintext highlighter-rouge">정적 할당 영역</code>이라고도 한다.</p>
</blockquote>

<h2 id="힙-영역">힙 영역</h2>
<ul>
  <li>사용자가 직접 할당할 수 있는 공간</li>
  <li>직접 할당하고 해제해야 함 / 최근 언어들은 G.C가 있어서 알아서 해줌 / 안하면 메모리 누수 (leak) 발생</li>
</ul>

<h2 id="스택-영역">스택 영역</h2>
<ul>
  <li>데이터가 일시적으로 저장되는 공간</li>
  <li>매개 변수 / 지역 변수</li>
</ul>

<blockquote>
  <p>위의 두 영역은 크기가 변형될 수 있으므로 <code class="language-plaintext highlighter-rouge">동적 할당 영역</code>이라고도 한다.</p>
</blockquote>

<blockquote>
  <p>힙 영역은 낮은 주소 -&gt; 높은 주소로 할당 <br />
스택 영역은 높은 주소 -&gt; 낮은 주소로 할당 <br />
동적 할당 영역이므로 둘이 반대되는 방향으로 할당 됨</p>
</blockquote>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[프로세스란? 실행되기 전 데이터 덩어리 -&gt; 프로그램 실행되어서 메모리에 적재된 것 -&gt; 프로세스]]></summary></entry><entry><title type="html">프로세스 상태와 계층 구조</title><link href="https://sho1007.github.io/operatingsystem/ProcessStateAndHirerachy/" rel="alternate" type="text/html" title="프로세스 상태와 계층 구조" /><published>2024-07-02T00:00:00+00:00</published><updated>2024-07-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/ProcessStateAndHirerachy</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/ProcessStateAndHirerachy/"><![CDATA[<h1 id="프로세스란">프로세스란?</h1>
<p>실행되기 전 데이터 덩어리 -&gt; 프로그램 <br />
실행되어서 메모리에 적재된 것 -&gt; 프로세스</p>

<h2 id="포그라운드-프로세스">포그라운드 프로세스</h2>
<p>사용자가 볼 수 있는 공간에서 실행되는 프로세스</p>
<h2 id="백그라운드-프로세스">백그라운드 프로세스</h2>
<p>사용자의 간섭 없이 보이지 않는 뒷편에서 실행 중인 프로세스 (서비스 / 데몬)</p>

<h1 id="프로세스-제어-블록">프로세스 제어 블록</h1>
<p>프로세스는 CPU가 필요하고, CPU 자원은 한정되어 있다. <br />
프로세스는 한정된 시간 만큼만 CPU 이용 가능 <br />
<strong>타이머 인터럽트</strong> 발생하면 다음 프로세스에게 차례를 양보 <br />
클럭신호를 발생하는 장치에서 주기적으로 발생하는 하드웨어 인터럽트</p>

<p>이렇게 빠르게 번갈아가며 수행하는 프로세스을 관리하기 위해 필요한 것이</p>
<h2 id="프로제스-제어-블록-pcb">프로제스 제어 블록 (PCB)</h2>
<p>프로세스 관련 정보를 저장하는 자료 구조 <br />
프로세스에 붙는 <code class="language-plaintext highlighter-rouge">상품 태그</code> <br />
프로세스 생성 시 커널 영역에 생성되고, 종료시 폐기 된다.</p>

<h3 id="pcb에-담기는-정보">PCB에 담기는 정보</h3>
<ul>
  <li>pid</li>
  <li>레지스터 값</li>
  <li>프로세스 상태</li>
  <li>CPU 스케줄링 정보</li>
  <li>메모리 정보</li>
  <li>사용한 파일과 입출력 장치 정보</li>
</ul>

<h4 id="pid">PID</h4>
<p>특정 프로세스를 식별하기 위해 부여하는 고유한 번호</p>

<h4 id="레지스터-값">레지스터 값</h4>
<ul>
  <li>타이머 인터럽트가 발생하면 <code class="language-plaintext highlighter-rouge">지금까지의 정보를 저장하고 있어야</code> 다시 복구하여 이어서 실행 가능</li>
  <li>프로그램 카운터, 스택 포인터 등</li>
</ul>

<h4 id="프로세스-상태">프로세스 상태</h4>
<ul>
  <li>입출력 장치를 위해 기다리는 상태</li>
  <li>생성 / 실행 / 대기 / 종료</li>
</ul>

<h4 id="cpu-스케줄링-정보">CPU 스케줄링 정보</h4>
<p>프로세스가 언제, 어떤 순서로 CPU를 할당 받을 지</p>
<h4 id="메모리-정보">메모리 정보</h4>
<ul>
  <li>프로세스가 어느 주소에 저장되어 있는지에 대한 정보</li>
  <li>페이지 테이블 정보
    <h4 id="사용한-파일과-입출력-장지-정보">사용한 파일과 입출력 장지 정보</h4>
    <p>할당된 입출력 장치, 사용 중인 (열린) 파일 정보</p>
  </li>
</ul>

<h1 id="문맥-교환-context-switch">문맥 교환 (Context Switch)</h1>
<p>프로세스 A에서 프로세스 B로 실행 순서가 넘어가면 어떤 작업이 이루어져야 하는가?</p>
<ol>
  <li>기존에 실행되던 프로세스 A는 중간 정보를 백업
    <ul>
      <li>위의 PCB에 해당하는 정보</li>
      <li>이러한 정보를 <code class="language-plaintext highlighter-rouge">문맥 (Context)</code></li>
      <li>다음 차례에 실행을 재개하기 위한 정보</li>
    </ul>
  </li>
  <li>뒤이어 실행할 프로세스 B의 문맥을 복구
    <blockquote>
      <p>이처럼 기존에 실행 중인 프로세스의 문맥을 백업하고, 새로운 프로세스의 문맥을 복구하는 과정을 <code class="language-plaintext highlighter-rouge">문맥 교환</code>이라고 한다.</p>
      <ul>
        <li>여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리</li>
      </ul>
    </blockquote>
  </li>
</ol>

<h1 id="프로세스의-메모리-영역">프로세스의 메모리 영역</h1>
<blockquote>
  <p>코드 / 데이터 / 힙 / 스택</p>
</blockquote>

<h2 id="코드-영역-텍스트-영역">코드 영역 (텍스트 영역)</h2>
<ul>
  <li>기계어로 이루어진 명령어가 저장된 영역</li>
  <li>CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역 (Read-Only)
    <h2 id="데이터-영역">데이터 영역</h2>
  </li>
  <li>프로그램이 실행되는 동안 유지할 데이터를 저장</li>
  <li>지역 변수 / 정적 변수</li>
</ul>

<blockquote>
  <p>위의 두 영역은 크기가 변형되지 않으므로 <code class="language-plaintext highlighter-rouge">정적 할당 영역</code>이라고도 한다.</p>
</blockquote>

<h2 id="힙-영역">힙 영역</h2>
<ul>
  <li>사용자가 직접 할당할 수 있는 공간</li>
  <li>직접 할당하고 해제해야 함 / 최근 언어들은 G.C가 있어서 알아서 해줌 / 안하면 메모리 누수 (leak) 발생</li>
</ul>

<h2 id="스택-영역">스택 영역</h2>
<ul>
  <li>데이터가 일시적으로 저장되는 공간</li>
  <li>매개 변수 / 지역 변수</li>
</ul>

<blockquote>
  <p>위의 두 영역은 크기가 변형될 수 있으므로 <code class="language-plaintext highlighter-rouge">동적 할당 영역</code>이라고도 한다.</p>
</blockquote>

<blockquote>
  <p>힙 영역은 낮은 주소 -&gt; 높은 주소로 할당 <br />
스택 영역은 높은 주소 -&gt; 낮은 주소로 할당 <br />
동적 할당 영역이므로 둘이 반대되는 방향으로 할당 됨</p>
</blockquote>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><summary type="html"><![CDATA[프로세스란? 실행되기 전 데이터 덩어리 -&gt; 프로그램 실행되어서 메모리에 적재된 것 -&gt; 프로세스]]></summary></entry><entry><title type="html">프로세스 상태와 계층 구조</title><link href="https://sho1007.github.io/operatingsystem/Thread/" rel="alternate" type="text/html" title="프로세스 상태와 계층 구조" /><published>2024-07-02T00:00:00+00:00</published><updated>2024-07-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/Thread</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/Thread/"><![CDATA[<h1 id="프로세스란">프로세스란?</h1>
<p>실행되기 전 데이터 덩어리 -&gt; 프로그램 <br />
실행되어서 메모리에 적재된 것 -&gt; 프로세스</p>

<h2 id="포그라운드-프로세스">포그라운드 프로세스</h2>
<p>사용자가 볼 수 있는 공간에서 실행되는 프로세스</p>
<h2 id="백그라운드-프로세스">백그라운드 프로세스</h2>
<p>사용자의 간섭 없이 보이지 않는 뒷편에서 실행 중인 프로세스 (서비스 / 데몬)</p>

<h1 id="프로세스-제어-블록">프로세스 제어 블록</h1>
<p>프로세스는 CPU가 필요하고, CPU 자원은 한정되어 있다. <br />
프로세스는 한정된 시간 만큼만 CPU 이용 가능 <br />
<strong>타이머 인터럽트</strong> 발생하면 다음 프로세스에게 차례를 양보 <br />
클럭신호를 발생하는 장치에서 주기적으로 발생하는 하드웨어 인터럽트</p>

<p>이렇게 빠르게 번갈아가며 수행하는 프로세스을 관리하기 위해 필요한 것이</p>
<h2 id="프로제스-제어-블록-pcb">프로제스 제어 블록 (PCB)</h2>
<p>프로세스 관련 정보를 저장하는 자료 구조 <br />
프로세스에 붙는 <code class="language-plaintext highlighter-rouge">상품 태그</code> <br />
프로세스 생성 시 커널 영역에 생성되고, 종료시 폐기 된다.</p>

<h3 id="pcb에-담기는-정보">PCB에 담기는 정보</h3>
<ul>
  <li>pid</li>
  <li>레지스터 값</li>
  <li>프로세스 상태</li>
  <li>CPU 스케줄링 정보</li>
  <li>메모리 정보</li>
  <li>사용한 파일과 입출력 장치 정보</li>
</ul>

<h4 id="pid">PID</h4>
<p>특정 프로세스를 식별하기 위해 부여하는 고유한 번호</p>

<h4 id="레지스터-값">레지스터 값</h4>
<ul>
  <li>타이머 인터럽트가 발생하면 <code class="language-plaintext highlighter-rouge">지금까지의 정보를 저장하고 있어야</code> 다시 복구하여 이어서 실행 가능</li>
  <li>프로그램 카운터, 스택 포인터 등</li>
</ul>

<h4 id="프로세스-상태">프로세스 상태</h4>
<ul>
  <li>입출력 장치를 위해 기다리는 상태</li>
  <li>생성 / 실행 / 대기 / 종료</li>
</ul>

<h4 id="cpu-스케줄링-정보">CPU 스케줄링 정보</h4>
<p>프로세스가 언제, 어떤 순서로 CPU를 할당 받을 지</p>
<h4 id="메모리-정보">메모리 정보</h4>
<ul>
  <li>프로세스가 어느 주소에 저장되어 있는지에 대한 정보</li>
  <li>페이지 테이블 정보
    <h4 id="사용한-파일과-입출력-장지-정보">사용한 파일과 입출력 장지 정보</h4>
    <p>할당된 입출력 장치, 사용 중인 (열린) 파일 정보</p>
  </li>
</ul>

<h1 id="문맥-교환-context-switch">문맥 교환 (Context Switch)</h1>
<p>프로세스 A에서 프로세스 B로 실행 순서가 넘어가면 어떤 작업이 이루어져야 하는가?</p>
<ol>
  <li>기존에 실행되던 프로세스 A는 중간 정보를 백업
    <ul>
      <li>위의 PCB에 해당하는 정보</li>
      <li>이러한 정보를 <code class="language-plaintext highlighter-rouge">문맥 (Context)</code></li>
      <li>다음 차례에 실행을 재개하기 위한 정보</li>
    </ul>
  </li>
  <li>뒤이어 실행할 프로세스 B의 문맥을 복구
    <blockquote>
      <p>이처럼 기존에 실행 중인 프로세스의 문맥을 백업하고, 새로운 프로세스의 문맥을 복구하는 과정을 <code class="language-plaintext highlighter-rouge">문맥 교환</code>이라고 한다.</p>
      <ul>
        <li>여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리</li>
      </ul>
    </blockquote>
  </li>
</ol>

<h1 id="프로세스의-메모리-영역">프로세스의 메모리 영역</h1>
<blockquote>
  <p>코드 / 데이터 / 힙 / 스택</p>
</blockquote>

<h2 id="코드-영역-텍스트-영역">코드 영역 (텍스트 영역)</h2>
<ul>
  <li>기계어로 이루어진 명령어가 저장된 영역</li>
  <li>CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역 (Read-Only)
    <h2 id="데이터-영역">데이터 영역</h2>
  </li>
  <li>프로그램이 실행되는 동안 유지할 데이터를 저장</li>
  <li>지역 변수 / 정적 변수</li>
</ul>

<blockquote>
  <p>위의 두 영역은 크기가 변형되지 않으므로 <code class="language-plaintext highlighter-rouge">정적 할당 영역</code>이라고도 한다.</p>
</blockquote>

<h2 id="힙-영역">힙 영역</h2>
<ul>
  <li>사용자가 직접 할당할 수 있는 공간</li>
  <li>직접 할당하고 해제해야 함 / 최근 언어들은 G.C가 있어서 알아서 해줌 / 안하면 메모리 누수 (leak) 발생</li>
</ul>

<h2 id="스택-영역">스택 영역</h2>
<ul>
  <li>데이터가 일시적으로 저장되는 공간</li>
  <li>매개 변수 / 지역 변수</li>
</ul>

<blockquote>
  <p>위의 두 영역은 크기가 변형될 수 있으므로 <code class="language-plaintext highlighter-rouge">동적 할당 영역</code>이라고도 한다.</p>
</blockquote>

<blockquote>
  <p>힙 영역은 낮은 주소 -&gt; 높은 주소로 할당 <br />
스택 영역은 높은 주소 -&gt; 낮은 주소로 할당 <br />
동적 할당 영역이므로 둘이 반대되는 방향으로 할당 됨</p>
</blockquote>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><summary type="html"><![CDATA[프로세스란? 실행되기 전 데이터 덩어리 -&gt; 프로그램 실행되어서 메모리에 적재된 것 -&gt; 프로세스]]></summary></entry><entry><title type="html">99클럽 코테 스터디 40일차 TIL - 738 Monotone Increasing Digits</title><link href="https://sho1007.github.io/leetcode/738/" rel="alternate" type="text/html" title="99클럽 코테 스터디 40일차 TIL - 738 Monotone Increasing Digits" /><published>2024-06-28T00:00:00+00:00</published><updated>2024-06-28T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/738</id><content type="html" xml:base="https://sho1007.github.io/leetcode/738/"><![CDATA[<h1 id="738-monotone-increasing-digits--c--medium--18분">738. Monotone Increasing Digits / c++ / Medium / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<h3 id="문제-링크"><a href="https://leetcode.com/problems/monotone-increasing-digits/description/">문제 링크</a></h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">CheckMID</span><span class="p">(</span><span class="n">string</span> <span class="n">current</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">monotoneIncreasingDigits</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">current</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="c1">// n보다 작거나 같은 증가하는 수 (붙어있는 두 자리 ij가 i&lt;=j인 수)를 구하시오</span>
        <span class="c1">// 만약 n이 증가하는 수면? return</span>
        <span class="c1">// 만약 n이 증가하는 수가 아니라면? 감소 -&gt; 어떻게?</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">CheckMID</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'9'</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// cout &lt;&lt; current &lt;&lt; '\n';</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">stoi</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그리디">그리디</h3>
<ol>
  <li>n보다 작거나 같은 <strong>단조롭게 증가하는 수</strong> 중 가장 큰 수를 반환하는 문제였다.</li>
  <li>저 <strong>단조롭게 증가하는 수</strong> 가 뭔지 와닿질 않아서 검색해보니 인접한 두 자리의 수를 ij라고 할 때, (i &lt;= j) 를 만족하는 수였다. (즉, 이전자리가 다음자리 보다 작거나 같아야 한다.)</li>
  <li>큰 흐름을 봤을 때, 일단 n이 단조롭게 증가하는 수 (줄여서 MID 라고 부르겠다.) 라면 그대로 n을 반환한다.</li>
  <li>n이 MID가 아니라면 n보다 작은 MID 중 가장 큰 수를 반환하면 된다고 생각했다.</li>
  <li>그러면 우선 MID인지를 판단하는 식이 필요했고, 임의의 숫자 current의 각자리를 돌면서 현재 자리가 다음 자리보다 크면 false, 모든 자리가 다음 자리보다 작거나 같으면 true를 반환하는 CheckMID를 만들었다. (그리고 각 자리의 비교를 편하게 하기 위해 string current = to_string(n) 를 사용했다.)</li>
  <li>n이 MID라면 그대로 n을 반환</li>
  <li>이제 n이 MID가 아닐 때, n보다 작은 수 중 가장 큰 MID를 찾는 규칙이 필요했다.</li>
  <li>이럴 땐, 임의의 수들이 변화는 과정을 보는게 효율적이라고 생각했다. 우선 예제에 있는 수 중 1234는 이미 MID이므로 이걸 1243으로 바꿔봤다. 그러면 답은 1239가 나온다. 그리고 10을 넣으면 9가 답으로 나온다. 여기서 찾은 규칙은 MID가 아니라면, i &lt;= j 가 아닌 부분이 9로 바뀐다는 점이었다.</li>
  <li>current[i] &gt; current[j] 이면, MID를 만들기 위해 current[i]가 1 감소해야하는데, 이 때, 결과값 current가 MID 중 가장 큰 수가 되려면 다음 자리인 current[j]는 9가 되어야했다.</li>
  <li>여기서 어느정도 결과를 찾았고, current를 끝 (가장 작은 자리)부터 순회하면서, MID를 만족하지 않는 부분에서 current[i]는 1을 감소시키고, current[i+1] 은 9로 만들어줬다. 그러면 i가 한칸씩 앞으로 가면서 모든 자리의 MID를 맞추게 된다고 생각했다.</li>
  <li>그리고 나서 엣지 케이스를 체크하기 위해 n의 범위의 양 끝 값인 0과 1’000’000’000을 TestCase에 넣어봤다.</li>
  <li>0의 경우 값이 잘 나왔지만, 1’000’000’000의 경우 기대값은 999’999’999인데 결과값은 900’000’000이 나왔다.</li>
  <li>왜인지 원인을 찾아보니, MID를 만족하지 않는 부분에서 current[i]는 1 감소, current[i+1]은 9로 만들어줬지만, i + 2, i + 3, … , current.length() - 1 까지의 값은 그대로였던 것이 문제였다.</li>
  <li>즉, 앞으로는 연쇄가 일어났지만, 뒤로는 연쇄가 일어나지 않았다. (1’111은 999가 되지만, 1’000은 900이 되어버림)</li>
  <li>그래서 새로운 규칙을 추가해줬다. MID를 만족하지 않는 부분이 생기면 그 뒤의 값을 다 9로 만들어줬다.</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>다시 생각해보니 monotoneIncreasingDigits 함수에서 for문을 돌때, 변환이 일어나지 않았다면 n이 이미 MID이므로 CheckMID함수는 만들 필요가 없었다.</li>
  <li>항상 엣지케이스를 많이 놓쳤었는데, 이번에 스스로 엣지케이스 검사를 통해 새로운 규칙을 찾아서 문제를 해결하는 경험을 했다.</li>
  <li>어느덧 40일이라는 시간이 지났고 99클럽 2기도 마무리되었다. 정말 어떻게 흘러갔는지 모를 시간이었고, 만약 99클럽을 신청하지 않았다면 분명 나는 이렇게 열심히 코테 준비와 TIL 작성을 하지 않았을 것이라고 생각한다.</li>
  <li>99클럽 덕분에 꾸준히 하루에 1문제씩 풀 수 있었고, TIL을 적으면서 내가 풀었던 문제를 돌아보고 다시 정리할 수 있었다.</li>
  <li>난 99클럽을 진행하면서 꾸준히 하는 습관과 코딩 테스트 능력을 기를 수 있었고, 다음 99 클럽 3기가 시작된다면 또 신청할 생각이다.</li>
  <li>주변에도 간증처럼 내 얘기를 하면서 99클럽을 신청하라고 하는데, 생각보다 사람들은 잘 참여를 안한다. (효과 좋은데..)</li>
  <li>99클럽을 만들어주신 팀 스파르타와 40일동안 관리해주신 매니저님들, 클럽장님들 정말 수고 많으셨습니다. 제가 비록 기타언어인 C++이고, 문제를 푸는 시간이 오후 10시 이후라 문제 풀이 세션을 참석 못(안)할 때가 더 많았지만 그래도 항상 문제 출제해주시고 관리해주신 덕분에 완주할 수 있었습니다. 이 글을 보실진 모르겠지만 다시 한번 감사하다는 말씀 드리고 싶습니다.</li>
  <li>언젠가 C++도 정규 언어가 되는 날을 기대하며 이만 99클럽 2기 마지막 TIL을 마친다.</li>
</ol>

<h2 id="학습-기록">학습 기록</h2>
<p><img src="/assets/images/240628.png" alt="99클럽 2기 학습 기록" /></p>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Greedy" /><summary type="html"><![CDATA[738. Monotone Increasing Digits / c++ / Medium / 18분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 39일차 TIL - 2662 Minimum Cost of a Path With Special Roads</title><link href="https://sho1007.github.io/leetcode/2662/" rel="alternate" type="text/html" title="99클럽 코테 스터디 39일차 TIL - 2662 Minimum Cost of a Path With Special Roads" /><published>2024-06-27T00:00:00+00:00</published><updated>2024-06-27T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2662</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2662/"><![CDATA[<h1 id="2662-minimum-cost-of-a-path-with-special-roads--c--medium--2시간">2662. Minimum Cost of a Path With Special Roads / c++ / Medium / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">GetCost</span><span class="p">(</span><span class="kt">int</span> <span class="n">startX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startY</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetY</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">startX</span> <span class="o">-</span> <span class="n">targetX</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">startY</span> <span class="o">-</span> <span class="n">targetY</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minimumCost</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">specialRoads</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">specialRoads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">specialRoads</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
        <span class="n">set</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Set</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetCost</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>
            <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">});</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">Set</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>

            <span class="n">Set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cost</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">nextCost</span> <span class="o">=</span> <span class="n">GetCost</span><span class="p">(</span><span class="n">specialRoads</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nextCost</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextCost</span><span class="p">;</span>
                    <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">nextCost</span><span class="p">,</span> <span class="n">i</span><span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">GetCost</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            
            <span class="n">answer</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">GetCost</span><span class="p">(</span><span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">specialRoads</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="다익스트라--set">다익스트라 / Set</h3>
<ol>
  <li>fromX, fromY 지점부터 toX, toY 까지의 거리가 abs(fromX - toX) + abs(fromY - toY) 이고, 특정 fromPostion, toPosition, cost들 가지는 specialRoad가 있을 때, startX,startY 로부터 targetX, targetY 까지의 최단 거리를 구하는 문제</li>
  <li>처음 생각한 방식은 start부터 target까지의 거리를 구할 때, specialRoad 를 순회하면서 임의의 원소를 road를 사용한다고 가정하고, start로부터 road의 시작점까지의 거리 + road 자체의 비용 + raod 끝점부터 target까지의 거리로 나눠서 최소값을 갱신하고, 다시 (start부터 road의 시작점까지)와 (road의 끝점부터 target까지)를 재귀적으로 2번 로직을 호출하면 되지 않을까? 였다.</li>
  <li>하지만 이렇게 작성하니 stack overflow가 떴다. 역시나 재귀는 깊이가 깊어지면 사용이 불가능했다.</li>
  <li>방법을 찾지 못해서 다른 사람들의 접근 방법을 봤다.</li>
  <li>다익스트라를 써서 계속 비용을 최소로 갱신을 하신 식이었다.</li>
  <li>생각해보니 노드에서 노드로 이동할 때 cost가 드는건 다익스트라를 쓸 생각을 했었는데, 이렇게 좌표값으로 주어질 때에는 다익스트라를 써볼 생각을 못했었다. (Cost 구하는 공식이 떡하니 있는데도..)</li>
  <li>start부터 specialRoads[i]의 끝지점까지의 최소 비용을 저장하는 배열 dp[i]를 선언하고, 우선 기본 비용으로 갱신해준 다음 Set에 넣어준다.. (거리차 공식으로 측정한 비용, 이제는 PQ대신 Set을 활용하는 것으로 바꿨다.)</li>
  <li>다음 Set이 빌 때까지 반복
    <ol>
      <li>Set의 가장 앞 원소 ([0]번 원소를 비용으로 뒀기 때문에, 비용이 가장 적은 원소)를 꺼낸다. 그 후 Set에서 지운다. (PQ.top(), PQ.pop()과 동일)</li>
      <li>원소를 가지고 cost와 pos로 나눠서 저장</li>
      <li>dp[pos]가 cost가 아니라면 continue (이전 문제에서도 PQ에 원소가 새롭게 갱신됐을 때의 문제를 Set의 erase로 해결했었는데, 여기서는 항상 갱신된 최소값이 dp[i]에 저장되어 있기 때문에 이것을 활용했다.)</li>
      <li>다음 specialRoads를 순회하면서, 현재 speicalRoads[pos]의 끝지점부터 specialRoads[i]의 시작지점까지의 비용 + specialRoads[i]의 비용 + cost 를 계산해서 만약 그게 dp[i]보다 작다면, dp[i]를 갱신하고, {dp[i], i} 를 다시 Set에 넣어준다. (다익스트라에서 경로를 갱신하고 갱신된 노드를 다시 PQ에 넣어주는 것과 동일)</li>
    </ol>
  </li>
  <li>8번을 마치고 나면, dp[i]에는 speicalRoads[i]를 사용했을 때의 최소 비용이 저장된다.</li>
  <li>그럼 다시 dp를 순회하면서 dp[i] + speicalRoads[i]의 끝지점에서 target까지의 비용을 계산해서 그 중 최소값으로 answer를 갱신해준다.</li>
  <li>answer를 반환, 해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>index만 존재하는 node가 아니라 좌표값으로 다익스트라를 적용해 볼 수 있는 좋은 경험이었다. (물론 스스로 생각해내지는 못했지만)</li>
  <li>dp가 항상 약했었는데, 거기에 Heap까지 더해지니까 정신을 못차리고 풀이 방법을 빨리 파악해내지 못했었다. Heap 쪽을 좀 더 많이 풀어봐야겠다.</li>
  <li>이제 내일이면 99클럽 2기가 끝나게 된다. 99클럽을 진행하면서 꾸준히 하루에 한문제씩을 풀 수 있었고, 덕분에 최근에 코테를 볼 일이 많았는데 불안함 없이 편하게 볼 수 있었던 것 같다. 99클럽 3기가 시작되면 또 신청해야겠다. (코테는 항상 준비하고 취미처럼 꾸준히 풀어야 실력이 녹슬지 않고 계속 발전할 수 있는 것 같다.)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Heap" /><summary type="html"><![CDATA[2662. Minimum Cost of a Path With Special Roads / c++ / Medium / 2시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 38일차 TIL - 3112 Minimum Time to Visit Disappearing Nodes</title><link href="https://sho1007.github.io/leetcode/3112/" rel="alternate" type="text/html" title="99클럽 코테 스터디 38일차 TIL - 3112 Minimum Time to Visit Disappearing Nodes" /><published>2024-06-26T00:00:00+00:00</published><updated>2024-06-26T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/3112</id><content type="html" xml:base="https://sho1007.github.io/leetcode/3112/"><![CDATA[<h1 id="3112-minimum-time-to-visit-disappearing-nodes--c--medium--1시간">3112. Minimum Time to Visit Disappearing Nodes / c++ / Medium / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minimumTime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">disappear</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">adjVector</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">adjVector</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">({</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]});</span>
            <span class="n">adjVector</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]].</span><span class="n">push_back</span><span class="p">({</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]});</span>
        <span class="p">}</span>

        <span class="n">set</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Set</span><span class="p">;</span>
        <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">});</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">Set</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">Iter</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Current</span> <span class="o">=</span> <span class="o">*</span><span class="n">Iter</span><span class="p">;</span>
            <span class="n">Set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Iter</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Iter</span> <span class="o">:</span> <span class="n">adjVector</span><span class="p">[</span><span class="n">Current</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">nextPos</span> <span class="o">=</span> <span class="n">Iter</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">nextTime</span> <span class="o">=</span> <span class="n">Current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Iter</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nextTime</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="n">disappear</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nextTime</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">EraseTarget</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">],</span> <span class="n">nextPos</span><span class="p">});</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">EraseTarget</span> <span class="o">!=</span> <span class="n">Set</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="n">Set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">EraseTarget</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="n">answer</span><span class="p">[</span><span class="n">nextPos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextTime</span><span class="p">;</span>
                    <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">nextTime</span><span class="p">,</span> <span class="n">nextPos</span><span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프--다익스트라--set">그래프 / 다익스트라 / Set</h3>
<ol>
  <li>0부터 모든 노드까지의 최소 거리를 봤을 때 바로 다익스트라가 떠올랐다.</li>
  <li>이 문제엔 한가지 추가 조건이 있었는데, disappear[i]일 때, 해당 노드가 사라진다는 것이었다.</li>
  <li>그래서 다익스트라를 갱신할 때 nextTime &lt; disappear[nextPos] 조건을 추가해줬다. (다음 노드까지의 시간이 다음 노드가 사라질 시간보다 작을 때)</li>
  <li>n의 최대개수인 50000일 때 시간 초과가 났다.</li>
  <li>그래서 보통 다익스트라를 사용할 때는 큐를 활용했었는데, 가장 거리가 짧은 노드를 먼저 갱신해야할 꺼같아서 우선순위 큐로 바꿔줬었다. 하지만 그래도 시간초과</li>
  <li>고민하다 1시간이 넘었고 다른 사람들의 접근방법을 참고했는데, 그 중에 Set을 활용한 풀이가 눈에 띄었다.</li>
  <li>항상 우선순위 큐를 쓸 때 고민했던 건데, 우선순위 큐에 이미 들어간 값이 새롭게 갱신됐을 때, 기존 값을 어떻게 삭제할지가 문제였다.</li>
  <li>그런데 Set을 쓰게 되면, 기존값을 검색해서 삭제할 수 있고, 이 문제의 경우 {다음 노드까지의 최소거리, 다음 노드의 번호} 처럼 원소가 2개인 벡터로 Set을 만들면, 알아서 벡터의 첫 번째 원소 기준으로 정렬을 해주기때문에 우선순위 큐를 사용한 것 같은 효과를 낼 수 있었다.</li>
  <li>그렇게 갱신되면 기존 값을 Set에서 제거해주며 진행했더니 통과되었다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>항상 고민했었던, 우선순위 큐에서 갱신되버린 원소의 기존값을 삭제하는 문제를 Set을 활용해서 해결하는 방법을 배웠다.</li>
  <li>그리고 원소 2개짜리인 컨테이너가 필요할 때 항상 pair를 썼었는데, vector를 써도 된다는 점을 새롭게 배웠다. (사실 당연히 둘 다 {1, 2} 이런식으로 선언할 수 있는건데, 이걸 왜 이제 깨달았을까..)</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Heap" /><summary type="html"><![CDATA[3112. Minimum Time to Visit Disappearing Nodes / c++ / Medium / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 37일차 TIL - 385 Mini Parser</title><link href="https://sho1007.github.io/leetcode/385/" rel="alternate" type="text/html" title="99클럽 코테 스터디 37일차 TIL - 385 Mini Parser" /><published>2024-06-25T00:00:00+00:00</published><updated>2024-06-25T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/385</id><content type="html" xml:base="https://sho1007.github.io/leetcode/385/"><![CDATA[<h1 id="385-mini-parser--c--medium--2시간">385. Mini Parser / c++ / Medium / 2시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">NestedInteger</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'['</span><span class="p">)</span> <span class="k">return</span> <span class="n">NestedInteger</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

        <span class="n">NestedInteger</span> <span class="n">ni</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">current</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="s">""</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">ni</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">NestedInteger</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">current</span><span class="p">)));</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'['</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">bracketCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span><span class="sc">'['</span><span class="p">)</span> <span class="n">bracketCount</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span><span class="sc">']'</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bracketCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">ni</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">deserialize</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">current</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="s">""</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ni</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">NestedInteger</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">current</span><span class="p">)));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ni</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--스택">자료 구조 / 스택</h3>
<ol>
  <li>주어진 문자열을 NestedInteger라고 하는 자료형구조로 변환(복원)하는 문제였다.</li>
  <li>문자열이 ‘[‘로 시작하면 앞뒤의 ‘[‘와 ‘]’를 제거해준다.</li>
  <li>NestedInteger를 생성하고 문자열을 순회하면서 아래의 규칙으로 진행
    <ol>
      <li>’[‘을 만난다면, 괄호갯수를 카운트해주며 짝이 맞는 닫힌 괄호까지를 새롭게 deserialize에 넣어서 현재 NestedInteger에 add해준다. (그리고 i를 닫힌 괄호의 다음으로 이동)</li>
      <li>’,’를 만나면, 만약 current (integer로 바꿀 string)이 비어있지 않다면 NestedInteger로 만들어서 현재 NestedInteger에 추가해준다.</li>
      <li>위의 두 경우가 아니라면 숫자이므로 current에 추가해준다.</li>
    </ol>
  </li>
  <li>위의 방법으로 생성된 NestedInteger를 반환</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 자체는 재귀적으로 해결하면 쉬운 문제였지만, 이해를 잘못해서 시간을 엄청 잡아먹었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Stack" /><summary type="html"><![CDATA[385. Mini Parser / c++ / Medium / 2시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 36일차 TIL - 2434 Using a Robot to Print the Lexicographically Smallest String</title><link href="https://sho1007.github.io/leetcode/2434/" rel="alternate" type="text/html" title="99클럽 코테 스터디 36일차 TIL - 2434 Using a Robot to Print the Lexicographically Smallest String" /><published>2024-06-24T00:00:00+00:00</published><updated>2024-06-24T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2434</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2434/"><![CDATA[<h1 id="2434-using-a-robot-to-print-the-lexicographically-smallest-string--c--medium--1시간">2434. Using a Robot to Print the Lexicographically Smallest String / c++ / Medium / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">Stack</span><span class="p">;</span>
<span class="n">multiset</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ms</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">robotWithString</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="n">Stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Stack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
                <span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]));</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Stack</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">ms</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
                <span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]));</span>
            <span class="p">}</span>

            <span class="n">answer</span> <span class="o">+=</span> <span class="n">Stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">Stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="c1">// cout &lt;&lt; answer &lt;&lt; '\n';</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Stack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">Stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">Stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--스택">자료 구조 / 스택</h3>
<ol>
  <li>주어진 문자열 s와, 저장 공간 t를 활용하여 만들어질 수 있는 문자열 중, 사전적으로 가장 앞에 오는 문자열을 반환하는 문제</li>
  <li>답은 문제에 있었다. 1번 동작은 s의 가장 앞 문자를 t의 가장 뒤에 붙이는 것, 2번 동작은 t의 가장 뒤에 있는 문자를 종이 (여기선는 answer)에 추가하는 것이었다.</li>
  <li>2번에서 알 수 있듯이, t는 뒤에 추가되고, 뒤에서 제거된다. (LIFO) 즉, 스택 자료형이다.</li>
  <li>이를 토대로 로직을 재구성해보면</li>
  <li>우선 최소값을 알아야 하기 때문에 s의 모든 문자를 multiset인 ms에 넣는다.</li>
  <li>index가 n (s의 length)보다 작을 동안 아래를 반복</li>
  <li>만약 t가 비어있다면 s[index]를 t에 넣고, ms에서 s[index]를 제거해준 후 index 증가</li>
  <li>t.top()이 *ms.begin() (남은 문자열 중 가장 작은 문자) 보다 크다면, 계속 t에 넣는다.</li>
  <li>그러다 t.top()이 *ms.begin() 보다 작거나 같다면 (적지 않는 모든 문자 중 가장 작은 문자라면) answer에 적고 t에서 제거한다. (t.pop())</li>
  <li>결국 s의 모든 문자가 t에 들어가고 그 중 일부는 answer에 적힌 채로 반복이 종료된다.</li>
  <li>마지막으로 t가 빌 때까지, t에 들어있는 모든 문자를 answer에 추가해준다.</li>
  <li>answer를 반환</li>
  <li>해결</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>여러 방법을 생각하다 t의 구조가 stack과 유사하다고 생각했고, 남은 문자열의 최소 문자를 찾기 위해 multiset을 활용했다. 99클럽의 이전 문제에서 multiset을 활용했던 경험이 도움이 되었다.</li>
  <li>나름 어렵게 느껴진 문제였지만, stl을 활용하여 스스로 풀었다는 점에서 성취감을 느낄 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DataStructure" /><category term="Stack" /><summary type="html"><![CDATA[2434. Using a Robot to Print the Lexicographically Smallest String / c++ / Medium / 1시간+]]></summary></entry></feed>