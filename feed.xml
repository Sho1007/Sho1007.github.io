<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-06-02T08:30:51+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 14일차 TIL - 43163 단어 변환</title><link href="https://sho1007.github.io/programmers/43163/" rel="alternate" type="text/html" title="99클럽 코테 스터디 14일차 TIL - 43163 단어 변환" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43163</id><content type="html" xml:base="https://sho1007.github.io/programmers/43163/"><![CDATA[<h1 id="43163-단어-변환--c--level3--18분">43163. 단어 변환 / c++ / level3 / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43163.%E2%80%85%EB%8B%A8%EC%96%B4%E2%80%85%EB%B3%80%ED%99%98"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--dfs">그래프 탐색 / DFS</h3>
<ol>
  <li>두 단어가 하나의 문자만 다른 경우 해당 단어로 바꿀 수 있다면, 두 단어를 이어진 두 노드라고 볼 수 있다.</li>
  <li>단어를 순회하면서 해당 단어와 한 문자만 다른 단어를 찾아 unordered_map&lt;string, vector<string>&gt; adjMap 에 넣는다.</string></li>
  <li>이 때 주의할 점은, 시작 단어는 words에 포함되어 있지 않기 때문에, wordgs 순회 전 begin도 words에 넣어줘야 한다.</li>
  <li>그리고 DFS에 사용하기 위한 방문 기록용 unordered_map&lt;string, boo&gt; vistedMap을 선언하고, words를 순회할 때 모든 단어를 false로 초기화 해준다.</li>
  <li>adjMap 초기화가 끝나면 begin을 시작점으로 해서 DFS를 진행</li>
  <li>DFS의 매개변수인 vector<string>&amp; path 의 마지막 단어가 target일 경우 path.size() 가 answer 보다 작다면 answer 를 초기화 해준다. (이 때 사용한 answer는 미리 MAX값으로 초기화)</string></li>
  <li>DFS가 끝나고 answer 가 여전히 MAX이면 0을 반환, 아니라면 answer를 반환한다. (나는 DFS를 위해 path에 시작값으로 begin을 넣어놨었기 때문에, answer-1을 반환했다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>DFS를 사용하면 백트래킹을 활용하여 경로탐색이 용이하다는 점을 다시금 느낄 수 있었다.</li>
  <li>begin을 미리 words에 넣어서 순회를 돌리는 것이 좋았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="DFS" /><summary type="html"><![CDATA[43163. 단어 변환 / c++ / level3 / 18분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 13일차 TIL - 87964 아이템 줍기</title><link href="https://sho1007.github.io/programmers/87964/" rel="alternate" type="text/html" title="99클럽 코테 스터디 13일차 TIL - 87964 아이템 줍기" /><published>2024-06-01T00:00:00+00:00</published><updated>2024-06-01T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/87964</id><content type="html" xml:base="https://sho1007.github.io/programmers/87964/"><![CDATA[<h1 id="87964-아이템-줍기--c--level3--1시간">87964. 아이템 줍기 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs">그래프 탐색 / BFS</h3>
<ol>
  <li>점이 겹치는 뭉치는 문제를 해결하기 위해 사각형의 각 좌표를 * 2 해줌</li>
  <li>사각형을 돌면서 2차원 bool 배열 map에 테두리를 true 표시해줌</li>
  <li>다시 사각형을 돌면서 사각형 안쪽을 false로 바꿔줌</li>
  <li>해당 map을 기준으로 BFS 진행 (이 때, 시작 좌표도 각각 *2)</li>
  <li>마지막으로 item 좌표 * 2 한 위치의 비용값의 절반을 return</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>사각형들의 테두리를 잇는 부분은 크게 어렵지 않았다.</li>
  <li>그런데 좌표가 1단위로 나눠져서, 분명 이어져있지 않은 길인데도 bfs할 때 이어진 것처럼 작동하는 문제가 있었다.</li>
  <li>예전에 이걸 *2해서 (지도가 커지면 좌표가 더 세밀해지는 느낌) 해결했던 경험이 있었는데, 이걸 다시 생각해내기까지가 정말 오래 걸렸다.</li>
  <li>다음에는 지금처럼 좌표값을 더 세분화해야 할 때, * 2 하는 방법을 바로 기억해낼 수 있도록 해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[87964. 아이템 줍기 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 12일차 TIL - 43164 여행경로</title><link href="https://sho1007.github.io/programmers/43164/" rel="alternate" type="text/html" title="99클럽 코테 스터디 12일차 TIL - 43164 여행경로" /><published>2024-05-31T00:00:00+00:00</published><updated>2024-05-31T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43164</id><content type="html" xml:base="https://sho1007.github.io/programmers/43164/"><![CDATA[<h1 id="43164-여행경로--c--level3--1시간">43164. 여행경로 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43164.%E2%80%85%EC%97%AC%ED%96%89%EA%B2%BD%EB%A1%9C"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs--구현--백트래킹">그래프 탐색 / BFS / 구현 / 백트래킹</h3>
<ol>
  <li>우선 tickets 을 순회 하면서 인접리스트인 adjMap (unordered_map&lt;string,vector<string>&gt;) 을 준비</string></li>
  <li>여행 경로를 담을 vector<string> currentPath를 선언</string></li>
  <li>currentPath에 출발지인 ICN을 삽입</li>
  <li>adjMap에서 ICN을 출발지로 하는 인접리스트를 돌면서 백트래킹 시작</li>
  <li>currentPath.back (마지막 여행지) 를 출발점으로 하는 인접행렬을 순회하며 다시 백트래킹 반복</li>
  <li>백트래킹 도중 currentPath가 ticket + 1 (출발지인 ICN까지 포함하므로) 가 되면, vector<stirng> 인 answer와 비교하여, 사전순으로 앞서있는지 체크</stirng></li>
  <li>currentPath 가 answer 보다 사전순으로 앞서있다면 answer 갱신</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>공항의 수가 최대 10’000개였기 때문에 백트래킹 (재귀) 은 과하게 depth가 깊어지면 stack overflow 가 날 수 있다고 걱정했다.</li>
  <li>그래서 처음엔 백트래킹을 사용하지 않고 BFS를 써서 어떻게든 풀어보려고 온몸비틀기를 했는데, 출발지 + 도착지를 한 string으로 묶어서 순서를 매겼더니, 중복되는 티켓을 처리하지 못하는 문제가 생겼다.</li>
  <li>그래서 밑져야 본전이라고 백트래킹으로 풀어봤더니 너무 잘 풀리고, 시간도 2번에서 풀었던 것보다 1ms 더 빨랐다.</li>
  <li>항상 가장 간단한 방법부터 시도해봐야한다고 머리로는 알고 있는데, 시간 제한이 있다고 생각하면 그게 잘 안되는 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><category term="BackTracking" /><summary type="html"><![CDATA[43164. 여행경로 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 11일차 TIL - 84021 퍼즐 조각 채우기</title><link href="https://sho1007.github.io/programmers/84021/" rel="alternate" type="text/html" title="99클럽 코테 스터디 11일차 TIL - 84021 퍼즐 조각 채우기" /><published>2024-05-30T00:00:00+00:00</published><updated>2024-05-30T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/84021</id><content type="html" xml:base="https://sho1007.github.io/programmers/84021/"><![CDATA[<h1 id="84021-퍼즐-조각-채우기--c--level3--1시간">84021. 퍼즐 조각 채우기 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/84021.%E2%80%85%ED%8D%BC%EC%A6%90%E2%80%85%EC%A1%B0%EA%B0%81%E2%80%85%EC%B1%84%EC%9A%B0%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs--구현">그래프 탐색 / BFS / 구현</h3>
<ol>
  <li>먼저 table 에서 블록(위치값의 벡터)들을 BFS 로 구한다.</li>
  <li>table을 탐색할 때, 좌상단부터 우하단 방향으로 탐색하기에, 블록의 첫 번째 부분은 항상 가장 위에 있고, 그 중 가장 왼쪽에 위치한다.</li>
  <li>구한 블록을 첫 번째 부분 기준으로 다시 표현한다. (모든 칸에서 첫 번째 칸의 위치를 빼주면 됨, 이 때 첫 번째 부분이 1에서 설명한 것처럼 가장 작으므로 모든 값은 양수로 표시됨)</li>
  <li>블록을 총 3번 회전시켜서 4개의 형태를 모두 구한다. (이 때는 블록의 x,y 좌표를 바꾸고, y 좌표에 -1을 곱해줌)</li>
  <li>해당 블록들을 다시 정렬한다. (4번으로 인해 정렬이 틀어졌기 때문)</li>
  <li>블록 구하기가 끝나면 이제 board에서 빈칸을 찾는다. (블록과 마찬가지로 위치값의 벡터로 구함)</li>
  <li>빈칸이 구해지면, 3번에서처럼 빈칸을 첫 번째 부분을 기준으로 다시 표현한다.</li>
  <li>그 후 빈칸을 정렬한다.</li>
  <li>정렬된 빈칸을 블록 벡터를 순회하면서 맞는 블록이 있는지 찾는다. (이 때, usedBlock 이라는 bool 벡터를 하나 선언해서 블록의 재사용을 막는다. 또한 한 블록은 4개의 회전 형태를 모두 고려한다.)
    <ol>
      <li>맞는 블록이 있다면, usedBlock 에 해당 블록을 체크해주고, 블록의 칸 갯수를 answer에 더한다.</li>
      <li>맞는 블록이 없다면, BFS에서 사용한 방문 정보를 초기화시킨다. (해당 빈칸을 다른 부분에서 다시 찾기 위함)</li>
    </ol>
  </li>
  <li>위의 과정으로 board를 모두 탐색하면 answer를 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이미 풀어봤던 문제임에도 시간이 꽤 걸렸다. 틀을 잡는건 금방 했는데, 블록을 탐색한 후 정렬을 언제 해줘야하는지가 많이 헷갈렸다. 문제를 정확하게 먼저 분석하고 풀었어야했는데, 또 바로 푸는 습관이 나와서 더 오래 걸렸던 것 같다.</li>
  <li>게더타운에서 풀기 위해 밤 늦게 풀었더니 졸려서 머리가 더 안돌아갔던 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[84021. 퍼즐 조각 채우기 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 10일차 TIL - 86971 전력망을 둘로 나누기</title><link href="https://sho1007.github.io/programmers/86971/" rel="alternate" type="text/html" title="99클럽 코테 스터디 10일차 TIL - 86971 전력망을 둘로 나누기" /><published>2024-05-29T00:00:00+00:00</published><updated>2024-05-29T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/86971</id><content type="html" xml:base="https://sho1007.github.io/programmers/86971/"><![CDATA[<h1 id="86971-전력망을-둘로-나누기--c--level2--18분">86971. 전력망을 둘로 나누기 / c++ / level2 / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/86971.%E2%80%85%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84%E2%80%85%EB%91%98%EB%A1%9C%E2%80%85%EB%82%98%EB%88%84%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="완전-탐색">완전 탐색</h3>
<ol>
  <li>노드가 100개이므로 인접행렬을 만들어도 100 * 100 개, 메모리 크기는 40KB(정수의 경우)가 되므로 충분했다.</li>
  <li>wires를 돌면서 두 노드를 모두 연결해줬다. (양방향 그래프)</li>
  <li>다시 wires를 돌면서, 이번엔 두 노드를 모두 끊어준 뒤, 각 노드를 시작점으로 하여 DFS를 계산해줬다.</li>
  <li>그렇게 나온 두 수 (두 전력망이 가지고 있는 송전탑의 개수)를 뺀 값의 절대값을 미리 최대값 (101)개를 취한 answer와 비교하여 더 작다면 answer를 갱신해줬다.</li>
  <li>answer를 반환</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>DFS를 맨 처음 시작할 때, 나눠진 두 노드의 방문 처리를 안해줬더니 테스트 케이스 1번이 틀렸었다. 사소해서 놓치기 쉬운 부분이므로 다음부터는 꼭 집고 넘어가야겠다.</li>
  <li>인접행렬에 비용이 들어가는게 아니라 연결 되어있는지 여부가 들어가므로 bool로 선언했다면 메모리를 아낄 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Brute Force" /><summary type="html"><![CDATA[86971. 전력망을 둘로 나누기 / c++ / level2 / 18분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 9일차 TIL - 84512 모음 사전</title><link href="https://sho1007.github.io/programmers/84512/" rel="alternate" type="text/html" title="99클럽 코테 스터디 9일차 TIL - 84512 모음 사전" /><published>2024-05-28T00:00:00+00:00</published><updated>2024-05-28T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/84512</id><content type="html" xml:base="https://sho1007.github.io/programmers/84512/"><![CDATA[<h1 id="84512-모음-사전--c--level2--8분">84512. 모음 사전 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/84512.%E2%80%85%EB%AA%A8%EC%9D%8C%E2%80%85%EC%82%AC%EC%A0%84"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="완전-탐색">완전 탐색</h3>
<ol>
  <li>빈 문자열 “” 부터 시작해서 큐에 집어넣는다.</li>
  <li>큐가 빌 때까지 아래를 반복</li>
  <li>큐에서 하나를 꺼내서 만약 길이가 5라면, 더 이상 추가할 수 없으므로 continue</li>
  <li>for 문을 돌면서 현재 문자열에 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’ 를 추가한다.</li>
  <li>해당 문자를 다시 큐에 넣고, 벡터에도 넣는다.</li>
  <li>위의 과정을 마친 뒤, 벡터를 정렬하고, word가 벡터에서 몇 번째에 위치하는지 찾아서 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>완전 탐색이라는 키워드를 알고 풀다보니, 쉽게 풀 수 있었다. (그냥 다 해보면 되니까)</li>
  <li>오히려 미들러 문제가 시간이 좀 더 걸렸다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Brute Force" /><summary type="html"><![CDATA[84512. 모음 사전 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 8일차 TIL - 899 Orderly Queue</title><link href="https://sho1007.github.io/leetcode/899/" rel="alternate" type="text/html" title="99클럽 코테 스터디 8일차 TIL - 899 Orderly Queue" /><published>2024-05-27T00:00:00+00:00</published><updated>2024-05-27T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/899</id><content type="html" xml:base="https://sho1007.github.io/leetcode/899/"><![CDATA[<h1 id="899-orderly-queue--c--hard--30분">899. Orderly Queue / c++ / Hard / 30분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Cmp</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">char</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">orderlyQueue</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">Answer</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">Answer</span><span class="p">)</span> <span class="n">Answer</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">sort</span><span class="p">(</span><span class="n">Answer</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Answer</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">Answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>처음엔 단순 정렬인 줄 알았는데, k가 1인 경우엔 정렬할 수 없이 계속 순환할 뿐이었다.</li>
  <li>그래서 Answer를 s로 초기화 해주고 k가 1인 경우와 아닌 경우로 나눈 뒤
    <ol>
      <li>k가 1이면 s.size() - 1 번 만큼 (한번 더 돌면 원래 상태이므로 -1 해줌) 돌면서 맨 앞 글자를 맨 뒤로 보내준다. 그 후 Answer 보다 작다면 Answer 갱신</li>
      <li>k가 2 이상이면 단순히 Answer를 정렬해준다.</li>
    </ol>
  </li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>리트코드 문제는 단순히 구현하는게 아니라 해당 문제의 본질을 찾는 것이 다른 곳들보다 더 중요하다고 느꼈다.</li>
  <li>앞에서 2개 중 하나만 골라 뒤로 보낼 수 있더라도 정렬이 가능하다는 것을 다시금 깨달았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[899. Orderly Queue / c++ / Hard / 30분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 7일차 TIL - 2551 Put Marbles in Bags</title><link href="https://sho1007.github.io/leetcode/2551/" rel="alternate" type="text/html" title="99클럽 코테 스터디 7일차 TIL - 2551 Put Marbles in Bags" /><published>2024-05-26T00:00:00+00:00</published><updated>2024-05-26T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2551</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2551/"><![CDATA[<h1 id="2551-put-marbles-in-bags--c--hard--1시간">2551. Put Marbles in Bags / c++ / Hard / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">costVector</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">putMarbles</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">costVector</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">costVector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">costVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costVector</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">maxCost</span> <span class="o">+=</span> <span class="n">costVector</span><span class="p">[</span><span class="n">costVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">minCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">minCost</span> <span class="o">+=</span> <span class="n">costVector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">maxCost</span> <span class="o">-</span> <span class="n">minCost</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>가장 단순하게 모든 구간을 잘라봤다. (전수조사, 백트래킹) -&gt; 시간 초과</li>
  <li>시간을 단축할 수 있는 방법을 찾아보려 했지만 결국 찾지 못했고, 힌트를 봤다.</li>
  <li>힌트에서 나눠지는 부분의 앞과 뒤를 사용해라고 나와 있었다.</li>
  <li>pair&lt;int,int&gt; 를 원소로 가지는 우선순위 큐를 선언하여 끊어질 수 있는 부분을 모두 넣었다.</li>
  <li>이러면 크거나 작은 한가지의 기준으로 정렬된 값을 꺼낼 수 있지만 여기선 최소값과 최대값 두가지의 기준이 필요했고, 기존 방법으로는 정렬의 반대 순서로 꺼내는게 번거로웠다.</li>
  <li>다시 생각해보니 굳이 우선순위 큐를 쓰지 않고, 벡터에 다 넣은 다음 정렬하면 앞뒤로 꺼낼 수 있었다.</li>
  <li>다른 분들의 풀이를 보니 또 굳이 pair&lt;int,int&gt; 로 나눠지는 부분을 받지 않고, 어차피 더해질 거 그냥 int 로 처음부터 더한 값을 원소로 받으면 된다는 점을 깨달았다.</li>
  <li>마지막으로 항상 maxSum - minSum을 반환하기 때문에, 맨 앞과 맨 뒤 원소는 maxSum과 minSum에 모두 포함되어 결국 상쇄되는 값이었다.</li>
  <li>이런 최적화 과정을 통해 최종 식이 (내림차순 정렬의 k-1개의 원소의 합) - (오름차순 정렬의 k-1개의 원소의 합) 이라는 점을 깨달았다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>리트코드는 힌트와 풀이 방법을 제공해준다는 점이 신기했다.</li>
  <li>힌트도 단계별로 나눠져 있어서 하다가 도저히 안되겠을 때 차례로 한 개씩 열어볼 수 있다는 점이 좋았다.</li>
  <li>이해하고 나니 단순 정렬 문제였는데, 풀이 과정을 유추해 내는 것이 너무 어려웠다.</li>
  <li>마치 구현 방법을 식으로 나타내고 그 식을 최적화하여 최종 계산식을 뽑아내는 느낌이었다.</li>
  <li>내가 부족한 부분이 문제 전체를 도식화하여 해결하는 능력이라는 것을 다시 한번 깨달을 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[2551. Put Marbles in Bags / c++ / Hard / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 6일차 TIL - 42628 이중우선순위큐</title><link href="https://sho1007.github.io/programmers/42628/" rel="alternate" type="text/html" title="99클럽 코테 스터디 6일차 TIL - 42628 이중우선순위큐" /><published>2024-05-25T00:00:00+00:00</published><updated>2024-05-25T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42628</id><content type="html" xml:base="https://sho1007.github.io/programmers/42628/"><![CDATA[<h1 id="42628-이중우선순위큐--c--level3--32분">42628. 이중우선순위큐 / c++ / level3 / 32분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42628.%E2%80%85%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="구현--자료구조--힙--셋-set">구현 / 자료구조 / 힙 / 셋 (Set)</h3>
<ol>
  <li>해당 요구사항에 맞게 자료구조를 구현하면 되는 문제였다.</li>
  <li>multiset을 사용해서 혹시 모를 중복에 대비하며, 자료를 입력과 동시에 정렬해줬다.</li>
  <li>D 1 의 경우 최대값을 삭제해야하므로 set 의 마지막 원소를 erase 해줬다.</li>
  <li>D -1 의 경우 최소값을 삭제해야하므로 set의 첫번째 원소를 erase 해줬다.</li>
  <li>마지막으로 set이 비어있는 경우 0,0을, set의 원소가 1개인 경우 해당 원소를 두번 출력해줬다.</li>
  <li>set의 원소가 2개 이상인 경우 set 의 begin 과 end -1 을 출력해줬다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>자료구조에 대한 이해가 있다면 set 혹은 priority_queue 등을 사용해서 쉽게 풀 수 있는 문제였던 것 같다.</li>
  <li>지금 와서 생각해보니 출력을 set의 원소가 0 / 1 / 2 이상 인 3가지로 잡지 않고 set이 비어있거나, 비어있지 않은 2가지 경우로 잡아도 충분히 출력이 가능한 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Heap" /><summary type="html"><![CDATA[42628. 이중우선순위큐 / c++ / level3 / 32분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 5일차 TIL - 42627 디스크 컨트롤러</title><link href="https://sho1007.github.io/programmers/42627/" rel="alternate" type="text/html" title="99클럽 코테 스터디 5일차 TIL - 42627 디스크 컨트롤러" /><published>2024-05-24T00:00:00+00:00</published><updated>2024-05-24T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42627</id><content type="html" xml:base="https://sho1007.github.io/programmers/42627/"><![CDATA[<h1 id="42627-디스크-컨트롤러--c--level3--1시간">42627. 디스크 컨트롤러 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42627.%E2%80%85%EB%94%94%EC%8A%A4%ED%81%AC%E2%80%85%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--힙--우선순위-큐">자료구조 / 힙 / 우선순위 큐</h3>
<ol>
  <li>문제 자체는 단순했다.</li>
  <li>현재 처리할 수 있는 일들 중 가장 짧은 일을 처리한다.</li>
  <li>모든 일을 처리할 때까지 반복</li>
  <li>이 때, 일을 짧은 순서로 정리하기 위해서 우선순위 큐를 사용했다.</li>
  <li>하지만 간과한 것이 2가지 있었다.
    <ol>
      <li>매번 일을 하나 처리할 때마다, 현재 시간이 증가하기 때문에, 새로운 일들이 들어온다. 이를 놓쳐서 큐에 있는 모든 일을 처리한 뒤 새로운 일들을 큐에 받아들였더니 틀린 답이 나왔었다.</li>
      <li>첫 일을 정할때도 가장 짧은 일을 골라야 한다. jobs 벡터가 정렬되어 있지 않을 것이라고 생각해서 정렬을 했었지만, 단순 시작 시간으로만 정렬을 했었다. 그랬더니 아마 첫 일을 가장 빠른 일이지만 가장 짧은 일을 고르지 못해서 틀렸던 것 같다.</li>
    </ol>
  </li>
  <li>위의 두가지 문제를 해결했더니 정답을 맞출 수 있었다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 자체는 굉장히 단순하다고 생각했는데, 엣지 케이스를 찾는데 너무 많은 시간을 허비했다.</li>
  <li>다음부터 이렇게 뭔가 놓치는 부분이 보이면 수도코드로 어느정도 정리해서 엣지 케이스를 잡을 수 있도록 해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Heap" /><summary type="html"><![CDATA[42627. 디스크 컨트롤러 / c++ / level3 / 1시간+]]></summary></entry></feed>