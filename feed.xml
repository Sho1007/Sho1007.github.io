<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-05-29T03:01:04+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 10일차 TIL - 86971 전력망을 둘로 나누기</title><link href="https://sho1007.github.io/programmers/86971/" rel="alternate" type="text/html" title="99클럽 코테 스터디 10일차 TIL - 86971 전력망을 둘로 나누기" /><published>2024-05-29T00:00:00+00:00</published><updated>2024-05-29T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/86971</id><content type="html" xml:base="https://sho1007.github.io/programmers/86971/"><![CDATA[<h1 id="86971-전력망을-둘로-나누기--c--level2--18분">86971. 전력망을 둘로 나누기 / c++ / level2 / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/86971.%E2%80%85%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84%E2%80%85%EB%91%98%EB%A1%9C%E2%80%85%EB%82%98%EB%88%84%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="완전-탐색">완전 탐색</h3>
<ol>
  <li>노드가 100개이므로 인접행렬을 만들어도 100 * 100 개, 메모리 크기는 40KB(정수의 경우)가 되므로 충분했다.</li>
  <li>wires를 돌면서 두 노드를 모두 연결해줬다. (양방향 그래프)</li>
  <li>다시 wires를 돌면서, 이번엔 두 노드를 모두 끊어준 뒤, 각 노드를 시작점으로 하여 DFS를 계산해줬다.</li>
  <li>그렇게 나온 두 수 (두 전력망이 가지고 있는 송전탑의 개수)를 뺀 값의 절대값을 미리 최대값 (101)개를 취한 answer와 비교하여 더 작다면 answer를 갱신해줬다.</li>
  <li>answer를 반환</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>DFS를 맨 처음 시작할 때, 나눠진 두 노드의 방문 처리를 안해줬더니 테스트 케이스 1번이 틀렸었다. 사소해서 놓치기 쉬운 부분이므로 다음부터는 꼭 집고 넘어가야겠다.</li>
  <li>인접행렬에 비용이 들어가는게 아니라 연결 되어있는지 여부가 들어가므로 bool로 선언했다면 메모리를 아낄 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Brute Force" /><summary type="html"><![CDATA[86971. 전력망을 둘로 나누기 / c++ / level2 / 18분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 9일차 TIL - 84512 모음 사전</title><link href="https://sho1007.github.io/programmers/84512/" rel="alternate" type="text/html" title="99클럽 코테 스터디 9일차 TIL - 84512 모음 사전" /><published>2024-05-28T00:00:00+00:00</published><updated>2024-05-28T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/84512</id><content type="html" xml:base="https://sho1007.github.io/programmers/84512/"><![CDATA[<h1 id="84512-모음-사전--c--level2--8분">84512. 모음 사전 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/84512.%E2%80%85%EB%AA%A8%EC%9D%8C%E2%80%85%EC%82%AC%EC%A0%84"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="완전-탐색">완전 탐색</h3>
<ol>
  <li>빈 문자열 “” 부터 시작해서 큐에 집어넣는다.</li>
  <li>큐가 빌 때까지 아래를 반복</li>
  <li>큐에서 하나를 꺼내서 만약 길이가 5라면, 더 이상 추가할 수 없으므로 continue</li>
  <li>for 문을 돌면서 현재 문자열에 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’ 를 추가한다.</li>
  <li>해당 문자를 다시 큐에 넣고, 벡터에도 넣는다.</li>
  <li>위의 과정을 마친 뒤, 벡터를 정렬하고, word가 벡터에서 몇 번째에 위치하는지 찾아서 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>완전 탐색이라는 키워드를 알고 풀다보니, 쉽게 풀 수 있었다. (그냥 다 해보면 되니까)</li>
  <li>오히려 미들러 문제가 시간이 좀 더 걸렸다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Brute Force" /><summary type="html"><![CDATA[84512. 모음 사전 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 8일차 TIL - 899 Orderly Queue</title><link href="https://sho1007.github.io/leetcode/899/" rel="alternate" type="text/html" title="99클럽 코테 스터디 8일차 TIL - 899 Orderly Queue" /><published>2024-05-27T00:00:00+00:00</published><updated>2024-05-27T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/899</id><content type="html" xml:base="https://sho1007.github.io/leetcode/899/"><![CDATA[<h1 id="899-orderly-queue--c--hard--30분">899. Orderly Queue / c++ / Hard / 30분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Cmp</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">char</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">orderlyQueue</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">Answer</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">Answer</span><span class="p">)</span> <span class="n">Answer</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">sort</span><span class="p">(</span><span class="n">Answer</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Answer</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">Answer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>처음엔 단순 정렬인 줄 알았는데, k가 1인 경우엔 정렬할 수 없이 계속 순환할 뿐이었다.</li>
  <li>그래서 Answer를 s로 초기화 해주고 k가 1인 경우와 아닌 경우로 나눈 뒤
    <ol>
      <li>k가 1이면 s.size() - 1 번 만큼 (한번 더 돌면 원래 상태이므로 -1 해줌) 돌면서 맨 앞 글자를 맨 뒤로 보내준다. 그 후 Answer 보다 작다면 Answer 갱신</li>
      <li>k가 2 이상이면 단순히 Answer를 정렬해준다.</li>
    </ol>
  </li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>리트코드 문제는 단순히 구현하는게 아니라 해당 문제의 본질을 찾는 것이 다른 곳들보다 더 중요하다고 느꼈다.</li>
  <li>앞에서 2개 중 하나만 골라 뒤로 보낼 수 있더라도 정렬이 가능하다는 것을 다시금 깨달았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[899. Orderly Queue / c++ / Hard / 30분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 7일차 TIL - 2551 Put Marbles in Bags</title><link href="https://sho1007.github.io/leetcode/2551/" rel="alternate" type="text/html" title="99클럽 코테 스터디 7일차 TIL - 2551 Put Marbles in Bags" /><published>2024-05-26T00:00:00+00:00</published><updated>2024-05-26T00:00:00+00:00</updated><id>https://sho1007.github.io/leetcode/2551</id><content type="html" xml:base="https://sho1007.github.io/leetcode/2551/"><![CDATA[<h1 id="2551-put-marbles-in-bags--c--hard--1시간">2551. Put Marbles in Bags / c++ / Hard / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">costVector</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">putMarbles</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">costVector</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">costVector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">costVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costVector</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">maxCost</span> <span class="o">+=</span> <span class="n">costVector</span><span class="p">[</span><span class="n">costVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">minCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">minCost</span> <span class="o">+=</span> <span class="n">costVector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">maxCost</span> <span class="o">-</span> <span class="n">minCost</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="정렬">정렬</h3>
<ol>
  <li>가장 단순하게 모든 구간을 잘라봤다. (전수조사, 백트래킹) -&gt; 시간 초과</li>
  <li>시간을 단축할 수 있는 방법을 찾아보려 했지만 결국 찾지 못했고, 힌트를 봤다.</li>
  <li>힌트에서 나눠지는 부분의 앞과 뒤를 사용해라고 나와 있었다.</li>
  <li>pair&lt;int,int&gt; 를 원소로 가지는 우선순위 큐를 선언하여 끊어질 수 있는 부분을 모두 넣었다.</li>
  <li>이러면 크거나 작은 한가지의 기준으로 정렬된 값을 꺼낼 수 있지만 여기선 최소값과 최대값 두가지의 기준이 필요했고, 기존 방법으로는 정렬의 반대 순서로 꺼내는게 번거로웠다.</li>
  <li>다시 생각해보니 굳이 우선순위 큐를 쓰지 않고, 벡터에 다 넣은 다음 정렬하면 앞뒤로 꺼낼 수 있었다.</li>
  <li>다른 분들의 풀이를 보니 또 굳이 pair&lt;int,int&gt; 로 나눠지는 부분을 받지 않고, 어차피 더해질 거 그냥 int 로 처음부터 더한 값을 원소로 받으면 된다는 점을 깨달았다.</li>
  <li>마지막으로 항상 maxSum - minSum을 반환하기 때문에, 맨 앞과 맨 뒤 원소는 maxSum과 minSum에 모두 포함되어 결국 상쇄되는 값이었다.</li>
  <li>이런 최적화 과정을 통해 최종 식이 (내림차순 정렬의 k-1개의 원소의 합) - (오름차순 정렬의 k-1개의 원소의 합) 이라는 점을 깨달았다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>리트코드는 힌트와 풀이 방법을 제공해준다는 점이 신기했다.</li>
  <li>힌트도 단계별로 나눠져 있어서 하다가 도저히 안되겠을 때 차례로 한 개씩 열어볼 수 있다는 점이 좋았다.</li>
  <li>이해하고 나니 단순 정렬 문제였는데, 풀이 과정을 유추해 내는 것이 너무 어려웠다.</li>
  <li>마치 구현 방법을 식으로 나타내고 그 식을 최적화하여 최종 계산식을 뽑아내는 느낌이었다.</li>
  <li>내가 부족한 부분이 문제 전체를 도식화하여 해결하는 능력이라는 것을 다시 한번 깨달을 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;LeetCode&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Sort" /><summary type="html"><![CDATA[2551. Put Marbles in Bags / c++ / Hard / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 6일차 TIL - 42628 이중우선순위큐</title><link href="https://sho1007.github.io/programmers/42628/" rel="alternate" type="text/html" title="99클럽 코테 스터디 6일차 TIL - 42628 이중우선순위큐" /><published>2024-05-25T00:00:00+00:00</published><updated>2024-05-25T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42628</id><content type="html" xml:base="https://sho1007.github.io/programmers/42628/"><![CDATA[<h1 id="42628-이중우선순위큐--c--level3--32분">42628. 이중우선순위큐 / c++ / level3 / 32분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42628.%E2%80%85%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="구현--자료구조--힙--셋-set">구현 / 자료구조 / 힙 / 셋 (Set)</h3>
<ol>
  <li>해당 요구사항에 맞게 자료구조를 구현하면 되는 문제였다.</li>
  <li>multiset을 사용해서 혹시 모를 중복에 대비하며, 자료를 입력과 동시에 정렬해줬다.</li>
  <li>D 1 의 경우 최대값을 삭제해야하므로 set 의 마지막 원소를 erase 해줬다.</li>
  <li>D -1 의 경우 최소값을 삭제해야하므로 set의 첫번째 원소를 erase 해줬다.</li>
  <li>마지막으로 set이 비어있는 경우 0,0을, set의 원소가 1개인 경우 해당 원소를 두번 출력해줬다.</li>
  <li>set의 원소가 2개 이상인 경우 set 의 begin 과 end -1 을 출력해줬다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>자료구조에 대한 이해가 있다면 set 혹은 priority_queue 등을 사용해서 쉽게 풀 수 있는 문제였던 것 같다.</li>
  <li>지금 와서 생각해보니 출력을 set의 원소가 0 / 1 / 2 이상 인 3가지로 잡지 않고 set이 비어있거나, 비어있지 않은 2가지 경우로 잡아도 충분히 출력이 가능한 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Heap" /><summary type="html"><![CDATA[42628. 이중우선순위큐 / c++ / level3 / 32분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 5일차 TIL - 42627 디스크 컨트롤러</title><link href="https://sho1007.github.io/programmers/42627/" rel="alternate" type="text/html" title="99클럽 코테 스터디 5일차 TIL - 42627 디스크 컨트롤러" /><published>2024-05-24T00:00:00+00:00</published><updated>2024-05-24T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42627</id><content type="html" xml:base="https://sho1007.github.io/programmers/42627/"><![CDATA[<h1 id="42627-디스크-컨트롤러--c--level3--1시간">42627. 디스크 컨트롤러 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42627.%E2%80%85%EB%94%94%EC%8A%A4%ED%81%AC%E2%80%85%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--힙--우선순위-큐">자료구조 / 힙 / 우선순위 큐</h3>
<ol>
  <li>문제 자체는 단순했다.</li>
  <li>현재 처리할 수 있는 일들 중 가장 짧은 일을 처리한다.</li>
  <li>모든 일을 처리할 때까지 반복</li>
  <li>이 때, 일을 짧은 순서로 정리하기 위해서 우선순위 큐를 사용했다.</li>
  <li>하지만 간과한 것이 2가지 있었다.
    <ol>
      <li>매번 일을 하나 처리할 때마다, 현재 시간이 증가하기 때문에, 새로운 일들이 들어온다. 이를 놓쳐서 큐에 있는 모든 일을 처리한 뒤 새로운 일들을 큐에 받아들였더니 틀린 답이 나왔었다.</li>
      <li>첫 일을 정할때도 가장 짧은 일을 골라야 한다. jobs 벡터가 정렬되어 있지 않을 것이라고 생각해서 정렬을 했었지만, 단순 시작 시간으로만 정렬을 했었다. 그랬더니 아마 첫 일을 가장 빠른 일이지만 가장 짧은 일을 고르지 못해서 틀렸던 것 같다.</li>
    </ol>
  </li>
  <li>위의 두가지 문제를 해결했더니 정답을 맞출 수 있었다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 자체는 굉장히 단순하다고 생각했는데, 엣지 케이스를 찾는데 너무 많은 시간을 허비했다.</li>
  <li>다음부터 이렇게 뭔가 놓치는 부분이 보이면 수도코드로 어느정도 정리해서 엣지 케이스를 잡을 수 있도록 해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Heap" /><summary type="html"><![CDATA[42627. 디스크 컨트롤러 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 4일차 TIL - 12909 옳바른 괄호</title><link href="https://sho1007.github.io/programmers/12909/" rel="alternate" type="text/html" title="99클럽 코테 스터디 4일차 TIL - 12909 옳바른 괄호" /><published>2024-05-23T00:00:00+00:00</published><updated>2024-05-23T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/12909</id><content type="html" xml:base="https://sho1007.github.io/programmers/12909/"><![CDATA[<h1 id="12909-옳바른-괄호--c--level2--8분">12909. 옳바른 괄호 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/12909.%E2%80%85%EC%98%AC%EB%B0%94%EB%A5%B8%E2%80%85%EA%B4%84%ED%98%B8"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--스택">자료구조 / 스택</h3>
<ol>
  <li>괄호 문제는 일단 스택을 생각하고 봐야한다.</li>
  <li>만약 배열의 원소의 갯수가 홀수라면 false를 리턴</li>
  <li>아니라면 배열을 순회하며
    <ol>
      <li>여는 괄호가 나오면 스택에 push</li>
      <li>닫는 괄호가 나오면 스택의 top이 여는 괄호인지 체크
        <ol>
          <li>스택이 비어있거나 스택의 top이 여는 괄호가 아니라면 false 리턴</li>
          <li>스택의 top이 여는 괄호라면 스택을 pop</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>배열 순회가 무사히 끝나면 true 리턴</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>괄호 문제 = 스택이라는 공식을 다시 한번 체감할 수 있는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Stack" /><summary type="html"><![CDATA[12909. 옳바른 괄호 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 3일차 TIL - 42586 기능개발</title><link href="https://sho1007.github.io/programmers/42586/" rel="alternate" type="text/html" title="99클럽 코테 스터디 3일차 TIL - 42586 기능개발" /><published>2024-05-22T00:00:00+00:00</published><updated>2024-05-22T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42586</id><content type="html" xml:base="https://sho1007.github.io/programmers/42586/"><![CDATA[<h1 id="42586-기능개발--c--level2--11분">42586. 기능개발 / c++ / level2 / 11분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42586.%E2%80%85%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="구현">구현</h3>
<ol>
  <li>완료되지 않은 가장 앞의 작업이 100을 넘길때까지 계속 작업량을 한번씩 더함</li>
  <li>완료되지 않은 가장 앞의 작업이 100을 넘기면, 그 뒤로 100이 넘어간 작업이 몇개 더 있는지 체크</li>
  <li>해당 갯수만큼 정답 벡터에 삽입, 만약 완료되지 않은 작업이 남았다면 다시 완료되지 않은 가장 앞의 작업에서 1번부터 반복</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제의 카테고리에는 자료구조와 큐가 적혀있었는데 이 문제는 단순 구현으로만 풀어서 뭔가 더 좋은 방법이 없나 고민해봤다.</li>
  <li>while 문으로 현재 작업이 100%를 넘길때까지 반복할게 아니라, (100 - 현재 작업량)/작업 속도를 해서 작업일을 구하고, 그 뒤로 해당 작업일까지 작업했을 때 같이 배포할 수 있는 것들의 수를 더해서 벡터에 삽입하는 방식이 더 효율적이라고 생각했다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Queue" /><summary type="html"><![CDATA[42586. 기능개발 / c++ / level2 / 11분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 2일차 TIL - 42578 의상</title><link href="https://sho1007.github.io/programmers/42578/" rel="alternate" type="text/html" title="99클럽 코테 스터디 2일차 TIL - 42578 의상" /><published>2024-05-21T00:00:00+00:00</published><updated>2024-05-21T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42578</id><content type="html" xml:base="https://sho1007.github.io/programmers/42578/"><![CDATA[<h1 id="42578-의상--c--level2--8분">42578. 의상 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42578.%E2%80%85%EC%9D%98%EC%83%81"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--해시">자료구조 / 해시</h3>
<ol>
  <li>매일 다른 옷을 입어야 하고 종류별로 최대 1가지 의상을 착용하거나 착용하지 않을 수 있는데, 최소 1가지의 옷은 입어야 한다.</li>
  <li>문제를 보고 든 생각은 종류 (카테고리) 별로 옷을 나누고, 그 옷들의 조합의 수를 구하는 것이었다.</li>
  <li>이 때 주의해야 할 점은 3가지이다.
    <ol>
      <li>각 종류별로 1가지를 입거나 입지 않을 수 있기 때문에 종류의 가짓수 + 1을 한 값에서 조합을 구해야 한다.</li>
      <li>최소 1개의 옷을 입어야 하기 때문에 모두 입지 않은 경우는 빼야한다.</li>
      <li>마지막으로 옷의 종류가 1가지만 있는 경우 1번과 2번이 상충되어 해당 종류의 가짓수를 그대로 출력한다.</li>
    </ol>
  </li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>챌린저 문제를 한참 고민하다 시간이 촉박하여 미들러 문제를 풀게 되었다.</li>
  <li>해싱을 통해 데이터를 정리 (나는 이것을 재료 손질이라고 부른다.) 하고 그 데이터를 가지고 추가적인 로직(여기서는 조합)과 예외 조건 등을 처리하는 문제였다.</li>
  <li>해싱은 그 자체로 문제 해결 알고리즘이 될 수 있지만, 이렇게 문제를 풀기 위한 사전 작업이 될 수도 있다는 점을 다시 한번 깨달았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Hash" /><summary type="html"><![CDATA[42578. 의상 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 1일차 TIL - 42579 베스트앨범</title><link href="https://sho1007.github.io/programmers/42579/" rel="alternate" type="text/html" title="99클럽 코테 스터디 1일차 TIL - 42579 베스트앨범" /><published>2024-05-20T00:00:00+00:00</published><updated>2024-05-20T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42579</id><content type="html" xml:base="https://sho1007.github.io/programmers/42579/"><![CDATA[<h1 id="42579-베스트앨범--c--level3--13분">42579. 베스트앨범 / c++ / level3 / 13분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42579.%E2%80%85%EB%B2%A0%EC%8A%A4%ED%8A%B8%EC%95%A8%EB%B2%94"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--해시--정렬">자료구조 / 해시 / 정렬</h3>
<ol>
  <li>문제를 읽고 든 생각은 총 2개의 컨테이너가 필요하다는 것이었다.
    <ol>
      <li>각 장르별 총 재생 횟수를 저장하는 컨테이너</li>
      <li>각 장르마다 곡의 인덱스와 재생 횟수를 저장하는 컨테이너</li>
    </ol>
  </li>
  <li>그래서 genres와 plays 벡터를 순회하면서 형식에 맞게 자료를 저장했다.</li>
  <li>문제의 요구 사항 1번이 ‘속한 노래가 많이 재생된 장르를 먼저 수록합니다.’ 였으므로 1번 컨테이너를 재생 횟수 순으로 정렬했다.</li>
  <li>정렬된 1번 컨테이너를 순회하면서 (이러면 자연스럽게 재생 횟수 순으로 노래가 들어가게 된다.) 해당 장르에 속하는 2번 컨테이너를 정렬했는데, 이 때 문제의 요구 사항 2, 3번을 적용했다.</li>
  <li>정렬된 2번 컨테이너에서 (장르가 존재한다는 것은 해당 장르의 노래가 최소 한 곡 이상은 존재한다는 의미이므로) 우선 첫 번째 원소의 인덱스를 정답 벡터에 삽입하고, 컨테이너 사이즈가 1 이상이면 두 번째 원소의 인덱스도 정답 벡터에 삽입했다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 외적으로 99클럽이 빠른 시일 내에 다시 열려서 기쁘다. 혼자서 코테 준비를 하게 되면 아무래도 꾸준하게 하기가 어려웠는데, 99클럽을 통해 다시 꾸준하게 코테 준비를 이어나가야겠다.</li>
  <li>문제는 해시 (맵) 과 정렬을 사용하면 비교적 쉽게 풀리는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Hash" /><category term="Sort" /><summary type="html"><![CDATA[42579. 베스트앨범 / c++ / level3 / 13분]]></summary></entry></feed>