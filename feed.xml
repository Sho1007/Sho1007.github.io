<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-05-23T08:56:09+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 4일차 TIL - 12909 옳바른 괄호</title><link href="https://sho1007.github.io/programmers/12909/" rel="alternate" type="text/html" title="99클럽 코테 스터디 4일차 TIL - 12909 옳바른 괄호" /><published>2024-05-23T00:00:00+00:00</published><updated>2024-05-23T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/12909</id><content type="html" xml:base="https://sho1007.github.io/programmers/12909/"><![CDATA[<h1 id="12909-옳바른-괄호--c--level2--8분">12909. 옳바른 괄호 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/12909.%E2%80%85%EC%98%AC%EB%B0%94%EB%A5%B8%E2%80%85%EA%B4%84%ED%98%B8"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--스택">자료구조 / 스택</h3>
<ol>
  <li>괄호 문제는 일단 스택을 생각하고 봐야한다.</li>
  <li>만약 배열의 원소의 갯수가 홀수라면 false를 리턴</li>
  <li>아니라면 배열을 순회하며
    <ol>
      <li>여는 괄호가 나오면 스택에 push</li>
      <li>닫는 괄호가 나오면 스택의 top이 여는 괄호인지 체크
        <ol>
          <li>스택이 비어있거나 스택의 top이 여는 괄호가 아니라면 false 리턴</li>
          <li>스택의 top이 여는 괄호라면 스택을 pop</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>배열 순회가 무사히 끝나면 true 리턴</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>괄호 문제 = 스택이라는 공식을 다시 한번 체감할 수 있는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Stack" /><summary type="html"><![CDATA[12909. 옳바른 괄호 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 3일차 TIL - 42586 기능개발</title><link href="https://sho1007.github.io/programmers/42586/" rel="alternate" type="text/html" title="99클럽 코테 스터디 3일차 TIL - 42586 기능개발" /><published>2024-05-22T00:00:00+00:00</published><updated>2024-05-22T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42586</id><content type="html" xml:base="https://sho1007.github.io/programmers/42586/"><![CDATA[<h1 id="42586-기능개발--c--level2--11분">42586. 기능개발 / c++ / level2 / 11분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42586.%E2%80%85%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="구현">구현</h3>
<ol>
  <li>완료되지 않은 가장 앞의 작업이 100을 넘길때까지 계속 작업량을 한번씩 더함</li>
  <li>완료되지 않은 가장 앞의 작업이 100을 넘기면, 그 뒤로 100이 넘어간 작업이 몇개 더 있는지 체크</li>
  <li>해당 갯수만큼 정답 벡터에 삽입, 만약 완료되지 않은 작업이 남았다면 다시 완료되지 않은 가장 앞의 작업에서 1번부터 반복</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제의 카테고리에는 자료구조와 큐가 적혀있었는데 이 문제는 단순 구현으로만 풀어서 뭔가 더 좋은 방법이 없나 고민해봤다.</li>
  <li>while 문으로 현재 작업이 100%를 넘길때까지 반복할게 아니라, (100 - 현재 작업량)/작업 속도를 해서 작업일을 구하고, 그 뒤로 해당 작업일까지 작업했을 때 같이 배포할 수 있는 것들의 수를 더해서 벡터에 삽입하는 방식이 더 효율적이라고 생각했다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Queue" /><summary type="html"><![CDATA[42586. 기능개발 / c++ / level2 / 11분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 2일차 TIL - 42578 의상</title><link href="https://sho1007.github.io/programmers/42578/" rel="alternate" type="text/html" title="99클럽 코테 스터디 2일차 TIL - 42578 의상" /><published>2024-05-21T00:00:00+00:00</published><updated>2024-05-21T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42578</id><content type="html" xml:base="https://sho1007.github.io/programmers/42578/"><![CDATA[<h1 id="42578-의상--c--level2--8분">42578. 의상 / c++ / level2 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42578.%E2%80%85%EC%9D%98%EC%83%81"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--해시">자료구조 / 해시</h3>
<ol>
  <li>매일 다른 옷을 입어야 하고 종류별로 최대 1가지 의상을 착용하거나 착용하지 않을 수 있는데, 최소 1가지의 옷은 입어야 한다.</li>
  <li>문제를 보고 든 생각은 종류 (카테고리) 별로 옷을 나누고, 그 옷들의 조합의 수를 구하는 것이었다.</li>
  <li>이 때 주의해야 할 점은 3가지이다.
    <ol>
      <li>각 종류별로 1가지를 입거나 입지 않을 수 있기 때문에 종류의 가짓수 + 1을 한 값에서 조합을 구해야 한다.</li>
      <li>최소 1개의 옷을 입어야 하기 때문에 모두 입지 않은 경우는 빼야한다.</li>
      <li>마지막으로 옷의 종류가 1가지만 있는 경우 1번과 2번이 상충되어 해당 종류의 가짓수를 그대로 출력한다.</li>
    </ol>
  </li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>챌린저 문제를 한참 고민하다 시간이 촉박하여 미들러 문제를 풀게 되었다.</li>
  <li>해싱을 통해 데이터를 정리 (나는 이것을 재료 손질이라고 부른다.) 하고 그 데이터를 가지고 추가적인 로직(여기서는 조합)과 예외 조건 등을 처리하는 문제였다.</li>
  <li>해싱은 그 자체로 문제 해결 알고리즘이 될 수 있지만, 이렇게 문제를 풀기 위한 사전 작업이 될 수도 있다는 점을 다시 한번 깨달았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Hash" /><summary type="html"><![CDATA[42578. 의상 / c++ / level2 / 8분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 1일차 TIL - 42579 베스트앨범</title><link href="https://sho1007.github.io/programmers/42579/" rel="alternate" type="text/html" title="99클럽 코테 스터디 1일차 TIL - 42579 베스트앨범" /><published>2024-05-20T00:00:00+00:00</published><updated>2024-05-20T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42579</id><content type="html" xml:base="https://sho1007.github.io/programmers/42579/"><![CDATA[<h1 id="42579-베스트앨범--c--level3--13분">42579. 베스트앨범 / c++ / level3 / 13분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42579.%E2%80%85%EB%B2%A0%EC%8A%A4%ED%8A%B8%EC%95%A8%EB%B2%94"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조--해시--정렬">자료구조 / 해시 / 정렬</h3>
<ol>
  <li>문제를 읽고 든 생각은 총 2개의 컨테이너가 필요하다는 것이었다.
    <ol>
      <li>각 장르별 총 재생 횟수를 저장하는 컨테이너</li>
      <li>각 장르마다 곡의 인덱스와 재생 횟수를 저장하는 컨테이너</li>
    </ol>
  </li>
  <li>그래서 genres와 plays 벡터를 순회하면서 형식에 맞게 자료를 저장했다.</li>
  <li>문제의 요구 사항 1번이 ‘속한 노래가 많이 재생된 장르를 먼저 수록합니다.’ 였으므로 1번 컨테이너를 재생 횟수 순으로 정렬했다.</li>
  <li>정렬된 1번 컨테이너를 순회하면서 (이러면 자연스럽게 재생 횟수 순으로 노래가 들어가게 된다.) 해당 장르에 속하는 2번 컨테이너를 정렬했는데, 이 때 문제의 요구 사항 2, 3번을 적용했다.</li>
  <li>정렬된 2번 컨테이너에서 (장르가 존재한다는 것은 해당 장르의 노래가 최소 한 곡 이상은 존재한다는 의미이므로) 우선 첫 번째 원소의 인덱스를 정답 벡터에 삽입하고, 컨테이너 사이즈가 1 이상이면 두 번째 원소의 인덱스도 정답 벡터에 삽입했다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>문제 외적으로 99클럽이 빠른 시일 내에 다시 열려서 기쁘다. 혼자서 코테 준비를 하게 되면 아무래도 꾸준하게 하기가 어려웠는데, 99클럽을 통해 다시 꾸준하게 코테 준비를 이어나가야겠다.</li>
  <li>문제는 해시 (맵) 과 정렬을 사용하면 비교적 쉽게 풀리는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Hash" /><category term="Sort" /><summary type="html"><![CDATA[42579. 베스트앨범 / c++ / level3 / 13분]]></summary></entry><entry><title type="html">18352 특정 거리의 도시 찾기</title><link href="https://sho1007.github.io/boj/18352/" rel="alternate" type="text/html" title="18352 특정 거리의 도시 찾기" /><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/18352</id><content type="html" xml:base="https://sho1007.github.io/boj/18352/"><![CDATA[<h1 id="18352-특정-거리의-도시-찾기--c--silver2--30분">18352 특정 거리의 도시 찾기 / c++ / Silver2 / 30분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/18352.%E2%80%85%ED%8A%B9%EC%A0%95%E2%80%85%EA%B1%B0%EB%A6%AC%EC%9D%98%E2%80%85%EB%8F%84%EC%8B%9C%E2%80%85%EC%B0%BE%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프--다익스트라">그래프 / 다익스트라</h3>
<ol>
  <li>각 도시간의 거리는 1이다.</li>
  <li>최대 도시 수는 300’000으로, 인접행렬로 구하기엔 공간 복잡도가 높다. <br />
 -&gt; 인접 리스트를 사용</li>
  <li>시작 도시 X에서 다익스트라 알고리즘으로 각 도시까지의 거리를 구한다.</li>
  <li>계산이 끝나면 그 중 거리가 K인 도시를 사전 순으로 출력, 없다면 -1을 출력한다.</li>
</ol>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>다익스트라 알고리즘을 적용해 볼 수 있는 비교적 간단한 문제였다.</li>
  <li>각 도시간의 거리가 1이라는 점, 큐와 다익스트라의 성질에 의해 먼저 접근한 도시가 당연히 거리가 짧게 된다. (그래서 거리를 비교할게 아니라 방문만 했다면 바로 건너뛰면 됨)</li>
  <li>1차 시도에서 시간이 960ms가 나와서 왜 그런지 찾아봤더니 인접 리스트를 저장할 때 Map으로 저장한게 시간을 지연시켰었다.
300’000개나 되는 도시를 다 저장하지 않아도 된다고 생각해서 검색 속도가 빠른 Map을 사용한 것이었는데, 이정도 규모에서는 그냥 Vector를 사용하는 것이 훨씬 효율이 좋았다. (심지어 메모리도 더 적게 차지했다.)</li>
  <li>간만에 자료구조에 대해 다시 생각해볼 수 있는 좋은 경험이었다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="Dijkstra" /><summary type="html"><![CDATA[18352 특정 거리의 도시 찾기 / c++ / Silver2 / 30분]]></summary></entry><entry><title type="html">11652 카드</title><link href="https://sho1007.github.io/boj/11652/" rel="alternate" type="text/html" title="11652 카드" /><published>2024-05-05T00:00:00+00:00</published><updated>2024-05-05T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/11652</id><content type="html" xml:base="https://sho1007.github.io/boj/11652/"><![CDATA[<h1 id="11652-카드--c--silver4--8분">11652 카드 / c++ / Silver4 / 8분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/11652.%E2%80%85%EC%B9%B4%EB%93%9C"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료구조---맵--정렬">자료구조  / 맵 / 정렬</h3>
<ol>
  <li>준규가 가지는 하나의 카드는 long long 범위이다.</li>
  <li>맵을 사용하여 카드의 갯수를 증가시키며 저장</li>
  <li>카드 입력 종료 후 맵을 처음부터 순회하며 최대값 갱신때마다 answer에 해당 정수를 저장</li>
  <li>answer 출력</li>
</ol>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>자료형의 범위와 맵의 특징을 알고 있다면 쉽게 풀 수 있는 문제였다.</li>
  <li>맵을 벡터로 변환하여 정렬 후 가장 앞의 값을 출력해도 풀 수 있을 것 같다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Map" /><category term="Sort" /><summary type="html"><![CDATA[11652 카드 / c++ / Silver4 / 8분]]></summary></entry><entry><title type="html">3085 사탕 게임</title><link href="https://sho1007.github.io/boj/3085/" rel="alternate" type="text/html" title="3085 사탕 게임" /><published>2024-05-04T00:00:00+00:00</published><updated>2024-05-04T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/3085</id><content type="html" xml:base="https://sho1007.github.io/boj/3085/"><![CDATA[<h1 id="3085-사탕-게임--c--silver2--40분">3085 사탕 게임 / c++ / Silver2 / 40분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/3085.%E2%80%85%EC%82%AC%ED%83%95%E2%80%85%EA%B2%8C%EC%9E%84"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="브루트-포스--구현">브루트 포스 / 구현</h3>
<ol>
  <li>인접한 4칸 중 색이 다른 칸을 찾기
 (왼쪽위에서 우하향으로 내려오기 때문에 오른쪽, 아래만 검사하면 됨)</li>
  <li>서로 색을 바꾸기</li>
  <li>바꾼 칸 두 칸을 기준으로 4방향으로 뻗었을 때, 가장 긴 수를 반환</li>
  <li>최대값 갱신</li>
  <li>순회가 끝나면 최대값 출력</li>
</ol>

<p>-&gt; 내가 바꾸지 않은 부분에서 최대값이 나오는 경우를 탐지하지 못했다. (에제 2번)</p>

<p>그래서 1번 전에 우선 현재 칸 기준으로 최대값을 한번 찾는 로직을 추가했다. <br />
-&gt; 해결</p>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>코딩을 시작하기 전에 문제를 한번 분석하고 수도 코드를 작성하고 풀었더니 훨씬 쉽게 풀렸다.</li>
  <li>내가 바꾸지 않은 부분에서 최대값이 나올 수 있다는 것을 알았을 때, 처음엔 바꿀 때마다 전체 보드를 다 탐색해야 하나 생각했다.</li>
  <li>하지만 너무 비효율적이었고, 다른 방법을 찾던 중, 결국 내가 바꿨다면 변화가 거기에서만 오기때문에 그 부분만 찾는게 맞고, 아니라면 바꾸기 전 상태를 먼저 체크하면 되는게 아닌가 생각이 들었다.</li>
  <li>생각한대로 수정하고 문제를 해결하게 되어 엄청 뿌듯했다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Brute Force" /><summary type="html"><![CDATA[3085 사탕 게임 / c++ / Silver2 / 40분]]></summary></entry><entry><title type="html">11399 ATM</title><link href="https://sho1007.github.io/boj/11399/" rel="alternate" type="text/html" title="11399 ATM" /><published>2024-05-03T00:00:00+00:00</published><updated>2024-05-03T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/11399</id><content type="html" xml:base="https://sho1007.github.io/boj/11399/"><![CDATA[<h1 id="11399-atm--c--silver4--11분">11399 ATM / c++ / Silver4 / 11분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/11399.%E2%80%85ATM"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그리디--정렬">그리디 / 정렬</h3>
<ol>
  <li>시간의 총 합을 최소로 줄이기 위해선, 인출 시간이 짧은 순서대로 정렬하면 된다.</li>
</ol>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>정렬로 쉽게 풀 수 있는 문제였다.</li>
  <li>문제가 요구하는 총 인출 시간은 각 사람마다 대기시간 + 인출시간 을 더한 값의 총합이었는데, 처음에는 이를 혼동하여 마지막 사람의 대기시간 + 인출시간을 출력했었다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Greedy" /><category term="Sort" /><summary type="html"><![CDATA[11399 ATM / c++ / Silver4 / 11분]]></summary></entry><entry><title type="html">12789 도키도키 간식드리미</title><link href="https://sho1007.github.io/boj/12789/" rel="alternate" type="text/html" title="12789 도키도키 간식드리미" /><published>2024-05-02T00:00:00+00:00</published><updated>2024-05-02T00:00:00+00:00</updated><id>https://sho1007.github.io/boj/12789</id><content type="html" xml:base="https://sho1007.github.io/boj/12789/"><![CDATA[<h1 id="12789-도키도키-간식드리미--c--silver3--20분">12789 도키도키 간식드리미 / c++ / Silver3 / 20분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>
<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/12789.%E2%80%85%EB%8F%84%ED%82%A4%EB%8F%84%ED%82%A4%E2%80%85%EA%B0%84%EC%8B%9D%EB%93%9C%EB%A6%AC%EB%AF%B8"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="자료-구조--스택">자료 구조 / 스택</h3>
<ol>
  <li>입력을 받았을 때, 우선 스택이 비어있는지 체크
    <ol>
      <li>비어있지 않다면 스택의 탑이 들어갈 수 있는지 체크
        <ol>
          <li>들어갈 수 있다면 스택을 pop 하고 들어갈 수 있는 번호 1 증가</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>현재 입력 값이 들어갈 수 있는 지 체크
    <ol>
      <li>들어갈 수 있다면 들어갈 수 있는 번호 1 증가</li>
      <li>들어갈 수 없다면 Stack 에 입력값을 push</li>
    </ol>
  </li>
  <li>입력을 다 받은 후 스택이 비어 있는지 체크 후, 비어 있지 않다면 스택이 빌 때까지 반복
    <ol>
      <li>스택의 탑이 들어갈 수 있다면 pop, 들어갈 수 있는 번호 1 증가</li>
      <li>스택의 탑이 들어갈 수 없다면 “Sad\n” 출력 후 종료</li>
    </ol>
  </li>
  <li>스택도 다 비었다면, 전부 들어간 것이므로 “Nice\n” 출력</li>
</ol>

<h2 id="다시-생각해-볼-점">다시 생각해 볼 점</h2>
<ol>
  <li>스택의 값이 다시 배열로 돌아갈 수 없다는 조건을 처음에 발견하지 못해서 시간을 소모했다. 문제를 제대로 읽는 습관을 들여야겠다.</li>
  <li>스택의 성질만 안다면 쉽게 풀 수 있는 문제였다.</li>
</ol>]]></content><author><name>Sho1007</name></author><category term="[&quot;BOJ&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Data Structure" /><category term="Stack" /><summary type="html"><![CDATA[12789 도키도키 간식드리미 / c++ / Silver3 / 20분]]></summary></entry><entry><title type="html">OOP</title><link href="https://sho1007.github.io/design%20pattern/OOP/" rel="alternate" type="text/html" title="OOP" /><published>2024-05-01T00:00:00+00:00</published><updated>2024-05-01T00:00:00+00:00</updated><id>https://sho1007.github.io/design%20pattern/OOP</id><content type="html" xml:base="https://sho1007.github.io/design%20pattern/OOP/"><![CDATA[<h1 id="summary"><strong>Summary</strong></h1>

<h3 id="절차지향과-함수지향-프로그래밍과-비교한-객체지향-프로그래밍의-장단점">절차지향과 함수지향 프로그래밍과 비교한 객체지향 프로그래밍의 장단점</h3>

<h1 id="concept"><strong>Concept</strong></h1>

<h3 id="절차형">절차형:</h3>

<ul>
  <li>멤버 변수, 속성과 같은 데이터가 메서드와 분리되어 있는 것이 특징이다.</li>
  <li>메서드와 데이터 구조의 정의는 서로 관계가 없다.</li>
  <li>간단한 프로그램으로, 작업 흐름이 가지를 뻗어나가지 않고 일직선 형태를 띄는 경우에 유리하다.</li>
  <li>복잡한 대규모 프로그램의 경우 흐름이 그물망이나 나뭇가지처럼 여러 방향으로 얽히게 되는데, 이를 구현하기 위해서는 객체지향에 비해 훨씬 더 많은 노력이 필요하다.</li>
</ul>

<h3 id="함수형-">함수형 :</h3>

<ul>
  <li>함수형 프로그래밍의 함수는 수학의 함수 또는 포현식을 의미한다.</li>
  <li>프로그램이 수학적 표현의 조합 또는 표현식의 조합으로 표현될 수 있다고 생각한다.
    <ul>
      <li>이론적으로는 가능하지만 모든 프로그램이 이에 적합한 것은 아니다.</li>
    </ul>
  </li>
  <li>코드의 구성 단위로 함수를 사용한다.
    <ul>
      <li>스테이트리스 함수 라는 점에서 절차적 프로그래밍과 다르다.</li>
      <li>절차적 프로그래밍의 경우 전역 변수를 활용하는 반면 함수형 프로그래밍은 입력 매개변수만을 사용한다.</li>
    </ul>
  </li>
  <li>프로그래밍의 특수성 때문에 함수형 프로그래밍은 컴퓨터 과학, 데이터 처리, 통계 분석과 같은 특수한 분야에서만 그 장점을 충분히 발휘할 수 있다.</li>
</ul>

<h3 id="객체-지향-">객체 지향 :</h3>

<h3 id="캡슐화">캡슐화</h3>

<ul>
  <li>정보 은닉, 데이터 액세스 보호</li>
  <li>은행 계좌 클래스의 경우 balance(잔고) 를 다른 클래스에서 마음대로 가져다 변경할 경우 문제가 생길 수 있다.</li>
  <li>언어 자체에서 이를 지원하는 문법을 제공해야한다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="p">,</span> <span class="n">C</span><span class="o">++</span> <span class="err">의</span> <span class="k">public</span> <span class="o">/</span> <span class="k">private</span> <span class="err">키워드</span>
</code></pre></div></div>

<h3 id="추상화">추상화</h3>

<ul>
  <li>메서드의 내부 구현을 숨기는 것</li>
  <li>기능의 구현 방식이 아닌, 메서드가 제공하는 기능에만 집중할 수 있다.</li>
  <li>클래스의 메서드를 정의하거나 이름을 붙일 때는 추상적인 사고가 필요하다.</li>
  <li>에를 들어 getNaverCloudPictureUrl()은 네이버 클라우드가 아닌 다른 곳에 사진을 저장하게 되면 이름의 수정이 필요하다. getPictureUrl() 같이 보다 추상적인 이름을 사용하는 것이 좋다.</li>
</ul>

<h3 id="상속">상속</h3>

<ul>
  <li>‘is-a’ 관계</li>
  <li>단일 상속 : 하위 클래스가 단 하나의 상위 클래스만을 상속하는 것</li>
  <li>다중 상속 : 하위 클래스가 여러 상위 클래스를 동시에 상속할 수 있음을 의미
    <ul>
      <li>다중 상속의 경우 상속을 지원하는 모든 언어가 지원하는 것은 아니다.</li>
      <li>다이아몬드 상속 문제가 발생할 수 있다.</li>
    </ul>
  </li>
  <li>프로그래밍 언어가 상속을 표현하는 문법을 별도로 지원해야 한다.</li>
  <li>재사용성 : 상속을 이용하여 공통 부분을 상위 클래스로 모으면, 코드를 재사용하여 불필요한 반복을 줄일 수 있다.</li>
  <li>상속의 계층구조가 너무 깊고 복잡하면 코드의 가독성과 유지 관리성이 떨어진다. 그러므로 적게, 혹은 사용하지 않는 것이 좋고 ‘상속보다 합성’을 사용하는 것이 좋다.</li>
</ul>

<h3 id="다형성">다형성</h3>

<ul>
  <li>코드를 실행하는 과정에서 하위 클래스를 상위 클래스 대신 사용하고, 하위 클래스의 메서드를 호출할 수 있는 특성</li>
  <li>다형성을 충족시키기 위한 문법 (상속과 메서드 재정의를 활용한 방식)
    <ul>
      <li>상위 클래스 객체가 하위 클래스 객체를 참조할 수 있어야 한다.</li>
      <li>상속을 지원해야 한다.</li>
      <li>상위 클래스의 메서드를 재정의하는 하위 클래스를 지원해야 한다.</li>
    </ul>

    <aside>
  💡 상위 클래스를 상속한 하위 클래스에서 상위 클래스의 함수를 재정의 한 경우, 이를 상위 클래스가 참조할 수 있다면, 해상 함수를 호출 함으로써 다형성을 충족시켰다고 할 수 있다.
    
  </aside>
  </li>
  <li>이 밖에도 인터페이스 문법을 사용하거나 duck-typing 문법을 사용할 수있다.
    <ul>
      <li>Interface 문법
        <ul>
          <li>동일한 인터페이스를 구현하여 서로 다른 클래스여도 같은 인터페이스 형으로 사용될 수 있다.</li>
        </ul>
      </li>
      <li>duck-typing 문법
        <ul>
          <li>모든 언어에서 지원하는 것은 아니다. (C++에서는 지원하지 않고 Python에서는 지원한다.)</li>
          <li>동일한 함수명을 정의하여 같은 형식으로 활용할 수있다.</li>
          <li>다형성을 훨씬 유연하게 구현할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>다형성은 코드의 재사용성을 향상시킨다.</li>
</ul>

<h1 id="advantages"><strong>Advantages</strong></h1>

<ul>
  <li>재사용성</li>
  <li>확장성</li>
  <li>유지 보수 용이</li>
  <li>복잡한 관계에 대한 설계의 용이성</li>
</ul>

<h1 id="wrap-up"><strong>Wrap-up</strong></h1>

<ul>
  <li>절차형 프로그래밍의 경우 간단한 선형 구조의 프로그램을 구현하는데 유리하고, 함수형 프로그래밍의 경우 컴퓨터 과학이나, 데이터 처리 등의 프로그램을 구현하는데 유리하다. 하지만 둘은 함수 작성과 같은 특정 구현 세부 사항에 중점을 두는데, 이로 인해 프로그램의 흐름이 그물처럼 얽힌 관계가 복잡한 프로그램의 경우 객체 지향 프로그래밍에 비해 효율이 떨어진다. 반면 객체 지향 프로그래밍의 경우 상속, 다형성, 캡슐화, 추상화 의 특징을 활용하여 클래스 설계를 비롯한 코드 모듈 설계에 중점을 두므로 복잡한 구조의 프로그래밍 설계에 유리하고 재사용, 확장, 유지 관리가 쉽다.</li>
</ul>]]></content><author><name>Sho1007</name></author><category term="[&quot;Design Pattern&quot;]" /><category term="Study" /><summary type="html"><![CDATA[Summary]]></summary></entry></feed>