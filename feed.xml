<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-06-04T13:46:15+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 16일차 TIL - 42861 섬 연결하기</title><link href="https://sho1007.github.io/programmers/42861/" rel="alternate" type="text/html" title="99클럽 코테 스터디 16일차 TIL - 42861 섬 연결하기" /><published>2024-06-04T00:00:00+00:00</published><updated>2024-06-04T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42861</id><content type="html" xml:base="https://sho1007.github.io/programmers/42861/"><![CDATA[<h1 id="42861-섬-연결하기--c--level3--7분">42861. 섬 연결하기 / c++ / level3 / 7분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42861.%E2%80%85%EC%84%AC%E2%80%85%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그리디--그래프--union-find--크루스칼">그리디 / 그래프 / Union-Find / 크루스칼</h3>
<ol>
  <li>크루스칼 알고리즘을 이용하여 최소 신장 트리를 만들었을 때의 비용을 구하는 문제였다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>MST와 Union-Find 를 알고 있다면 쉽게 풀 수 있는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="Greedy" /><category term="UnionFind" /><category term="Kruskal" /><summary type="html"><![CDATA[42861. 섬 연결하기 / c++ / level3 / 7분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 15일차 TIL - 43162 네트워크</title><link href="https://sho1007.github.io/programmers/43162/" rel="alternate" type="text/html" title="99클럽 코테 스터디 15일차 TIL - 43162 네트워크" /><published>2024-06-03T00:00:00+00:00</published><updated>2024-06-03T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43162</id><content type="html" xml:base="https://sho1007.github.io/programmers/43162/"><![CDATA[<h1 id="43162-네트워크--c--level3--12분">43162. 네트워크 / c++ / level3 / 12분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43162.%E2%80%85%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs">그래프 탐색 / BFS</h3>
<ol>
  <li>처음엔 Union-Find 알고리즘을 활용하여, 부모가 다른 노드의 갯수를 세면 될것이라고 생각했는데, 비효율적이라고 판단했다.</li>
  <li>다시 생각해보니 인접행렬을 따라 BFS 했을 때, 만들어지는 sub-graph들의 갯수를 세면 되는 문제였다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이 전에도 풀어봤던 문제였지만, 다시 풀 때접근법부터 생각하고 풀어보니 빠른 시간 안에 풀 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[43162. 네트워크 / c++ / level3 / 12분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 14일차 TIL - 43163 단어 변환</title><link href="https://sho1007.github.io/programmers/43163/" rel="alternate" type="text/html" title="99클럽 코테 스터디 14일차 TIL - 43163 단어 변환" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43163</id><content type="html" xml:base="https://sho1007.github.io/programmers/43163/"><![CDATA[<h1 id="43163-단어-변환--c--level3--18분">43163. 단어 변환 / c++ / level3 / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43163.%E2%80%85%EB%8B%A8%EC%96%B4%E2%80%85%EB%B3%80%ED%99%98"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--dfs">그래프 탐색 / DFS</h3>
<ol>
  <li>두 단어가 하나의 문자만 다른 경우 해당 단어로 바꿀 수 있다면, 두 단어를 이어진 두 노드라고 볼 수 있다.</li>
  <li>단어를 순회하면서 해당 단어와 한 문자만 다른 단어를 찾아 unordered_map&lt;string, vector<string>&gt; adjMap 에 넣는다.</string></li>
  <li>이 때 주의할 점은, 시작 단어는 words에 포함되어 있지 않기 때문에, wordgs 순회 전 begin도 words에 넣어줘야 한다.</li>
  <li>그리고 DFS에 사용하기 위한 방문 기록용 unordered_map&lt;string, boo&gt; vistedMap을 선언하고, words를 순회할 때 모든 단어를 false로 초기화 해준다.</li>
  <li>adjMap 초기화가 끝나면 begin을 시작점으로 해서 DFS를 진행</li>
  <li>DFS의 매개변수인 vector<string>&amp; path 의 마지막 단어가 target일 경우 path.size() 가 answer 보다 작다면 answer 를 초기화 해준다. (이 때 사용한 answer는 미리 MAX값으로 초기화)</string></li>
  <li>DFS가 끝나고 answer 가 여전히 MAX이면 0을 반환, 아니라면 answer를 반환한다. (나는 DFS를 위해 path에 시작값으로 begin을 넣어놨었기 때문에, answer-1을 반환했다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>DFS를 사용하면 백트래킹을 활용하여 경로탐색이 용이하다는 점을 다시금 느낄 수 있었다.</li>
  <li>begin을 미리 words에 넣어서 순회를 돌리는 것이 좋았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="DFS" /><summary type="html"><![CDATA[43163. 단어 변환 / c++ / level3 / 18분]]></summary></entry><entry><title type="html">Stable &amp;amp; Unstable Sort</title><link href="https://sho1007.github.io/datastructure/Stable&UnStableSort/" rel="alternate" type="text/html" title="Stable &amp;amp; Unstable Sort" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/datastructure/Stable&amp;UnStableSort</id><content type="html" xml:base="https://sho1007.github.io/datastructure/Stable&amp;UnStableSort/"><![CDATA[<h1 id="stable--unstalbe-sort">Stable &amp; Unstalbe Sort</h1>

<p>정렬 시 같은 key 값을 가지는 원소들의 순서가 유지된다면 stable sort이고, 순서가 유지되지 않는다면 unstable sort이다.</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;DataStructure&quot;]" /><category term="Sort" /><category term="DataStructure" /><summary type="html"><![CDATA[Stable &amp; Unstalbe Sort]]></summary></entry><entry><title type="html">운영체제 시작하기</title><link href="https://sho1007.github.io/operatingsystem/OperatingSystem/" rel="alternate" type="text/html" title="운영체제 시작하기" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/OperatingSystem</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/OperatingSystem/"><![CDATA[<h1 id="운영체제란">운영체제란</h1>

<p>실행할 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램</p>

<h1 id="커널-영역--사용자-영역">커널 영역 / 사용자 영역</h1>
<p><strong>커널 영역</strong> : 운영체제가 적재되는 메모리 공간 <br />
<strong>사용자 영역</strong> : 사용자가 이용하는 응용 프로그램이 적재될 커널 영역 이외의 공간</p>

<h1 id="운영체제의-핵심-서비스">운영체제의 핵심 서비스</h1>
<h2 id="프로세스-관리">프로세스 관리</h2>
<p>실행 중인 프로그램을 프로세스라고 하는데, 일반적으로 CPU는 한번에 한 프로세스만 처리할 수 있으므로 운영체제가 프로세스들을 전환해가며 CPU를 사용하게 한다. 이 때 <strong>프로세스 동기화</strong>가 필수적이고, <strong>교착 상태</strong>를 해결해야 한다.</p>
<h2 id="자원-접근-및-할당">자원 접근 및 할당</h2>
<h3 id="cpu">CPU</h3>
<p>일반적으로 메모리에 여러 프로세스가 적재되고, 하나의 CPU에는 한번에 하나의 프로세스만 실행되므로, 다른 프로세스들은 CPU를 사용할 동안 기다려야 하는데, 운영체제에서 이를 관리하는 것을 <strong>CPU 스케쥴링</strong>이라고 한다.</p>
<h3 id="메모리">메모리</h3>
<p>메모리에 적재된 프로세스들은 크기도, 주소도 다 다르다.
운영체제는 새로운 프로세스가 적재될 때의 주소를 결정해야 하고, 메모리 공간도 관리해야 한다.</p>
<h3 id="입출력장치">입출력장치</h3>
<p>인터럽트 서비스 루틴은 운영체제의 기능으로 커널 영역에 있다. 입출력장치가 발생시키는 하드웨어 인터럽트도 마찬가지이다.</p>
<h2 id="파일-시스템">파일 시스템</h2>
<p>파일 열기, 닫기, 생성, 삭제, 디렉터리 관리도 운영체제가 담당한다.</p>

<blockquote>
  <p>가상 머신은 응용 프로그램으로 사용자 모드로 실행된다. 하지만 가상 머신에 운영체제가 존재할 때, 이 운영체제는 어떻게 커널 영역의 서비스를 제공받을 수 있을까? -&gt; 가상화를 지원하는 CPU는 커널 모드와 사용자 모드 이외에 <strong>하이퍼바이저 모드</strong>를 따로 둔다. 가상 머신 위에서 작동하는 응용 프로그램들은 하이퍼바이저모드로써 운영체제 서비스를 받을 수 있다.</p>
</blockquote>

<h1 id="커널">커널</h1>
<p>운영체제의 핵심 서비스를 담당하는 부분을 커널이라고 하는데, 운영체제는 커널 이외에도 사용자 인터페이스 (GUI, CLI)도 제공한다.</p>

<h1 id="이중모드">이중모드</h1>
<p>이중모드란, CPU가 명령어를 실행하는 모드를 <strong>사용자 모드</strong>와 <strong>커널 모드</strong>로 구분하는 방식이다.</p>
<h2 id="사용-이유">사용 이유</h2>
<p>운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하고, 오직 자신을 통해서만 접근하도록 하여 자원을 보호한다. <br />
이러한 운영체제의 문지기 역할은 <strong>이중 모드</strong> 를 사용하여 구현된다.</p>
<h2 id="사용자-모드">사용자 모드</h2>
<p>운영체제의 서비스를 제공받을 수 없는 실행 모드 (슈퍼바이저 플래그 off)</p>
<h2 id="커널-모드">커널 모드</h2>
<p>운영체제 서비스를 제공받을 수 있는 실행 모드 (슈퍼바이저 플래그 on)</p>
<h2 id="시스템-호출">시스템 호출</h2>
<p>사용자 모드에서 실행되는 프로그램이 자원에 접근하기 위해 운영체제 서비스를 제공받으려면 커널 모드로 전환되어야 하는데, 이 때 <strong>시스템 호출</strong>을 통해 커널 모드로 전환할 수 있다.</p>
<blockquote>
  <p>시스템 호출도 일종의 소프트웨어 인터럽트이다.</p>
  <ol>
    <li>시스템 호출 실행 (사용자 모드 -&gt; 커널 모드)</li>
    <li>운영체제 코드 실행 (커널 모드)</li>
    <li>시스템 호출로부터 복귀 (커널 모드 -&gt; 사용자 모드)</li>
  </ol>
</blockquote>

<p>응용 프로그램은 실행 도중 빈번하게 시스템 호출을 발생시키고, 사용자 모드와 커널 모드를 오가며 실행된다.</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[운영체제란]]></summary></entry><entry><title type="html">Uniform Initialization</title><link href="https://sho1007.github.io/c++/UniformInitialization/" rel="alternate" type="text/html" title="Uniform Initialization" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/c++/UniformInitialization</id><content type="html" xml:base="https://sho1007.github.io/c++/UniformInitialization/"><![CDATA[<h1 id="uniform-initialization">Uniform Initialization</h1>
<p>유니폼 초기화 혹은 균일 초기화라고 부른다.</p>
<h2 id="생기게된-계기">생기게된 계기</h2>
<p>C++ 에서 변수를 초기화 할 때, 아래와 같은 실수를 저지른다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">a</span><span class="p">();</span>
    <span class="n">MyClass</span> <span class="nf">b</span><span class="p">();</span>
</code></pre></div></div>
<p>이 때, a와 b는 작동 방식이 다르다. a는 int자료형을 Direct Initialization한 것이고, b는 MyClass라고 하는 자료형을 반환하는 함수를 정의한 것 이기 때문에, 생성자가 호줄되지 않는다. (전방선언)</p>

<blockquote>
  <p>함수의 정의처럼 보이는 것들은 모두 함수의 정의로 해석</p>
</blockquote>

<p>다른 예로는,</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="nf">b</span><span class="p">(</span><span class="n">A</span><span class="p">());</span>
</code></pre></div></div>
<p>의 경우, 인자값을 받지 않고 A를 return 하는 함수를, 다시 인자값으로 받아 B를 return하는 함수 b인 것이다. (우리는 class A의 기본 생성자로 생성된 객체 A를 인자값으로 받는 B 생성자로 b를 생성했다고 생각했지만)</p>
<blockquote>
  <p>문제는, 소괄호 ()가 함수를 인자를 정의할 때도, 객체의 생성자를 호출할 때도 사용되기 때문</p>
</blockquote>

<p>그래서 이런 문제를 해결하고자 나온 것이, {}를 사용하는 Uniform Initialization이다.</p>

<h2 id="uniform-initialization-의-특징">Uniform Initialization 의 특징</h2>

<h3 id="생성과-생성의-차이점">()생성과 {}생성의 차이점</h3>
<p>데이터 손실이 있는 형 변환 (Narro Conversion) 의 가능 여부</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">A</span><span class="p">(</span><span class="mf">3.5</span><span class="n">f</span><span class="p">)</span> <span class="c1">// Narrow-Conversion 가능</span>
    <span class="kt">int</span> <span class="n">B</span><span class="p">{</span><span class="mf">3.</span><span class="n">f</span><span class="p">}</span> <span class="c1">// Narro-Conversion 불가 -&gt; Error 발생</span>
</code></pre></div></div>

<h3 id="반환-할-때의-특징">반환 할 때의 특징</h3>
<p>Uniform Initialization 으로 반환할 때에는, 생성할 객체의 타입을 명시하지 않아도 된다는 특징이 있다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="n">A</span> <span class="n">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">};</span>    <span class="c1">// A(3, 3.5) 와 동일</span>
<span class="p">}</span>
</code></pre></div></div>
<p>이 경우 컴파일러가 함수의 반환값을 보고 추론하여 A의 생성자를 호출한다.</p>
<h3 id="initializer_list-초기화자-리스트">Initializer_list (초기화자 리스트)</h3>
<p>배열을 초기화할 때, {}를 사용할 수 있다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div></div>
<p>Uniform Initialization을 사용하면, 객체도 이처럼 초기화할 수 있는데, 이 때 Initializer_list 가 사용된다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">A</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Todo : Use *iter</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="p">}</span>

</code></pre></div></div>
<h3 id="initializer_list-사용시-주의할-점">Initializer_list 사용시 주의할 점</h3>
<ul>
  <li>()을 사용해 생성하면 initializer_list 를 사용할 수 없다.</li>
  <li>원소의 갯수가 1개일 때 주의할점
    <ul>
      <li>벡터 생성 시
        <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 원소 10개짜리 벡터 생성</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="c1">// 10을 원소로 가지는 1개짜리 벡터 생성</span>
  <span class="c1">// vector&lt;int&gt; b = {10} 와 동일;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>initializer_list 가 최우선으로 고려되어 생기는 문제점
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="nl">public:</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"일반 생성자! "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">A</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"초기화자 사용 생성자! "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>  <span class="c1">// Good</span>
  <span class="n">A</span> <span class="n">b</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">};</span>  <span class="c1">// Bad! -&gt; initializer_list&lt;int&gt; 인데, 1.5인 double 이 들어왔음 -&gt; Narrow-Conversion이 안되므로 error 발생</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>auto를 사용하여 생기는 문제점
    <ul>
      <li>원소의 갯수에 따른 문제(해결됨)
        <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>          <span class="c1">//std::initializer_list&lt;int&gt;</span>
  <span class="k">auto</span> <span class="n">b</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>    <span class="c1">//std::initializer_list&lt;int&gt;</span>
  <span class="c1">// 즉 둘 다 배열로 간주된다는 점</span>
</code></pre></div>        </div>
        <ul>
          <li>하지만 이는 원소의 갯수가 1개이나, 2개 이상이냐로 나뉘어 해결됨
            <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>          <span class="c1">// 그냥 int</span>
  <span class="k">auto</span> <span class="n">b</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>    <span class="c1">//std::initializer_list&lt;int&gt;</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>문자열에 대한 문제
        <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">,</span> <span class="s">"def"</span><span class="p">,</span> <span class="s">"ghi"</span><span class="p">};</span>
  <span class="c1">//std::initilizer_list&lt;string&gt;이 아닌 std::initilizer_list&lt;const char*&gt;이 됨</span>

  <span class="c1">// 이를 해결하기 위해서는 C++14에서 추가된 리터럴 연산자를 사용</span>

  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">stringList</span> <span class="o">=</span> <span class="p">{</span><span class="s">"abc"</span><span class="n">s</span><span class="p">,</span> <span class="s">"def"</span><span class="n">s</span><span class="p">,</span> <span class="s">"ghi"</span><span class="n">s</span><span class="p">};</span>
  <span class="c1">// 이러면 std::initilaizer_list&lt;string&gt;으로 처리됨</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h1 id="reference">Reference</h1>
<p><a href="https://modoocode.com/286">모두의 코드</a></p>]]></content><author><name>Sho1007</name></author><category term="[&quot;C++&quot;]" /><category term="C++" /><category term="Initialization" /><summary type="html"><![CDATA[Uniform Initialization 유니폼 초기화 혹은 균일 초기화라고 부른다. 생기게된 계기 C++ 에서 변수를 초기화 할 때, 아래와 같은 실수를 저지른다. int a(); MyClass b(); 이 때, a와 b는 작동 방식이 다르다. a는 int자료형을 Direct Initialization한 것이고, b는 MyClass라고 하는 자료형을 반환하는 함수를 정의한 것 이기 때문에, 생성자가 호줄되지 않는다. (전방선언)]]></summary></entry><entry><title type="html">99클럽 코테 스터디 13일차 TIL - 87964 아이템 줍기</title><link href="https://sho1007.github.io/programmers/87964/" rel="alternate" type="text/html" title="99클럽 코테 스터디 13일차 TIL - 87964 아이템 줍기" /><published>2024-06-01T00:00:00+00:00</published><updated>2024-06-01T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/87964</id><content type="html" xml:base="https://sho1007.github.io/programmers/87964/"><![CDATA[<h1 id="87964-아이템-줍기--c--level3--1시간">87964. 아이템 줍기 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs">그래프 탐색 / BFS</h3>
<ol>
  <li>점이 겹치는 뭉치는 문제를 해결하기 위해 사각형의 각 좌표를 * 2 해줌</li>
  <li>사각형을 돌면서 2차원 bool 배열 map에 테두리를 true 표시해줌</li>
  <li>다시 사각형을 돌면서 사각형 안쪽을 false로 바꿔줌</li>
  <li>해당 map을 기준으로 BFS 진행 (이 때, 시작 좌표도 각각 *2)</li>
  <li>마지막으로 item 좌표 * 2 한 위치의 비용값의 절반을 return</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>사각형들의 테두리를 잇는 부분은 크게 어렵지 않았다.</li>
  <li>그런데 좌표가 1단위로 나눠져서, 분명 이어져있지 않은 길인데도 bfs할 때 이어진 것처럼 작동하는 문제가 있었다.</li>
  <li>예전에 이걸 *2해서 (지도가 커지면 좌표가 더 세밀해지는 느낌) 해결했던 경험이 있었는데, 이걸 다시 생각해내기까지가 정말 오래 걸렸다.</li>
  <li>다음에는 지금처럼 좌표값을 더 세분화해야 할 때, * 2 하는 방법을 바로 기억해낼 수 있도록 해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[87964. 아이템 줍기 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 12일차 TIL - 43164 여행경로</title><link href="https://sho1007.github.io/programmers/43164/" rel="alternate" type="text/html" title="99클럽 코테 스터디 12일차 TIL - 43164 여행경로" /><published>2024-05-31T00:00:00+00:00</published><updated>2024-05-31T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43164</id><content type="html" xml:base="https://sho1007.github.io/programmers/43164/"><![CDATA[<h1 id="43164-여행경로--c--level3--1시간">43164. 여행경로 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43164.%E2%80%85%EC%97%AC%ED%96%89%EA%B2%BD%EB%A1%9C"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs--구현--백트래킹">그래프 탐색 / BFS / 구현 / 백트래킹</h3>
<ol>
  <li>우선 tickets 을 순회 하면서 인접리스트인 adjMap (unordered_map&lt;string,vector<string>&gt;) 을 준비</string></li>
  <li>여행 경로를 담을 vector<string> currentPath를 선언</string></li>
  <li>currentPath에 출발지인 ICN을 삽입</li>
  <li>adjMap에서 ICN을 출발지로 하는 인접리스트를 돌면서 백트래킹 시작</li>
  <li>currentPath.back (마지막 여행지) 를 출발점으로 하는 인접행렬을 순회하며 다시 백트래킹 반복</li>
  <li>백트래킹 도중 currentPath가 ticket + 1 (출발지인 ICN까지 포함하므로) 가 되면, vector<stirng> 인 answer와 비교하여, 사전순으로 앞서있는지 체크</stirng></li>
  <li>currentPath 가 answer 보다 사전순으로 앞서있다면 answer 갱신</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>공항의 수가 최대 10’000개였기 때문에 백트래킹 (재귀) 은 과하게 depth가 깊어지면 stack overflow 가 날 수 있다고 걱정했다.</li>
  <li>그래서 처음엔 백트래킹을 사용하지 않고 BFS를 써서 어떻게든 풀어보려고 온몸비틀기를 했는데, 출발지 + 도착지를 한 string으로 묶어서 순서를 매겼더니, 중복되는 티켓을 처리하지 못하는 문제가 생겼다.</li>
  <li>그래서 밑져야 본전이라고 백트래킹으로 풀어봤더니 너무 잘 풀리고, 시간도 2번에서 풀었던 것보다 1ms 더 빨랐다.</li>
  <li>항상 가장 간단한 방법부터 시도해봐야한다고 머리로는 알고 있는데, 시간 제한이 있다고 생각하면 그게 잘 안되는 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><category term="BackTracking" /><summary type="html"><![CDATA[43164. 여행경로 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 11일차 TIL - 84021 퍼즐 조각 채우기</title><link href="https://sho1007.github.io/programmers/84021/" rel="alternate" type="text/html" title="99클럽 코테 스터디 11일차 TIL - 84021 퍼즐 조각 채우기" /><published>2024-05-30T00:00:00+00:00</published><updated>2024-05-30T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/84021</id><content type="html" xml:base="https://sho1007.github.io/programmers/84021/"><![CDATA[<h1 id="84021-퍼즐-조각-채우기--c--level3--1시간">84021. 퍼즐 조각 채우기 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/84021.%E2%80%85%ED%8D%BC%EC%A6%90%E2%80%85%EC%A1%B0%EA%B0%81%E2%80%85%EC%B1%84%EC%9A%B0%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs--구현">그래프 탐색 / BFS / 구현</h3>
<ol>
  <li>먼저 table 에서 블록(위치값의 벡터)들을 BFS 로 구한다.</li>
  <li>table을 탐색할 때, 좌상단부터 우하단 방향으로 탐색하기에, 블록의 첫 번째 부분은 항상 가장 위에 있고, 그 중 가장 왼쪽에 위치한다.</li>
  <li>구한 블록을 첫 번째 부분 기준으로 다시 표현한다. (모든 칸에서 첫 번째 칸의 위치를 빼주면 됨, 이 때 첫 번째 부분이 1에서 설명한 것처럼 가장 작으므로 모든 값은 양수로 표시됨)</li>
  <li>블록을 총 3번 회전시켜서 4개의 형태를 모두 구한다. (이 때는 블록의 x,y 좌표를 바꾸고, y 좌표에 -1을 곱해줌)</li>
  <li>해당 블록들을 다시 정렬한다. (4번으로 인해 정렬이 틀어졌기 때문)</li>
  <li>블록 구하기가 끝나면 이제 board에서 빈칸을 찾는다. (블록과 마찬가지로 위치값의 벡터로 구함)</li>
  <li>빈칸이 구해지면, 3번에서처럼 빈칸을 첫 번째 부분을 기준으로 다시 표현한다.</li>
  <li>그 후 빈칸을 정렬한다.</li>
  <li>정렬된 빈칸을 블록 벡터를 순회하면서 맞는 블록이 있는지 찾는다. (이 때, usedBlock 이라는 bool 벡터를 하나 선언해서 블록의 재사용을 막는다. 또한 한 블록은 4개의 회전 형태를 모두 고려한다.)
    <ol>
      <li>맞는 블록이 있다면, usedBlock 에 해당 블록을 체크해주고, 블록의 칸 갯수를 answer에 더한다.</li>
      <li>맞는 블록이 없다면, BFS에서 사용한 방문 정보를 초기화시킨다. (해당 빈칸을 다른 부분에서 다시 찾기 위함)</li>
    </ol>
  </li>
  <li>위의 과정으로 board를 모두 탐색하면 answer를 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이미 풀어봤던 문제임에도 시간이 꽤 걸렸다. 틀을 잡는건 금방 했는데, 블록을 탐색한 후 정렬을 언제 해줘야하는지가 많이 헷갈렸다. 문제를 정확하게 먼저 분석하고 풀었어야했는데, 또 바로 푸는 습관이 나와서 더 오래 걸렸던 것 같다.</li>
  <li>게더타운에서 풀기 위해 밤 늦게 풀었더니 졸려서 머리가 더 안돌아갔던 것 같다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[84021. 퍼즐 조각 채우기 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 10일차 TIL - 86971 전력망을 둘로 나누기</title><link href="https://sho1007.github.io/programmers/86971/" rel="alternate" type="text/html" title="99클럽 코테 스터디 10일차 TIL - 86971 전력망을 둘로 나누기" /><published>2024-05-29T00:00:00+00:00</published><updated>2024-05-29T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/86971</id><content type="html" xml:base="https://sho1007.github.io/programmers/86971/"><![CDATA[<h1 id="86971-전력망을-둘로-나누기--c--level2--18분">86971. 전력망을 둘로 나누기 / c++ / level2 / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/86971.%E2%80%85%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84%E2%80%85%EB%91%98%EB%A1%9C%E2%80%85%EB%82%98%EB%88%84%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="완전-탐색">완전 탐색</h3>
<ol>
  <li>노드가 100개이므로 인접행렬을 만들어도 100 * 100 개, 메모리 크기는 40KB(정수의 경우)가 되므로 충분했다.</li>
  <li>wires를 돌면서 두 노드를 모두 연결해줬다. (양방향 그래프)</li>
  <li>다시 wires를 돌면서, 이번엔 두 노드를 모두 끊어준 뒤, 각 노드를 시작점으로 하여 DFS를 계산해줬다.</li>
  <li>그렇게 나온 두 수 (두 전력망이 가지고 있는 송전탑의 개수)를 뺀 값의 절대값을 미리 최대값 (101)개를 취한 answer와 비교하여 더 작다면 answer를 갱신해줬다.</li>
  <li>answer를 반환</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>DFS를 맨 처음 시작할 때, 나눠진 두 노드의 방문 처리를 안해줬더니 테스트 케이스 1번이 틀렸었다. 사소해서 놓치기 쉬운 부분이므로 다음부터는 꼭 집고 넘어가야겠다.</li>
  <li>인접행렬에 비용이 들어가는게 아니라 연결 되어있는지 여부가 들어가므로 bool로 선언했다면 메모리를 아낄 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Brute Force" /><summary type="html"><![CDATA[86971. 전력망을 둘로 나누기 / c++ / level2 / 18분]]></summary></entry></feed>