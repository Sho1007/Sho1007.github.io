<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://sho1007.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sho1007.github.io/" rel="alternate" type="text/html" /><updated>2024-06-09T15:34:35+00:00</updated><id>https://sho1007.github.io/feed.xml</id><title type="html">Today I Learned</title><subtitle>내가 공부한 것들을 기록하는 공간</subtitle><author><name>Sho1007</name></author><entry><title type="html">99클럽 코테 스터디 21일차 TIL - 42897 도둑질</title><link href="https://sho1007.github.io/programmers/42897/" rel="alternate" type="text/html" title="99클럽 코테 스터디 21일차 TIL - 42897 도둑질" /><published>2024-06-09T00:00:00+00:00</published><updated>2024-06-09T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42897</id><content type="html" xml:base="https://sho1007.github.io/programmers/42897/"><![CDATA[<h1 id="42897-도둑질--c--level4--1시간">42897. 도둑질 / c++ / level4 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/4/42897.%E2%80%85%EB%8F%84%EB%91%91%EC%A7%88"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>이런 식의 문제는 보통, 현재 칸에서 행동함 = 전 칸의 행동 안한 결과 + 현재 칸의 값 으로 풀 수 있다.</li>
  <li>다만 이 문제의 경우 순환 배열이어서 시작 원소와 마지막 원소 역시 위의 조건을 만족해야 했다.</li>
  <li>고민 끝에 내가 생각한 방법은, 배열을 아래처럼 총 4개 만들어주는 것이었다.
    <ol>
      <li>현재 집을 도둑질 함 (시작 지점을 도둑질한 경우)</li>
      <li>현재 집을 도둑질 하지 않음 (시작 지점을 도둑질한 경우)</li>
      <li>현재 집을 도둑질 함 (시작 지점을 도둑질하지 않은 경우)</li>
      <li>현재 집을 도둑질 하지 않음 (시작 지점을 도둑질하지 않은 경우)</li>
    </ol>
  </li>
  <li>이렇게 한 뒤, 맨 마지막 집 전까지만, 배열을 순회하며 dp값을 저장해주고, <br />
 맨 마지막 집의 경우 3-3번에만 값을 더 해주었다. (3-1의 경우 시작 지점을 도둑질 했기 때문에 마지막 집을 도둑질할 수 없다.)</li>
  <li>그 후, 나온 값들 중 가장 큰 값을 비교하여 반환</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>확실히 level4 문제들은 난이도가 있다고 생각이 들었다.</li>
  <li>다만 이 문제의 경우 이전에도 접해본 dp문제 유형이었는데, 거기에 시작 지점의 값도 추가로 신경써줘야하는 응용 문제여서 생각만 잘 했다면 충분히 빨리 풀 수 있었는데, 이건 좀 더 반복적으로 연습을 해야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[42897. 도둑질 / c++ / level4 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 20일차 TIL - 1843 사칙연산</title><link href="https://sho1007.github.io/programmers/1843/" rel="alternate" type="text/html" title="99클럽 코테 스터디 20일차 TIL - 1843 사칙연산" /><published>2024-06-08T00:00:00+00:00</published><updated>2024-06-08T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/1843</id><content type="html" xml:base="https://sho1007.github.io/programmers/1843/"><![CDATA[<h1 id="1843-사칙연산--c--level4--1시간">1843. 사칙연산 / c++ / level4 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/4/1843.%E2%80%85%EC%82%AC%EC%B9%99%EC%97%B0%EC%82%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>식을 적절히 괄호로 감싸서 계산 순서를 정했을 때 나올 수 있는 최대 값을 구하는 문제였다.</li>
  <li>dp라는건 결국 이전 값을 다음 계산에 활용할 수 있다는 것이므로, 이걸 어떻게 문제에 대입할 수 있을지 생각해봤다.</li>
  <li>연산자 하나에 대해 양쪽 옆에 새로운 부분식이 생긴다고 했을 때, 다시 그 작은 식을 재귀적으로 해결할 수 있을거라고 생각했다.</li>
  <li>그 부분식의 계산값을 저장해두면, 매번 계산하지 않아도 되므로, 이 방법으로 풀었더니 통과했다. (이 때, 포인트는 부분식의 최대값과 최소값을 동시에 저장해서, 연산자가 - 일 때 오른쪽 부분식의 최대값과 최소값 중 어떤걸 활용하는지를 정하는 것이었다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>진짜 어려웠다. level4 문제를 정말 오랜만에 풀어봤다. 그래도 정답을 찾아보지 않고 직접 생각해서 풀어서 성취감을 느낄 수 있었다.</li>
  <li>마지막에 unordered_set으로도 시간초과가 나서 공간복잡도를 생각한 뒤, 2차원 배열로 바꾼게 효과적이었다. unordered_set 이 hash를 사용해서 일반 map보다 검색 속도가 빠르다고 하더라도, 굳이 int,int를 string으로 바꾸기보다, 2차원 배열로 직접 접근하는게 훨씬 빨랐다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[1843. 사칙연산 / c++ / level4 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 19일차 TIL - 43105 정수 삼각형</title><link href="https://sho1007.github.io/programmers/43105/" rel="alternate" type="text/html" title="99클럽 코테 스터디 19일차 TIL - 43105 정수 삼각형" /><published>2024-06-07T00:00:00+00:00</published><updated>2024-06-07T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43105</id><content type="html" xml:base="https://sho1007.github.io/programmers/43105/"><![CDATA[<h1 id="43105-정수-삼각형--c--level3--26분">43105. 정수 삼각형 / c++ / level3 / 26분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43105.%E2%80%85%EC%A0%95%EC%88%98%E2%80%85%EC%82%BC%EA%B0%81%ED%98%95"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>위에서 아래로 내려간다면, 어떤 루트를 결정해야 큰 값이 나올지 모를 수 있지만, 반대로 아래에서 위의 값을 고른다면, 무조건 둘 중 큰 값을 고르기만 하면 된다.</li>
  <li>해당 식을 DP라는 함수로 만들어서 저장 (이 때, 인자값으로 row, col 변수를 넘겨주는데, 만약 삼각형의 범위를 넘어간 값이라면 0을 리턴)</li>
  <li>맨 아랫줄의 모든 칸에 대해 DP를 수행하면, 순차적으로 위로 타고 올라가며 결국 모든 칸의 계산값이 구해지게 된다.</li>
  <li>따라서 맨 아랫줄의 계산 값 중, 가장 큰 값을 고르면 그 값이 나올 수 있는 가장 큰 값이다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>예전에 풀었던 문제라 로직 자체는 쉽게 생각해낼 수 있었는데, 배열로 선언하여 아랫줄에서 윗줄을 검사할 때는 실패가 떴었다. (아마 내가 구현을 잘못하거나, 예외처리를 빠트린게 있었겠지..?)</li>
  <li>다시 처음부터 만들 때, DP를 함수로 빼고, dp[row][col]이 계산되어 있지 않다면, 윗줄의 왼쪽 값, 오른쪽 값을 다시 재귀적으로  DP 함수를 호출하도록 구현했더니 통과했다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[43105. 정수 삼각형 / c++ / level3 / 26분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 18일차 TIL - 42895 N으로 표현</title><link href="https://sho1007.github.io/programmers/42895/" rel="alternate" type="text/html" title="99클럽 코테 스터디 18일차 TIL - 42895 N으로 표현" /><published>2024-06-06T00:00:00+00:00</published><updated>2024-06-06T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42895</id><content type="html" xml:base="https://sho1007.github.io/programmers/42895/"><![CDATA[<h1 id="42895-n으로-표현--c--level3--1시간">42895. N으로 표현 / c++ / level3 / 1시간+</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42895.%E2%80%85N%EC%9C%BC%EB%A1%9C%E2%80%85%ED%91%9C%ED%98%84"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="동적-계획법">동적 계획법</h3>
<ol>
  <li>사칙 연산으로 이루어져 있다는 점에서 착안</li>
  <li>N이 들어간 횟수를 i라고 했을 때, i + 1은 결국 1 ~ (i-1)까지의 사칙 연산으로 이루어져 있다고 판단</li>
  <li>dp[i]는 N이 i번 들어갔을 때 만들어질 수 있는 수들의 배열 (여기선 중복을 방지하기 위해 unordered_set을 사용)</li>
  <li>i 를 1부터 8까지 증가시켜가면서, i를 이룰 수 있는 경우의 수 (i가 4라면 1 + 3 부터 3 + 1) 까지의 두 수 j, k를 인덱스로 하는 dp[j], dp[k]를 가져와서, 거기에 해당하는 모든 수의 사칙 연산을 다시 dp[i]에 삽입 (이 때, 0보다 클 경우에만 삽입)</li>
  <li>그리고 여기서부터는 막혀서 결국 다른 코드를 보고 깨달았음</li>
  <li>기존엔 32,001 보다 작아야 dp[i]에 삽입했었는데, 그건 단지 number가 32’000이하라는 소리이고, 계산 과정이 32’000보다 작아야하는게 아니라서, 오히려 32’001보다 작을 때만 dp[i]에 삽입하는 것이 오류였음. (그래서 그 부분을 삭제)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>큰 틀의 로직은 생각을 했는데, 계산 과정에서 32’000보다 큰 수가 들어갈 수 있다는 점을 놓쳐서 그것 때문에 너무 많은 시간을 허비한 것 같다. 항상 예외처리에 많은 시간을 투자하고 있는데, 어떨 때는 그게 불필요한 경우일 수도 있다는 걸 생각해봐야겠다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="DynamicProgramming" /><summary type="html"><![CDATA[42895. N으로 표현 / c++ / level3 / 1시간+]]></summary></entry><entry><title type="html">99클럽 코테 스터디 17일차 TIL - 42884 단속카메라</title><link href="https://sho1007.github.io/programmers/42884/" rel="alternate" type="text/html" title="99클럽 코테 스터디 17일차 TIL - 42884 단속카메라" /><published>2024-06-05T00:00:00+00:00</published><updated>2024-06-05T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42884</id><content type="html" xml:base="https://sho1007.github.io/programmers/42884/"><![CDATA[<h1 id="42884-단속카메라--c--level3--32분">42884. 단속카메라 / c++ / level3 / 32분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42884.%E2%80%85%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그리디--정렬--라인-스위핑">그리디 / 정렬 / 라인 스위핑</h3>
<ol>
  <li>이런 문제는 일단 시작점과 끝점 양쪽을 기준으로 빠른 순으로 정렬한다.</li>
  <li>그러면 모든 차(선분)이 겹치거나 겹치지 않는 형태로 일렬로 정렬이 된다.</li>
  <li>정렬된 벡터를 순회하면서, 만약 두 차의 경로가 겹친다면, 겹치는 부분으로 합친다. <br />
 ([-20, -15], [-18, -13] 인 두 차량의 경우 [-18, -15]로 합친다.)</li>
  <li>그러다 겹치지 않는 차량이 나오면, 이전까지의 겹친 차량들은 카메라가 필요하므로 answer++</li>
  <li>그렇게 모든 차량을 순회하여 나온 answer를 반환한다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>처음엔 두 차량의 경로를 비교해서 겹친다면 합치지 않고 경로의 끝 지점을 두 경로 중 큰 값으로 정했었는데, 이렇게 되면, 1[ 2[ ] 3[O] ] 이렇게 1번 경로가 2번 경로보다 경우, 3번을 포함하는 부분에 카메라를 설치하게 되면, 1,3번은 영향을 받지만, 2번은 놓치게 된다. 그래서 겹치는 부분이 존재한다면 무조건 [두 차의 경로의 시작 값 중 큰 수] 부터 [두 차의 경로의 끝 값 중 작으 수] 로 경로를 합쳐야했다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="Greedy" /><category term="Sort" /><category term="LineSweeping" /><summary type="html"><![CDATA[42884. 단속카메라 / c++ / level3 / 32분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 16일차 TIL - 42861 섬 연결하기</title><link href="https://sho1007.github.io/programmers/42861/" rel="alternate" type="text/html" title="99클럽 코테 스터디 16일차 TIL - 42861 섬 연결하기" /><published>2024-06-04T00:00:00+00:00</published><updated>2024-06-04T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/42861</id><content type="html" xml:base="https://sho1007.github.io/programmers/42861/"><![CDATA[<h1 id="42861-섬-연결하기--c--level3--7분">42861. 섬 연결하기 / c++ / level3 / 7분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/42861.%E2%80%85%EC%84%AC%E2%80%85%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그리디--그래프--union-find--크루스칼">그리디 / 그래프 / Union-Find / 크루스칼</h3>
<ol>
  <li>크루스칼 알고리즘을 이용하여 최소 신장 트리를 만들었을 때의 비용을 구하는 문제였다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>MST와 Union-Find 를 알고 있다면 쉽게 풀 수 있는 문제였다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="Greedy" /><category term="UnionFind" /><category term="Kruskal" /><summary type="html"><![CDATA[42861. 섬 연결하기 / c++ / level3 / 7분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 15일차 TIL - 43162 네트워크</title><link href="https://sho1007.github.io/programmers/43162/" rel="alternate" type="text/html" title="99클럽 코테 스터디 15일차 TIL - 43162 네트워크" /><published>2024-06-03T00:00:00+00:00</published><updated>2024-06-03T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43162</id><content type="html" xml:base="https://sho1007.github.io/programmers/43162/"><![CDATA[<h1 id="43162-네트워크--c--level3--12분">43162. 네트워크 / c++ / level3 / 12분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43162.%E2%80%85%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--bfs">그래프 탐색 / BFS</h3>
<ol>
  <li>처음엔 Union-Find 알고리즘을 활용하여, 부모가 다른 노드의 갯수를 세면 될것이라고 생각했는데, 비효율적이라고 판단했다.</li>
  <li>다시 생각해보니 인접행렬을 따라 BFS 했을 때, 만들어지는 sub-graph들의 갯수를 세면 되는 문제였다.</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>이 전에도 풀어봤던 문제였지만, 다시 풀 때접근법부터 생각하고 풀어보니 빠른 시간 안에 풀 수 있었다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[43162. 네트워크 / c++ / level3 / 12분]]></summary></entry><entry><title type="html">99클럽 코테 스터디 14일차 TIL - 43163 단어 변환</title><link href="https://sho1007.github.io/programmers/43163/" rel="alternate" type="text/html" title="99클럽 코테 스터디 14일차 TIL - 43163 단어 변환" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/programmers/43163</id><content type="html" xml:base="https://sho1007.github.io/programmers/43163/"><![CDATA[<h1 id="43163-단어-변환--c--level3--18분">43163. 단어 변환 / c++ / level3 / 18분</h1>

<h2 id="문제-및-코드">문제 및 코드</h2>

<p><a href="https://github.com/Sho1007/Algorithm/tree/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/43163.%E2%80%85%EB%8B%A8%EC%96%B4%E2%80%85%EB%B3%80%ED%99%98"><img src="https://github.com/Sho1007/sho1007.github.io/blob/main/assets/images/github-logo-vector.png?raw=true" width="200" height="100" /></a></p>

<h2 id="접근-방식">접근 방식</h2>
<h3 id="그래프-탐색--dfs">그래프 탐색 / DFS</h3>
<ol>
  <li>두 단어가 하나의 문자만 다른 경우 해당 단어로 바꿀 수 있다면, 두 단어를 이어진 두 노드라고 볼 수 있다.</li>
  <li>단어를 순회하면서 해당 단어와 한 문자만 다른 단어를 찾아 unordered_map&lt;string, vector<string>&gt; adjMap 에 넣는다.</string></li>
  <li>이 때 주의할 점은, 시작 단어는 words에 포함되어 있지 않기 때문에, wordgs 순회 전 begin도 words에 넣어줘야 한다.</li>
  <li>그리고 DFS에 사용하기 위한 방문 기록용 unordered_map&lt;string, boo&gt; vistedMap을 선언하고, words를 순회할 때 모든 단어를 false로 초기화 해준다.</li>
  <li>adjMap 초기화가 끝나면 begin을 시작점으로 해서 DFS를 진행</li>
  <li>DFS의 매개변수인 vector<string>&amp; path 의 마지막 단어가 target일 경우 path.size() 가 answer 보다 작다면 answer 를 초기화 해준다. (이 때 사용한 answer는 미리 MAX값으로 초기화)</string></li>
  <li>DFS가 끝나고 answer 가 여전히 MAX이면 0을 반환, 아니라면 answer를 반환한다. (나는 DFS를 위해 path에 시작값으로 begin을 넣어놨었기 때문에, answer-1을 반환했다.)</li>
</ol>

<h2 id="생각해-볼-점">생각해 볼 점</h2>
<ol>
  <li>DFS를 사용하면 백트래킹을 활용하여 경로탐색이 용이하다는 점을 다시금 느낄 수 있었다.</li>
  <li>begin을 미리 words에 넣어서 순회를 돌리는 것이 좋았다.</li>
</ol>

<h3 id="해시태그">해시태그</h3>
<p>#99클럽 #코딩테스트 준비 #개발자 취업 #항해99 #TIL</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;Programmers&quot;]" /><category term="Algorithm" /><category term="CodingTest" /><category term="Cpp" /><category term="TIL" /><category term="Graph" /><category term="DFS" /><summary type="html"><![CDATA[43163. 단어 변환 / c++ / level3 / 18분]]></summary></entry><entry><title type="html">Stable &amp;amp; Unstable Sort</title><link href="https://sho1007.github.io/datastructure/Stable&UnStableSort/" rel="alternate" type="text/html" title="Stable &amp;amp; Unstable Sort" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/datastructure/Stable&amp;UnStableSort</id><content type="html" xml:base="https://sho1007.github.io/datastructure/Stable&amp;UnStableSort/"><![CDATA[<h1 id="stable--unstalbe-sort">Stable &amp; Unstalbe Sort</h1>

<p>정렬 시 같은 key 값을 가지는 원소들의 순서가 유지된다면 stable sort이고, 순서가 유지되지 않는다면 unstable sort이다.</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;DataStructure&quot;]" /><category term="Sort" /><category term="DataStructure" /><summary type="html"><![CDATA[Stable &amp; Unstalbe Sort]]></summary></entry><entry><title type="html">운영체제 시작하기</title><link href="https://sho1007.github.io/operatingsystem/OperatingSystem/" rel="alternate" type="text/html" title="운영체제 시작하기" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://sho1007.github.io/operatingsystem/OperatingSystem</id><content type="html" xml:base="https://sho1007.github.io/operatingsystem/OperatingSystem/"><![CDATA[<h1 id="운영체제란">운영체제란</h1>

<p>실행할 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램</p>

<h1 id="커널-영역--사용자-영역">커널 영역 / 사용자 영역</h1>
<p><strong>커널 영역</strong> : 운영체제가 적재되는 메모리 공간 <br />
<strong>사용자 영역</strong> : 사용자가 이용하는 응용 프로그램이 적재될 커널 영역 이외의 공간</p>

<h1 id="운영체제의-핵심-서비스">운영체제의 핵심 서비스</h1>
<h2 id="프로세스-관리">프로세스 관리</h2>
<p>실행 중인 프로그램을 프로세스라고 하는데, 일반적으로 CPU는 한번에 한 프로세스만 처리할 수 있으므로 운영체제가 프로세스들을 전환해가며 CPU를 사용하게 한다. 이 때 <strong>프로세스 동기화</strong>가 필수적이고, <strong>교착 상태</strong>를 해결해야 한다.</p>
<h2 id="자원-접근-및-할당">자원 접근 및 할당</h2>
<h3 id="cpu">CPU</h3>
<p>일반적으로 메모리에 여러 프로세스가 적재되고, 하나의 CPU에는 한번에 하나의 프로세스만 실행되므로, 다른 프로세스들은 CPU를 사용할 동안 기다려야 하는데, 운영체제에서 이를 관리하는 것을 <strong>CPU 스케쥴링</strong>이라고 한다.</p>
<h3 id="메모리">메모리</h3>
<p>메모리에 적재된 프로세스들은 크기도, 주소도 다 다르다.
운영체제는 새로운 프로세스가 적재될 때의 주소를 결정해야 하고, 메모리 공간도 관리해야 한다.</p>
<h3 id="입출력장치">입출력장치</h3>
<p>인터럽트 서비스 루틴은 운영체제의 기능으로 커널 영역에 있다. 입출력장치가 발생시키는 하드웨어 인터럽트도 마찬가지이다.</p>
<h2 id="파일-시스템">파일 시스템</h2>
<p>파일 열기, 닫기, 생성, 삭제, 디렉터리 관리도 운영체제가 담당한다.</p>

<blockquote>
  <p>가상 머신은 응용 프로그램으로 사용자 모드로 실행된다. 하지만 가상 머신에 운영체제가 존재할 때, 이 운영체제는 어떻게 커널 영역의 서비스를 제공받을 수 있을까? -&gt; 가상화를 지원하는 CPU는 커널 모드와 사용자 모드 이외에 <strong>하이퍼바이저 모드</strong>를 따로 둔다. 가상 머신 위에서 작동하는 응용 프로그램들은 하이퍼바이저모드로써 운영체제 서비스를 받을 수 있다.</p>
</blockquote>

<h1 id="커널">커널</h1>
<p>운영체제의 핵심 서비스를 담당하는 부분을 커널이라고 하는데, 운영체제는 커널 이외에도 사용자 인터페이스 (GUI, CLI)도 제공한다.</p>

<h1 id="이중모드">이중모드</h1>
<p>이중모드란, CPU가 명령어를 실행하는 모드를 <strong>사용자 모드</strong>와 <strong>커널 모드</strong>로 구분하는 방식이다.</p>
<h2 id="사용-이유">사용 이유</h2>
<p>운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하고, 오직 자신을 통해서만 접근하도록 하여 자원을 보호한다. <br />
이러한 운영체제의 문지기 역할은 <strong>이중 모드</strong> 를 사용하여 구현된다.</p>
<h2 id="사용자-모드">사용자 모드</h2>
<p>운영체제의 서비스를 제공받을 수 없는 실행 모드 (슈퍼바이저 플래그 off)</p>
<h2 id="커널-모드">커널 모드</h2>
<p>운영체제 서비스를 제공받을 수 있는 실행 모드 (슈퍼바이저 플래그 on)</p>
<h2 id="시스템-호출">시스템 호출</h2>
<p>사용자 모드에서 실행되는 프로그램이 자원에 접근하기 위해 운영체제 서비스를 제공받으려면 커널 모드로 전환되어야 하는데, 이 때 <strong>시스템 호출</strong>을 통해 커널 모드로 전환할 수 있다.</p>
<blockquote>
  <p>시스템 호출도 일종의 소프트웨어 인터럽트이다.</p>
  <ol>
    <li>시스템 호출 실행 (사용자 모드 -&gt; 커널 모드)</li>
    <li>운영체제 코드 실행 (커널 모드)</li>
    <li>시스템 호출로부터 복귀 (커널 모드 -&gt; 사용자 모드)</li>
  </ol>
</blockquote>

<p>응용 프로그램은 실행 도중 빈번하게 시스템 호출을 발생시키고, 사용자 모드와 커널 모드를 오가며 실행된다.</p>]]></content><author><name>Sho1007</name></author><category term="[&quot;OperatingSystem&quot;]" /><category term="OperatingSystem" /><category term="HonGong" /><summary type="html"><![CDATA[운영체제란]]></summary></entry></feed>